<!-- Surgical patch 2025-08-29 14:56:25 IST: Removed BIU buttons; kept only Bold/Italic/Underline checkboxes -->
<!-- Surgical patch on 2025-08-29T13:38:41 IST: Removed malformed <style id="css-canvas-row4-size-before"> block; added #gridSizeLabel next to #gridSize. No other changes. -->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Canvas Designer Pro — Restore Transform &amp; Effects + Fix Center X</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400..700&amp;family=Great+Vibes&amp;family=Lobster&amp;family=Pacifico&amp;display=swap" rel="stylesheet"/>
<style id="css-core">
/* ================ CORE VARIABLES & RESET ================ */
/* Core variables & resets */
:root{
  --bg:#0f172a; --panel:#111827; --muted:#374151; --text:#e5e7eb;
  --accent:#3b82f6; --accent-2:#2563eb;
  --rowHeight: 35px;}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font:13px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
*, *::before, *::after { box-sizing: border-box; }

button,input,select,textarea{font:inherit;color:inherit}
</style>
    <!-- Canvas final override inserted at end of head to override previous styles -->
    <style id="css-canvas-final-overrides-20250830">
      /*
        Final Canvas layout fix: ensure the Canvas panel shows four distinct rows
        (Width+DPI, Height+Unit, Apply button, Size+Show/Snap controls).  Because earlier
        CSS uses high‑specificity selectors and `!important` flags to inline these rows,
        we apply extremely specific selectors with repeated IDs and `!important` to take
        precedence.  This style is placed at the very end of the head to override all
        previous rules.
      */
      /* Prevent parent Canvas panel from centering its children */
      #canvasPanel .pb {
        text-align: left !important;
      }
      /* Rows 3 and 4: full‑width flex rows */
      #canvasPanel .pb > #canvasApplyRow#canvasApplyRow#canvasApplyRow,
      #canvasPanel .pb > #canvasRow4#canvasRow4#canvasRow4 {
        display: flex !important;
        align-items: center !important;
        justify-content: flex-start !important;
        width: 100% !important;
        flex-wrap: nowrap !important;
        gap: 8px !important;
        margin: var(--row-gap) 0 !important;
        padding: 0 !important;
      }
      /* Make Apply button fill its row */
      #canvasPanel #canvasApplyRow > #applyCanvas {
        flex: 1 1 auto !important;
        width: 100% !important;
        justify-content: center !important;
      }
      /* Remove any order overrides so DOM order determines row order */
      #canvasApplyRow,
      #canvasRow4 {
        order: 0 !important;
      }
    </style>

    
<style id="css-layout">
/* ================ LAYOUT (APP/HEADER/COLUMNS/CANVAS) ================ */
/* Layout (app/header/columns/canvas) */
.app{display:flex;flex-direction:column;height:100%}

/* Header */
header{
  height:52px;display:flex;align-items:center;padding:8px 12px;
  border-bottom:1px solid var(--muted);background:#0b1224;gap:12px;
  flex-wrap:nowrap; white-space:nowrap; overflow:hidden;
}
header .row{display:flex;align-items:center;gap:6px;flex-wrap:nowrap;white-space:nowrap}
header strong { white-space: nowrap; }
header button.btn{ padding: 2px 6px; font-size: 13px; line-height: 1.2; }

/* Left / Middle / Right columns */
#left{width:76px;border-right:1px solid var(--muted);padding:10px;display:flex;flex-direction:column;gap:10px;background:#0b1224}
.tool{display:flex;flex-direction:column;align-items:center;gap:6px;background:#1f2937;border:1px solid var(--muted);border-radius:12px;height:64px;justify-content:center;cursor:pointer}
.tool.active{background:var(--accent)}

#middle{position:relative;flex:1;display:flex;overflow:hidden;background:#0f172a}
#stageWrap{position:relative;flex:1;overflow:hidden}
#stage{position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden}
canvas{position:absolute;left:0;top:0}
#canvas { z-index: 1; }
#overlay { z-index: 2; pointer-events: none; }

#right{width:390px;border-left:1px solid var(--muted);padding:12px;overflow:auto;background:#0b1224}
</style>
<style id="css-controls">
/* ================ CONTROLS (INPUTS, BUTTONS, RANGES, COLORS) ================ */
/* Controls (inputs, buttons, ranges, colors) */
.btn{background:#1f2937;border:1px solid var(--muted);padding:4px 8px;border-radius:6px;cursor:pointer}
.btn:hover{background:#2a3648}
.btn.primary{background:var(--accent);border-color:var(--accent-2)}
.btn.danger{background:#7f1d1d;border-color:#991b1b}

.row{display:flex;align-items:center;gap:10px}
.sp{flex:1}

input[type="number"],input[type="text"],select{
  background:#1f2937;border:1px solid var(--muted);border-radius:10px;padding:8px;min-width:0
}
input[type="color"]{inline-size:30px;block-size:26px;border:none;background:#1f2937;border-radius:6px;cursor:pointer}
input[type="range"]{width:100%}
</style>
<style id="css-panels">
/* ================ PANELS: BASE & COLLAPSIBLE ================ */
/* Panels: base & collapsible */
.panel{
  background:transparent;border:0;border-bottom:1px solid #2c325d;
  border-radius:0;padding:0;margin:0 0 0 0;box-shadow:none;
}
.ph{display:flex;align-items:center;justify-content:space-between;padding:6px 8px;border-bottom:0;margin:0}
.ph strong{font-weight:600;font-size:13px}
.panel .ph .row, .panel .pb .row{display:flex;flex-wrap:wrap;gap:8px 10px;align-items:center;margin:0}
.panel .pb{padding:6px 8px}
.panel .ph button.caret{background:transparent;border:0;padding:0 6px;cursor:pointer;margin-left:auto;font-size:12px;opacity:.85}
.panel .ph button.caret:focus{outline:none}
.panel.collapsed .pb{display:none !important}
</style>
<style id="css-text">
/* ================ PANEL: TEXT ================ */
/* Panel: Text */
#right .panel[data-sec="Text"] .row{
  display:flex;align-items:center;gap:8px;flex-wrap:nowrap;
}
#right .panel[data-sec="Text"] textarea#textValue{
  width:100% !important; min-height:100px !important; resize:vertical;
  border:1px solid var(--muted); border-radius:10px; padding:8px;
}
#right .panel[data-sec="Text"] select,
#right .panel[data-sec="Text"] input[type="number"],
#right .panel[data-sec="Text"] input[type="text"],
#right .panel[data-sec="Text"] button.btn{
  height: var(--rowHeight) !important; min-height: var(--rowHeight) !important;

  line-height: var(--rowHeight) !important;}
#right .panel[data-sec="Text"] label.small{ min-width:52px; white-space:nowrap; }
#right .panel[data-sec="Text"] #fontFamily { flex: 1 1 auto; min-width:160px; }
#right .panel[data-sec="Text"] #textSize { width:72px; }
#right .panel[data-sec="Text"] #textAlign { width:84px; }
#right .panel[data-sec="Text"] #lineHeight { width:72px; }
</style>
<style id="css-stroke">
/* ================ PANEL: STROKE ================ */
/* Panel: Stroke */
[data-sec="Stroke"] .row{ display:flex; align-items:center; gap:6px; flex-wrap:nowrap; }
[data-sec="Stroke"] #strokeType{ width:120px; max-width:140px; }
[data-sec="Stroke"] #transparentShapeBtn{ width:110px; min-width:110px; padding:0 8px; }

/* Dash + Color + Alpha row */
[data-sec="Stroke"] #strokeDash{ width:64px; max-width:64px; text-align:center; }
[data-sec="Stroke"] #strokeColor{ inline-size:26px; block-size:22px; }
[data-sec="Stroke"] #strokeAlpha[type="range"]{ width:120px; max-width:120px; height:22px; }
[data-sec="Stroke"] .row label.small{ min-width:0; white-space:nowrap; }

/* Width + Unit row */
[data-sec="Stroke"] #strokeW[type="range"]{ width:140px; max-width:140px; height:22px; }
[data-sec="Stroke"] #strokeUnit{ height:22px; min-width:60px; max-width:70px; padding:0 4px; font-size:12px; box-sizing:border-box; }
[data-sec="Stroke"] .row:has(#strokeW) label.small{ min-width:0; white-space:nowrap; }

/* Buttons inside Stroke panel */
[data-sec="Stroke"] .btn, [data-sec="Stroke"] button{
  height:22px; line-height:22px; padding:0 10px; font-size:12px; width:auto; min-width:72px; box-sizing:border-box; align-self:center;
}
/* keep Transparent Shape narrow (redeclare to ensure) */
[data-sec="Stroke"] #transparentShapeBtn{ width:110px; min-width:110px; }
</style>
<style id="css-canvas">
/* ================ PANEL: CANVAS ================ */
/* Panel: Canvas */
/* Fixed 100px sizing for common controls */
#cw, #ch, #unit, #dpi, #gridSize, #applyCanvas{
  width:100px; max-width:100px; height:28px; text-align:center; box-sizing:border-box;
}

/* Inline third row: Show Grid | Snap | Size | Apply */
#canvasRow3{
  display:flex; align-items:center; gap:8px; flex-wrap:nowrap; white-space:nowrap; margin:0; padding:0;
}
#canvasRow3 *{ white-space:nowrap; }
#canvasRow3 label.small{ min-width:0; width:auto; display:inline-flex; align-items:center; margin:0; padding:0; }
#canvasRow3 input[type="checkbox"]{ margin-right:8px; width:14px; height:14px; flex:0 0 auto; }
#canvasRow3 #gridSize, #canvasRow3 #applyCanvas{ width:100px; max-width:100px; height:28px; flex:0 0 auto; text-align:center; }

/* Right panel tidy alignment for fields */
#right .panel .pb .row .field{ display:inline-flex; align-items:center; gap:6px; white-space:nowrap; }
#right .panel .pb .row .field > label{ min-width:72px; text-align:left; }
#right .panel .pb .row .field > input[type="text"],
#right .panel .pb .row .field > input[type="number"]{ width:100px; max-width:120px; flex:0 0 auto; }
#right .panel .pb .row .field > select{ width:82px; max-width:120px; flex:0 0 auto; }
#right .panel .pb .row .field > input[type="checkbox"]{ width:14px; height:14px; flex:0 0 auto; }
/* === Canvas panel tuning (tight rows & hover) === */

/* 1) Margin-bottom 2px after each row */
[data-sec="Canvas"] .row,
#canvasRow3 {
  margin-bottom: 2px !important;
}

/* 2) Row 1 & Row 2: reduce label + unit spacing */
[data-sec="Canvas"] .row-tight-2 label.small {
  min-width: 40px !important;
  margin-right: 4px !important;
}
[data-sec="Canvas"] .row-tight-2 select,
[data-sec="Canvas"] .row-tight-2 input {
  margin-right: 4px !important;
}

/* 3) Row 3: show | snap | size | apply -> single line, compact */
#canvasRow3 {
  display: flex !important;
  align-items: center !important;
  flex-wrap: nowrap !important;
  gap: 6px !important;
  white-space: nowrap !important;
}
#canvasRow3 #applyCanvas {
  align-self: center !important;
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  border-radius: 6px !important;
  transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}
#canvasRow3 #applyCanvas:hover {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
}

/* === Canvas panel tuning v2 (target actual markup) === */

/* 0) Ensure our Canvas panel namespace is clear */
#canvasPanel .pb { /* container for rows */ }

/* 1) Rows 1 & 2: reduce spacing */
#canvasPanel .row-tight-2 {
  gap: 4px !important;
  margin-bottom: 2px !important;
}
#canvasPanel .row-tight-2 label.small {
  min-width: 40px !important;
  margin-right: 4px !important;
}
#canvasPanel .row-tight-2 select,
#canvasPanel .row-tight-2 input {
  margin-right: 4px !important;
  height: 28px !important;
  line-height: 28px !important;
}

/* --- Removed legacy Canvas inline-row rules.  Canvas rows now stack vertically by default. --- */

/* 4) Compact checkbox visuals */
#canvasPanel input[type="checkbox"] {
  width: 14px !important;
  height: 14px !important;
}

/* === Canvas panel spacing fix v3 === */

/* Reduce gap between labels and inputs */
#canvasPanel .row-tight-2 label.small {
  min-width: 38px !important;
  margin-right: 2px !important;
}
#canvasPanel .row-tight-2 input,
#canvasPanel .row-tight-2 select {
  margin-left: 2px !important;
}

/* Add vertical breathing space between rows */
#canvasPanel .row-tight-2,
#canvasPanel .pb > div:has(#gridShow),
#canvasPanel .pb > div:has(#gridSnap),
#canvasPanel #canvasApplyRow {
  margin-bottom: 6px !important;
}

/* === Canvas panel anti-wrap fix v5 === */

/* Base: ensure all Canvas direct rows are flex, centered, no wrap */
#canvasPanel .row-tight-2 {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
  gap: 6px !important;
}

/* Removed obsolete inline-flex rule for Canvas bottom rows and associated centering/styling. */

/* === Canvas panel anti-overflow for first two rows v6 === */

/* Reduce gaps and allow items to fit in one line */
#canvasPanel .row-tight-2 {
  gap: 4px !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
}

/* Minimal label width to save space */
#canvasPanel .row-tight-2 label.small {
  min-width: 36px !important;
  margin-right: 2px !important;
}

/* Compact control widths */
#canvasPanel #ch,
#canvasPanel #cw { 
  width: 80px !important; 
  max-width: 80px !important;
}

#canvasPanel #unit { 
  width: 60px !important; 
  max-width: 60px !important;
}

#canvasPanel #dpi,
#canvasPanel #gridSize { 
  width: 64px !important; 
  max-width: 64px !important;
}

/* Ensure controls canvas shrink if needed and don't force overflow */
#canvasPanel .row-tight-2 input,
#canvasPanel .row-tight-2 select {
  flex: 0 1 auto !important;
  min-width: 0 !important;
}

/* === Canvas panel label-control spacing fix v7 === */

/* Tighten spacing between label and input/select */
#canvasPanel .row-tight-2 label.small {
  margin: 0 2px 0 0 !important;   /* minimal space after label */
}

#canvasPanel .row-tight-2 input,
#canvasPanel .row-tight-2 select {
  margin: 0 6px 0 0 !important;   /* small space after each input/select */
}

/* Add vertical breathing room between rows */
#canvasPanel .row-tight-2 {
  margin-bottom: 8px !important;
}

/* === Canvas panel v8: label width + bottom row tidy === */

/* Slightly wider labels for readability without big gaps */
#canvasPanel .row-tight-2 label.small {
  min-width: 50px !important;
  margin-right: 4px !important;
}

/* Bottom row: Show | Snap | Size | Apply: even spacing + matching margin */
#canvasPanel .pb > div:has(#gridShow),
#canvasPanel .pb > div:has(#gridSnap),
#canvasPanel #canvasApplyRow {
  gap: 10px !important;
  margin-bottom: 8px !important;
}

/* Make Apply feel like a button, not a pill input */
#canvasPanel #applyCanvas {
  padding: 0 14px !important;
  height: 30px !important;
  border-radius: 6px !important;
}

/* === Canvas panel v9: enforce readable labels (Unit/DPI) & spacing === */

/* Make ALL labels in Canvas clearly readable and not dimmed */
#canvasPanel .pb label.small {
  color: var(--text) !important;
  opacity: 1 !important;
  white-space: nowrap !important;
  overflow: visible !important;
  text-overflow: clip !important;
  letter-spacing: normal !important;
}

/* Slightly larger min-width for labels ONLY when followed by #unit or #dpi */
#canvasPanel .row-tight-2 label.small:has(+ #unit),
#canvasPanel .row-tight-2 label.small:has(+ #dpi) {
  min-width: 56px !important;
  margin-right: 4px !important;
}

/* Keep Height/Width labels comfortable but tight */
#canvasPanel .row-tight-2 label.small:not(:has(+ #unit)):not(:has(+ #dpi)) {
  min-width: 50px !important;
  margin-right: 4px !important;
}

/* Tight but readable gap after controls */
#canvasPanel .row-tight-2 input,
#canvasPanel .row-tight-2 select {
  margin: 0 6px 0 0 !important;
}

/* Ensure dropdown/pill styles don't overlap the label */
#canvasPanel #unit,
#canvasPanel #dpi {
  position: relative !important;
  z-index: 1 !important;
}

/* Keep rows inline and centered without wrapping */
#canvasPanel .row-tight-2 {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
  gap: 6px !important;
  margin-bottom: 8px !important;
}

/* === Canvas panel v10: pure gap layout (fix overlapping "Unit" label) === */

/* Use only 'gap' for spacing; kill conflicting margins that cause overlap */
#canvasPanel .row-tight-2 {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
  gap: 6px !important;
  margin-bottom: 8px !important;
}
#canvasPanel .row-tight-2 > * {
  margin: 0 !important;           /* remove per-element margins */
}

/* Label readability and width */
#canvasPanel .row-tight-2 label.small {
  color: var(--text) !important;
  opacity: 1 !important;
  min-width: 56px !important;     /* a touch wider for "Unit" / "Width" */
  white-space: nowrap !important;
}

/* Prevent select/input visual pills from overlapping labels */
#canvasPanel .row-tight-2 select,
#canvasPanel .row-tight-2 input {
  position: relative !important;
  z-index: 1 !important;
  overflow: visible !important;
  min-width: 0 !important;
  flex: 0 0 auto !important;
}

/* Slightly tighten default control widths for the Canvas pairs */
#canvasPanel #ch, #canvasPanel #cw { width: 84px !important; max-width: 84px !important; }
#canvasPanel #unit { width: 70px !important; max-width: 70px !important; }
#canvasPanel #dpi  { width: 70px !important; max-width: 70px !important; }

/* Surgical tweak: ensure the Apply button row centers consistently */
#canvasPanel #canvasApplyRow { 
  text-align: center !important; 
}
#canvasPanel #canvasApplyRow > #applyCanvas {
  display: inline-flex !important;
}

</style>
<style id="css-transform">
/* ================ PANEL: TRANSFORM (X,Y | W,H | Rotate, Lock) ================ */

/* Base rows: single-line, centered, tight spacing */
#transformRowXY,
#transformRowWH,
#transformRowRotLock {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
  gap: 6px !important;
  margin-bottom: 8px !important;
}

/* Tight label-control spacing without shrinking labels too much */
#transformRowXY label.small,
#transformRowWH label.small,
#transformRowRotLock label.small {
  min-width: 32px !important;  /* X, Y, W, H fit well */
  margin-right: 4px !important;
  white-space: nowrap !important;
  opacity: 1 !important;
  color: var(--text) !important;
}

/* Compact numeric inputs */
#transformRowXY input[type="number"],
#transformRowWH input[type="number"],
#transformRowRotLock input[type="number"] {
  width: 84px !important;
  max-width: 84px !important;
  flex: 0 1 auto !important;
  min-width: 0 !important;
}

/* Checkbox sizing for Lock */
#transformRowRotLock input[type="checkbox"] {
  width: 16px !important;
  height: 16px !important;
  flex: 0 0 auto !important;
}
</style>
<!-- Transform panel augmentation -->
<style id="css-transform-augment">
/* === Transform panel uniform height === */
#transformRowXY label.small,
#transformRowWH label.small,
#transformRowRotLock label.small,
#transformRowXY input[type="number"],
#transformRowWH input[type="number"],
#transformRowRotLock input[type="number"],
#transformRowRotLock input[type="checkbox"] {
  height: 25px !important;
  min-height: 25px !important;
  line-height: 25px !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}
</style>
<style id="css-fill">
/* ================ PANEL: FILL (Solid + Linear Gradient layout) ================ */

/* Base rows inside Fill: compact & single line */
.panel[data-sec="Fill"] .row {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
  gap: 6px !important;
  margin-bottom: 8px !important;
}

/* --- Solid mode: Color + Alpha slider + numeric value on one row --- */
#fillSolid {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
  gap: 8px !important;
}
#fillSolid label.small { margin-right: 4px !important; }
#fillSolid input[type="color"] { inline-size: 28px !important; block-size: 24px !important; }
#fillAlpha { width: 160px !important; }
#fillAlphaL { min-width: 36px !important; text-align: center !important; display: inline-block !important; }

/* --- Gradient mode: show S1/S2 on first line, S3/S4 on second; label above slider --- */
#fillGrad { margin-top: 8px !important; }
#fillGrad .grid-2 {
  display: grid !important;
  grid-template-columns: repeat(2, minmax(140px, 1fr)) !important;
  gap: 10px 16px !important; /* row gap 10, col gap 16 */
  justify-items: center !important;
}

/* Each gradient stop cell contains a label, a colour input and a range slider.
   Lay these three elements out horizontally so the label and inputs sit on one line.
   The enclosing grid arranges cells into two columns (S1+S2 on the first row,
   S3+S4 on the second). */
#fillGrad .grid-2 > .row {
  display: flex !important;
  flex-direction: row !important;
  align-items: center !important;
  gap: 6px !important;
  margin: 0 !important;
}
#fillGrad .grid-2 > .row label.small {
  opacity: 1 !important;
  color: var(--text) !important;
  white-space: nowrap !important;
  margin-right: 4px !important;
}

/* hide per-stop color inputs; keep alpha sliders visible per your spec */
#fillGrad input[type="color"] { display: inline-block !important; }

/* Make gradient stop sliders responsive; stretch to container width */
#fillGrad input[type="range"] {
  width: 100% !important;
  max-width: 100% !important;
  flex: 1 1 auto !important;
}

/* Angle row compact */
#gAngle { width: 200px !important; }
#gAngleL { min-width: 32px !important; text-align: center !important; display: inline-block !important; }
</style>
<!-- Stroke panel augmentation -->
<style id="css-stroke-augment">
/* === Stroke panel uniform sizing & stretch === */

/* 1) Uniform heights */
[data-sec="Stroke"] label.small,
[data-sec="Stroke"] select,
[data-sec="Stroke"] input:not([type="range"]):not([type="color"]),
[data-sec="Stroke"] .btn {
  height: 28px !important;
  min-height: 28px !important;
  line-height: 28px !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* Make range+color inputs visually match height without breaking their native UI */
[data-sec="Stroke"] input[type="range"],
[data-sec="Stroke"] input[type="color"] {
  height: 28px !important;
  min-height: 28px !important;
  box-sizing: border-box !important;
}

/* 2) Stretch rows to full width and space items neatly */
[data-sec="Stroke"] .row {
  display: flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  gap: 8px !important;
  width: 100% !important;
}

/* 3) Let key sliders grow to consume remaining width */
[data-sec="Stroke"] #strokeW,
[data-sec="Stroke"] #strokeAlpha {
  flex: 1 1 auto !important;
  max-width: none !important;
}

/* 4) Keep numeric readouts compact */
[data-sec="Stroke"] #strokeWL,
[data-sec="Stroke"] #strokeAlphaL {
  flex: 0 0 auto !important;
  min-width: 36px !important;
  text-align: center !important;
}

/* 5) Dash and Color group sizing: inputs stay compact */
[data-sec="Stroke"] #strokeDash {
  width: 70px !important;
  max-width: 90px !important;
  text-align: center !important;
  flex: 0 0 auto !important;
}
[data-sec="Stroke"] #strokeColor {
  inline-size: 28px !important;
  block-size: 24px !important;
  flex: 0 0 auto !important;
}

/* 6) Type + Transparent row: let selector & button share width */
[data-sec="Stroke"] #strokeType,
[data-sec="Stroke"] #transparentShapeBtn {
  flex: 1 1 0 !important;
  max-width: none !important;
}

/* 7) Labels: remove forced min-widths inside Stroke so they don't create extra gaps */
[data-sec="Stroke"] label.small {
  min-width: auto !important;
  margin: 0 !important;
  white-space: nowrap !important;
}

/* 8) Round corner row: maintain a single row with even spacing and prevent justification from
   stretching items across the row. Without this, the general stroke row rule (justify-content:
   space-between) pushes the items apart and causes wrapping or misalignment. */
#strokeRoundRow {
  /* Display four corner pairs in a single horizontal row */
  display: flex !important;
  justify-content: flex-start !important;
  align-items: center !important;
  /* Reduce horizontal spacing between corner controls to free up space for the
     numeric inputs. A smaller gap leaves more room for the counters */
  gap: 4px !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
}

/* Each label+input pair sits together */
#strokeRoundRow .corner-pair {
  display: flex !important;
  align-items: center !important;
  /* Reduce the gap between the label and its corresponding counter so the counter
     canvas occupy more horizontal space */
  gap: 2px !important;
}

/* Corner input sizing */
#strokeRoundRow .corner-pair input[type="number"] {
  /* Ensure the numeric inputs do not flex-grow and have a fixed width. Reduce width so
     all four controls canvas fit comfortably in the panel width. */
  flex: 0 0 auto !important;
  /* Use a modest width so that all four pairs canvas fit on the same row while still
     leaving space for the numeric values. */
  width: 32px !important;
  max-width: 32px !important;
  /* Use a visible background and text color so the numbers are readable. These
     overrides ensure the inputs match the dark theme while remaining legible. */
  background-color: #0f172a !important;
  color: #d1d5db !important;
  border: 1px solid #334155 !important;
  border-radius: 4px !important;
  padding: 2px 4px !important;
  text-align: center !important;
}
</style>
<!-- Uniform height augmentation v4 (high-specificity overrides) -->
<style id="css-uniform-height">
/* === Global 35px baseline for target panels === */
[data-sec="Canvas"] label.small,
[data-sec="Transform"] label.small,
[data-sec="Fill"] label.small,
[data-sec="Stroke"] label.small,
[data-sec="Effects"] label.small,
[data-sec="Canvas"] input,
[data-sec="Transform"] input,
[data-sec="Fill"] input,
[data-sec="Stroke"] input,
[data-sec="Effects"] input,
[data-sec="Canvas"] select,
[data-sec="Transform"] select,
[data-sec="Fill"] select,
[data-sec="Stroke"] select,
[data-sec="Effects"] select,
[data-sec="Canvas"] .btn,
[data-sec="Transform"] .btn,
[data-sec="Fill"] .btn,
[data-sec="Stroke"] .btn,
[data-sec="Effects"] .btn {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  white-space: nowrap !important;
  padding: 0 10px !important;
}

/* === Stroke: per-ID overrides to defeat more specific rules === */
[data-sec="Stroke"] #strokeW,
[data-sec="Stroke"] #strokeAlpha,
[data-sec="Stroke"] #strokeDash,
[data-sec="Stroke"] #strokeColor,
[data-sec="Stroke"] #strokeType,
[data-sec="Stroke"] #transparentShapeBtn,
[data-sec="Stroke"] #strokeWL,
[data-sec="Stroke"] #strokeAlphaL {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 10px !important;
}

/* Fix color input intrinsic box */
[data-sec="Stroke"] #strokeColor {
  inline-size: 35px !important;
  block-size: 35px !important;
  padding: 0 !important;
}

/* === Transform: explicit targeting === */
#transformRowXY input[type="number"],
#transformRowWH input[type="number"],
#transformRowRotLock input[type="number"],
#transformRowRotLock input[type="checkbox"],
#transformRowXY label.small,
#transformRowWH label.small,
#transformRowRotLock label.small {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 10px !important;
}

/* Checkbox visual centering */
#transformRowRotLock input[type="checkbox"] {
  width: 18px !important;
  height: 18px !important; /* intrinsic box */
  padding: 0 !important;
  margin: 0 4px 0 0 !important;
  align-self: center !important;
}

/* Range inputs in Stroke should also visually match */
[data-sec="Stroke"] input[type="range"] {
  height: 35px !important;
  min-height: 35px !important;
  align-self: center !important;
}
</style>
<!-- Canvas tighten + Color width augmentation -->
<!-- Canvas Apply row tighten v2 + round color inputs + gradient compact -->
<style id="css-fill-tighter">
/* Tighter vertical height for linear gradient controls */
#fillGrad { margin-top: 2px !important; }
#fillGrad .grid-2 { gap: 4px 10px !important; }
#fillGrad .grid-2 > .row { gap: 2px !important; margin: 0 !important; }
#fillGrad .grid-2 > .row label.small { height: auto !important; line-height: 1 !important; }
/* Allow gradient stop sliders to stretch to fill the available space within their cell */
#fillGrad input[type="range"] {
  /* Constrain the gradient stop slider width so it doesn’t dominate the row */
  width: 100% !important;
  max-width: 120px !important;
}
#gAngle { width: 160px !important; }
</style>
<style id="css-effects-one-row">
#effectsTopRow {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;
}
#effectsTopRow #blendNormalLabel {
  text-transform: none !important;
  font-weight: 500 !important;
}
</style>

<style id="css-fillgrad-chip-fix">
/* Fix Fill -> Gradient stop rows after color-chip wrapping */
#fillGrad .grid-2 > .row {
  display: flex !important;
  flex-direction: row !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 6px !important;
  margin: 0 !important;
}

#fillGrad .grid-2 > .row label.small {
  min-width: 20px !important;
  margin-right: 4px !important;
}

#fillGrad .color-chip-25 {
  flex: 0 0 auto !important;
}

#fillGrad input[type="range"] {
  flex: 1 1 auto !important;
  max-width: 160px !important;
}
</style>
<style id="css-color-25px-authority">
header input[type="color"],
#right input[type="color"],
[data-sec] input[type="color"],
input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  display: inline-block !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
  vertical-align: middle !important;
}
header input[type="color"], #right input[type="color"] { align-self: center !important; }
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }
input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }
</style>

<!-- Additional stroke panel adjustments for button sizing and spacing -->
<style id="css-stroke-adjustments-20250830">
/* Transparent button: unify font size and padding to match other buttons */
[data-sec="Stroke"] #transparentShapeBtn {
  font-size: 14px !important;
  line-height: 1.2 !important;
  padding: 0 12px !important;
}
/* Stretch width and alpha sliders to fill available row width */
[data-sec="Stroke"] #strokeW,
[data-sec="Stroke"] #strokeAlpha {
  flex: 1 1 0 !important;
  width: 100% !important;
}
/* Increase spacing between Inside/Center/Outside buttons */
#strokeAlignGroup {
  gap: 12px !important;
}
/* Ensure align buttons share equal width within their container */
#strokeAlignGroup .btn {
  flex: 1 1 0 !important;
}
</style>

<!-- Global uniform vertical spacing between rows across panels -->
<style id="css-global-row-gap-20250830">
#right .panel .row {
  margin-bottom: 8px !important;
}
</style>

<!-- Add subtle 1px boundary around each panel for visual separation -->
<style id="css-panel-boundary-20250830">
#right .panel {
  border: 1px solid var(--muted) !important;
  border-radius: 8px !important;
  padding-bottom: 4px !important;
  margin-bottom: 12px !important;
}
#right .panel .ph {
  border-bottom: 1px solid var(--muted) !important;
  border-radius: 8px 8px 0 0 !important;
}
#right .panel.collapsed {
  /* When collapsed, remove internal padding to keep header height consistent */
  padding-bottom: 0 !important;
}
</style>
<style id="css-fillgrad-native-25">
/* Keep gradient stop color inputs native, but force perfect 25px circles */
#right .panel[data-sec="Fill"] #fillGrad input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  display: inline-block !important; /* Fixed: Ensure color inputs are visible */
  box-sizing: border-box !important;
  overflow: hidden !important;
}
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }
</style>
<style id="css-colorpicker-uniformheight-fix-and-slider-tighten">
/* 1) Remove global uniform-height effect ONLY for color pickers */
header input[type="color"],
#right input[type="color"],
[data-sec] input[type="color"],
input[type="color"] {
  height: 25px !important;
  min-height: 25px !important;
  line-height: 25px !important;
  padding: 0 !important;
  margin: 0 !important;
  display: inline-block !important;
  border: none !important;
  background: none !important;
  width: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
}

/* Keep internal swatch perfectly round */
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }
input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }

/* 2) Reduce slider widths to prevent overlapping boundaries */

/* Fill panel sliders */
#right .panel[data-sec="Fill"] #fillAlpha { width: 140px !important; max-width: 140px !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="range"] { width: 130px !important; max-width: 130px !important; }
#right .panel[data-sec="Fill"] #gAngle { width: 160px !important; max-width: 160px !important; }

/* Stroke panel sliders */
#right .panel[data-sec="Stroke"] #strokeW { width: 140px !important; max-width: 140px !important; }
#right .panel[data-sec="Stroke"] #strokeAlpha { width: 140px !important; max-width: 140px !important; }

/* Effects panel sliders */
#right .panel[data-sec="Effects"] #shAlpha { width: 140px !important; max-width: 140px !important; }
</style>
<style id="css-fillgrad-2x2-pure">
/* Make the gradient stops appear as two columns: (S1 S2) on first row, (S3 S4) on second */
#fillGrad .grid-2 {
  display: grid !important;
  grid-template-columns: repeat(2, minmax(160px, 1fr)) !important;
  gap: 10px 22px !important; /* row gap, column gap */
  justify-items: stretch !important;
  align-items: start !important;
}

/* Each stop row becomes a mini grid: 
   label on top across both columns, then color + slider below */
#fillGrad .grid-2 > .row {
  display: grid !important;
  grid-template-columns: auto 1fr !important;
  grid-template-areas:
    "lab lab"
    "col rng" !important;
  column-gap: 10px !important;
  row-gap: 6px !important;
  margin: 0 !important;
}

/* Place elements into areas */
#fillGrad .grid-2 > .row label.small { 
  grid-area: lab; 
  justify-self: start;
  opacity: 0.95 !important;
  margin: 0 !important;
}
#fillGrad .grid-2 > .row input[type="color"] { 
  grid-area: col; 
  width: 25px !important; height: 25px !important;
  inline-size: 25px !important; block-size: 25px !important;
  border-radius: 50% !important;
}
#fillGrad .grid-2 > .row input[type="range"] { 
  grid-area: rng; 
  width: 120px !important; max-width: 120px !important;
}

/* Hide any trailing span right after a range (end-of-slider text) inside Fill panel */
.panel[data-sec="Fill"] input[type="range"] + span { display: none !important; }
</style>
<style id="css-effects-tidy">
#effectsTopRow, #effectsAlphaOnly {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;
}
#effectsTopRow select#blendMode {
  width: 140px !important;
}
</style><style id="css-text-rows-35">
/* Text panel three-row layout with 35px controls */
.panel[data-sec="Text"] .row > label.small,
.panel[data-sec="Text"] .row > input,
.panel[data-sec="Text"] .row > select,
.panel[data-sec="Text"] .row > button {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  display: inline-flex !important;
  align-items: center !important;
  box-sizing: border-box !important;
}
.panel[data-sec="Text"] #textRowSizeAlign #fontSize { width: 90px !important; }
.panel[data-sec="Text"] #textRowSizeAlign #textAlign { width: 84px !important; }
.panel[data-sec="Text"] #textRowLineStyles #lineHeight { width: 72px !important; }
.panel[data-sec="Text"] .row { gap: 8px !important; }

/* Keep textarea unaffected */
.panel[data-sec="Text"] textarea#textValue { min-height: 100px !important; height: auto !important; }
</style><style id="css-layers-gap-final">
/* Layers panel: add small gap between eye / lock / name */
.panel[data-sec="Layers"] #layers .layer {
  display: flex !important;
  align-items: center !important;
  gap: 6px !important;
}

/* Keep layer name flexible */
.panel[data-sec="Layers"] #layers .layer > span {
  flex: 1 1 auto !important;
}
</style>

<style id="css-right-hover">
/* Hover effect for right-side panel headers */
#right .panel .ph {
  cursor: pointer;
  transition: background 0.25s ease, color 0.25s ease;
}
#right .panel .ph:hover {
  background: rgba(59,130,246,0.15); /* soft accent background */
  color: var(--accent);
}
#right .panel.open .ph {
  background: rgba(59,130,246,0.25);
  color: var(--accent-2);
}
</style>

<style id="css-right-remove-caret">
/* Remove the tiny caret button from right-side panel headers */
#right .panel .ph button.caret {
  display: none !important;
}
</style>

<style id="css-right-allcaps">
/* Make right-side panel header text ALL CAPS */
#right .panel .ph strong {
  text-transform: uppercase !important;
  letter-spacing: 0.5px;
}
</style>

<style id="css-right-hover-animated">
/* Animated hover + distinct opened color for right-side panel headers */
#right .panel .ph {
  cursor: pointer;
  transition: background 200ms ease, box-shadow 200ms ease, color 200ms ease, transform 120ms ease;
  border-radius: 8px;
}

/* Hover animation with a different color (indigo -> blue sweep) */
#right .panel .ph:hover {
  background: linear-gradient(90deg, rgba(99,102,241,0.18), rgba(59,130,246,0.18));
  box-shadow: 0 0 0 1px rgba(59,130,246,0.35) inset;
  transform: translateY(-1px);
  color: #c7d2fe; /* light indigo text */
}

/* Opened (expanded) section: distinct, steady color */
#right .panel:not(.collapsed) .ph {
  background: rgba(59,130,246,0.22); /* richer blue */
  box-shadow: 0 0 0 1px rgba(59,130,246,0.45) inset;
  color: #e5f0ff;
}

/* Keep ALL CAPS styling intact from previous step */
#right .panel .ph strong {
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
</style>

<style id="css-topbar-35px">
/* Top bar: make specific buttons height 35px only */
header #centerView,
header #centerX,
header #toggleGuides,
header #openProj,
header #saveProj,
header #exportImg,
header #printBtn,
header #clearAll {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 12px !important;
  box-sizing: border-box !important;
}
</style>

<style id="css-topbar-35px-hover">
/* Hover color effect for selected top bar buttons */
header #centerView:hover,
header #centerX:hover,
header #toggleGuides:hover,
header #openProj:hover,
header #saveProj:hover,
header #exportImg:hover,
header #printBtn:hover,
header #clearAll:hover {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
  transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}
</style>

<style id="css-panel-buttons-hover">
/* Canvas section - Apply button */
#canvasPanel #applyCanvas:hover,
/* Fill section - Canvas, Shape, Text buttons */
#right .panel[data-sec="Fill"] #toCanvas:hover,
#right .panel[data-sec="Fill"] #toShape:hover,
#right .panel[data-sec="Fill"] #toText:hover,
/* Stroke section - Transparent button */
#right .panel[data-sec="Stroke"] #transparentShapeBtn:hover,
/* Effects section - None button */
#right .panel[data-sec="Effects"] #effectsNone:hover,
/* Layers section - Bring & Send buttons */
#right .panel[data-sec="Layers"] #bringF:hover,
#right .panel[data-sec="Layers"] #sendB:hover {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
  transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}
</style>

<style id="css-layers-buttons-35px">
/* Force Bring & Send buttons in Layers section to 35px height */
#right .panel[data-sec="Layers"] #bringF,
#right .panel[data-sec="Layers"] #sendB {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 12px !important;
  box-sizing: border-box !important;
}
</style>

<style id="css-left-light-bg">
/* Lighter background color for left side section */
#left {
  background: #1e293b !important; /* lighter slate color */
}
</style>

<style id="css-panels-light-bg">
/* Lighter background for left, right, and top bar */
#left {
  background: #1e293b !important; /* lighter slate */
}
#right {
  background: #1e293b !important; /* same lighter slate for consistency */
}
header {
  background: #1e293b !important; /* unify top bar with side panels */
  border-bottom: 1px solid #334155 !important;
}
/* Optional: soften tool tile background to harmonize */
#left .tool {
  background: #273449 !important;
  border-color: #374151 !important;
}
#left .tool.active {
  background: var(--accent) !important;
}
</style>

<style id="css-canvas-show-snap-to-button">
/* Convert Show/Snap to buttons: hide original checkboxes, keep behavior intact */
#canvasPanel #gridShow,
#canvasPanel #gridSnap {
  display: none !important;
}
</style>

<style id="css-canvas-hide-show-snap-labels">
/* Hide the text labels next to Show and Snap buttons in Canvas panel */
#canvasPanel label.small[for="gridShow"],
#canvasPanel label.small[for="gridSnap"],
#canvasPanel .row > label.small:first-child {
  display: none !important;
}
</style>

<style id="css-canvas-show-snap-active">
/* Active state color for Show/Snap buttons */
#canvasPanel #gridShowBtn,
#canvasPanel #gridSnapBtn {
  transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}

/* When corresponding checkbox is checked (On) */
#canvasPanel #gridShow:checked + #gridShowBtn,
#canvasPanel #gridSnap:checked + #gridSnapBtn {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
}

/* When not checked (Off), keep neutral */
#canvasPanel #gridShow:not(:checked) + #gridShowBtn,
#canvasPanel #gridSnap:not(:checked) + #gridSnapBtn {
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  color: var(--text) !important;
}
</style>

<style id="css-canvas-apply-fullwidth-strong">
#canvasPanel #canvasApplyRow {
  display: flex !important;
  width: 100% !important;
  padding: 0 !important;
  margin: 6px 0 6px 0 !important;
}
#canvasPanel #canvasApplyRow > #applyCanvas {
  display: inline-flex !important;
  /* Do not stretch apply button across the row */
  flex: 0 0 auto !important;
  width: auto !important;
  justify-content: center !important;
  align-items: center !important;
  height: 35px !important;
  padding: 0 14px !important;
}
</style>

<style id="css-canvas-row4-tight">
#canvasPanel #canvasRow4 {
  /* Lay out Size + Show/Snap horizontally with consistent spacing */
  display: flex !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 8px !important;
  margin-top: 6px !important;
}
#canvasPanel #canvasRow4 .btn {
  height: 28px !important;
  line-height: 28px !important;
  padding: 0 10px !important;
}
#canvasPanel #canvasRow4 #gridSize {
  width: 64px !important;
  max-width: 64px !important;
}
</style>

<style id="css-canvas-row4-label-clean">
/* Show the 'Size' label in Row 4 and ensure proper spacing */
#canvasRow4 label.small { display: inline-flex !important; margin-right: 4px !important; }
#canvasRow4 #gridShowBtn, #canvasRow4 #gridSnapBtn { margin: 0 !important; }
/* Hidden checkboxes: ensure zero footprint */
#canvasRow4 input[type="checkbox"] { display: none !important; }
</style>

<style id="css-canvas-row4-size-span">
#canvasRow4 #gridSizeLabel { display: inline-flex !important; margin-left: 8px; }
</style>

<style id="css-text-style-buttons">
#textStyleRow .btn {
  width: 35px !important;
  height: 35px !important;
  min-width: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 !important;
  text-align: center !important;
  font-weight: 700 !important;
  box-sizing: border-box !important;
}
#textStyleRow .btn.active {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
}
</style>

<style id="css-text-style-hide-checks">
/* Force-hide the original checkboxes so only the buttons are visible */
#right .panel[data-sec="Text"] input#bold,
#right .panel[data-sec="Text"] input#italic,
#right .panel[data-sec="Text"] input#underline {
  display: none !important;
  position: absolute !important;
  width: 0 !important;
  height: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  opacity: 0 !important;
  pointer-events: none !important;
}
</style>

<style id="css-text-style-buttons-polish">
#textStyleRow {
  display: flex !important;
  justify-content: center !important;
  align-items: center !important;
  gap: 10px !important;
  margin-top: 6px !important;
}

#textStyleRow .btn {
  width: 35px !important;
  height: 35px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  font-size: 18px !important;
  font-weight: bold !important;
  border-radius: 8px !important;
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  color: var(--text) !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25) !important;
  transition: background 0.2s, color 0.2s, border-color 0.2s, transform 0.1s !important;
}

#textStyleRow .btn:hover {
  background: rgba(59,130,246,0.15) !important;
  color: var(--accent) !important;
}

#textStyleRow .btn.active {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
  transform: translateY(-1px) !important;
}
</style>

<style id="css-text-line-biu-row">
/* Text panel: Line + B/I/U on one row */
.panel[data-sec="Text"] #textRowLineBIU {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 10px !important;
  margin-top: 6px !important;
  flex-wrap: nowrap !important;
}
.panel[data-sec="Text"] #textRowLineBIU label.small { min-width: 32px !important; }
.panel[data-sec="Text"] #textRowLineBIU #lineHeight { width: 72px !important; }

/* Buttons look professional and centered */
.panel[data-sec="Text"] #textRowLineBIU .btn {
  width: 35px !important;
  height: 35px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  font-size: 18px !important;
  font-weight: 700 !important;
  border-radius: 8px !important;
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  color: var(--text) !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25) !important;
  transition: background .2s, color .2s, border-color .2s, transform .1s !important;
}
.panel[data-sec="Text"] #textRowLineBIU .btn:hover {
  background: rgba(59,130,246,0.15) !important;
  color: var(--accent) !important;
}
.panel[data-sec="Text"] #textRowLineBIU .btn.active {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
  transform: translateY(-1px) !important;
}

/* Hide any legacy checkboxes for B/I/U if present */
.panel[data-sec="Text"] input#bold,
.panel[data-sec="Text"] input#italic,
.panel[data-sec="Text"] input#underline {
  display: none !important;
  position: absolute !important;
  width: 0 !important;
  height: 0 !important;
  opacity: 0 !important;
  pointer-events: none !important;
}
</style>

<style id="css-topbar-fmt-polish">
/* Top bar export format select: modern, clean border + custom arrow */
header select#fmt {
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  color: var(--text) !important;
  padding: 6px 34px 6px 10px !important; /* room for arrow */
  border-radius: 10px !important;
  height: 35px !important;
  line-height: 23px !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25) !important;
  outline: none !important;
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  position: relative !important;
}

/* Hover/Focus states */
header select#fmt:hover {
  border-color: var(--accent-2) !important;
}
header select#fmt:focus {
  border-color: var(--accent-2) !important;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25) !important;
}

/* Custom arrow using an inline SVG background (keeps it single-file) */
header select#fmt {
  background-image:
    url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'>\
<polyline points='6 9 12 15 18 9'/>\
</svg>");
  background-repeat: no-repeat;
  background-position: right 10px center;
  background-size: 16px 16px;
}

/* Firefox quirk: ensure the dropdown arrow area stays clickable */
header select#fmt::-ms-expand { display: none; }
</style>

<style id="css-custom-export-dropdown">
/* Container */
header .custom-select {
  position: relative;
  display: inline-block;
  min-width: 120px;
  user-select: none;
}

/* Visible selected area */
header .custom-select .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
}

/* Chevron */
header .custom-select .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
header .custom-select .options {
  position: absolute;
  left: 0; right: 0;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  max-height: 240px;
  overflow: auto;
}

/* Option item */
header .custom-select .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
}
header .custom-select .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}
header .custom-select.open .options {
  display: block;
}

/* Hide native select but keep it in DOM for JS compatibility */
header select#fmt {
  display: none !important;
}
</style>

<style id="css-custom-export-dropdown-portal">
.custom-select-portal {
  position: fixed;
  left: 0; top: 0;
  z-index: 10000;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  max-height: 240px;
  overflow: auto;
  display: none;
}
.custom-select-portal.open { display: block; }
.custom-select-portal li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
}
.custom-select-portal li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}
</style>

<style id="css-canvas-unit-custom-select">
/* Canvas Unit: custom responsive dropdown mirroring header .custom-select */
#canvasPanel .custom-select-unit {
  position: relative;
  display: inline-block;
  min-width: 90px;
  user-select: none;
  vertical-align: middle;
}

/* Visible selected area */
#canvasPanel .custom-select-unit .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  min-width: 90px;
  width: auto;
  max-width: 28vw;              /* clamp like the top bar */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Chevron */
#canvasPanel .custom-select-unit .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#canvasPanel .custom-select-unit .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;           /* grow to the longest item */
  max-width: 50vw;              /* clamp */
  max-height: 240px;
  overflow: auto;
}

#canvasPanel .custom-select-unit.open .options { display: block; }

#canvasPanel .custom-select-unit .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
}
#canvasPanel .custom-select-unit .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native select but keep behavior via JS sync */
#canvasPanel select#unit {
  display: none !important;
}
</style>

<style id="css-fill-mode-custom-select">
/* Fill -> Mode: custom responsive dropdown */
#right .panel[data-sec="Fill"] .custom-select-fill {
  position: relative;
  display: inline-block;
  min-width: 120px;
  user-select: none;
  vertical-align: middle;
}

#right .panel[data-sec="Fill"] .custom-select-fill .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  min-width: 120px;
  width: auto;
  max-width: 28vw;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#right .panel[data-sec="Fill"] .custom-select-fill .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

#right .panel[data-sec="Fill"] .custom-select-fill .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;
  max-width: 50vw;
  max-height: 240px;
  overflow: auto;
}

#right .panel[data-sec="Fill"] .custom-select-fill.open .options { display: block; }

#right .panel[data-sec="Fill"] .custom-select-fill .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
}
#right .panel[data-sec="Fill"] .custom-select-fill .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

#right .panel[data-sec="Fill"] select#fillMode {
  display: none !important;
}
</style>

<style id="css-canvas-unit-leftalign">
/* Force left alignment for Canvas -> Unit custom select */
#canvasPanel .custom-select-unit .selected {
  justify-content: flex-start !important;
  text-align: left !important;
  padding-left: 12px !important;
}
</style>

<style id="css-canvas-unit-leftalign-strong">
/* Reset inherited centering from #canvasPanel for the Unit custom select */
#canvasPanel .custom-select-unit,
#canvasPanel .custom-select-unit .selected,
#canvasPanel .custom-select-unit .options,
#canvasPanel .custom-select-unit .options li {
  text-align: left !important;
}

/* Keep content pinned to the left inside the selected chip */
#canvasPanel .custom-select-unit .selected {
  justify-content: flex-start !important;
  align-items: center !important;
}

/* Ensure list items occupy full row so text aligns left edge cleanly */
#canvasPanel .custom-select-unit .options li {
  display: block !important;
}
</style>

<style id="css-stroke-type-custom-select">
/* Stroke -> Type: custom responsive dropdown */
#right .panel[data-sec="Stroke"] .custom-select-stroke {
  position: relative;
  display: inline-block;
  min-width: 120px;
  user-select: none;
  vertical-align: middle;
  text-align: left; /* ensure left alignment in stroke panel */
}

/* Visible selected area */
#right .panel[data-sec="Stroke"] .custom-select-stroke .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start; /* left align content */
  min-width: 120px;
  width: auto;
  max-width: 28vw;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
}

/* Chevron */
#right .panel[data-sec="Stroke"] .custom-select-stroke .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#right .panel[data-sec="Stroke"] .custom-select-stroke .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;
  max-width: 50vw;
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Stroke"] .custom-select-stroke.open .options { display: block; }

#right .panel[data-sec="Stroke"] .custom-select-stroke .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Stroke"] .custom-select-stroke .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native strokeType select (mirrored via JS) */
#right .panel[data-sec="Stroke"] select#strokeType {
  display: none !important;
}
</style>

<style id="css-effects-blend-custom-select">
/* Effects -> Blend: custom responsive dropdown */
#right .panel[data-sec="Effects"] .custom-select-effects {
  position: relative;
  display: inline-block;
  min-width: 140px;
  user-select: none;
  vertical-align: middle;
  text-align: left; /* ensure left alignment */
}

/* Visible selected area */
#right .panel[data-sec="Effects"] .custom-select-effects .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start;    /* left align content */
  min-width: 140px;
  width: auto;
  max-width: 30vw;               /* clamp */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
}

/* Chevron */
#right .panel[data-sec="Effects"] .custom-select-effects .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#right .panel[data-sec="Effects"] .custom-select-effects .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;            /* grow to longest label */
  max-width: 50vw;               /* clamp */
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Effects"] .custom-select-effects.open .options { display: block; }

#right .panel[data-sec="Effects"] .custom-select-effects .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Effects"] .custom-select-effects .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native blend select (mirrored via JS) */
#right .panel[data-sec="Effects"] select#blendMode {
  display: none !important;
}
</style>

<style id="css-effects-filter-custom-select">
/* Effects -> Filter: custom responsive dropdown */
#right .panel[data-sec="Effects"] .custom-select-filter {
  position: relative;
  display: inline-block;
  min-width: 140px;
  user-select: none;
  vertical-align: middle;
  text-align: left;
}

/* Visible selected area */
#right .panel[data-sec="Effects"] .custom-select-filter .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start;   /* left align content */
  min-width: 140px;
  width: auto;
  max-width: 30vw;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
}

/* Chevron */
#right .panel[data-sec="Effects"] .custom-select-filter .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#right .panel[data-sec="Effects"] .custom-select-filter .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;
  max-width: 50vw;
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Effects"] .custom-select-filter.open .options { display: block; }

#right .panel[data-sec="Effects"] .custom-select-filter .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Effects"] .custom-select-filter .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native filter select (mirrored via JS) */
#right .panel[data-sec="Effects"] select#filterSel {
  display: none !important;
}
</style>

<style id="css-text-font-align-custom-selects">
/* Text panel: Font family custom dropdown */
#right .panel[data-sec="Text"] .custom-select-font,
#right .panel[data-sec="Text"] .custom-select-align {
  position: relative;
  display: inline-block;
  user-select: none;
  vertical-align: middle;
  text-align: left;
}

#right .panel[data-sec="Text"] .custom-select-font { min-width: 160px; }
#right .panel[data-sec="Text"] .custom-select-align { min-width: 100px; }

#right .panel[data-sec="Text"] .custom-select-font .selected,
#right .panel[data-sec="Text"] .custom-select-align .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start;  /* left align text */
  width: auto;
  max-width: 30vw;             /* responsive clamp */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#right .panel[data-sec="Text"] .custom-select-font .selected::after,
#right .panel[data-sec="Text"] .custom-select-align .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup lists */
#right .panel[data-sec="Text"] .custom-select-font .options,
#right .panel[data-sec="Text"] .custom-select-align .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;          /* expand to longest item */
  max-width: 50vw;             /* clamp */
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Text"] .custom-select-font.open .options,
#right .panel[data-sec="Text"] .custom-select-align.open .options { display: block; }

#right .panel[data-sec="Text"] .custom-select-font .options li,
#right .panel[data-sec="Text"] .custom-select-align .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Text"] .custom-select-font .options li:hover,
#right .panel[data-sec="Text"] .custom-select-align .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native selects (mirrored via JS) */
#right .panel[data-sec="Text"] select#fontFamily,
#right .panel[data-sec="Text"] select#textAlign {
  display: none !important;
}
</style>

<style id="css-effects-row-stack-fix">
/* Effects panel: ensure rows stack and don't sit side-by-side */
#right .panel[data-sec="Effects"] .pb {
  display: block !important;
}
#right .panel[data-sec="Effects"] .row {
  width: 100% !important;
  flex: 1 1 100% !important;
}

/* Make the alpha slider fill remaining space nicely */
#right .panel[data-sec="Effects"] #effectsAlphaOnly {
  display: flex !important;
  align-items: center !important;
  gap: 10px !important;
}
#right .panel[data-sec="Effects"] #effectsAlphaOnly input[type="range"] {
  flex: 1 1 auto !important;
  min-width: 140px !important;
}

/* Keep other rows tidy */
#right .panel[data-sec="Effects"] #effectsRowXY,
#right .panel[data-sec="Effects"] #effectsRowBlurFilter {
  display: flex !important;
  align-items: center !important;
  gap: 10px !important;
  width: 100% !important;
}
</style>

<style id="css-custom-dropdown-hide-scrollbar">
/* Hide scrollbar but keep scrolling for the custom dropdown portal */
.custom-select-portal {
  scrollbar-width: none;           /* Firefox */
  -ms-overflow-style: none;        /* IE/Edge legacy */
}
.custom-select-portal::-webkit-scrollbar { /* Chrome/Safari/Edge */
  width: 0;
  height: 0;
}

/* In case a non-portal list is used somewhere */
.custom-select .options {
  scrollbar-width: none;
  -ms-overflow-style: none;
}
.custom-select .options::-webkit-scrollbar {
  width: 0;
  height: 0;
}
</style>

<style id="css-portal-pointer-fix">
/* Portal must not block clicks when closed */
.custom-select-portal {
  pointer-events: none; /* ignore clicks by default */
}
.custom-select-portal.open {
  pointer-events: auto; /* interactive only when open */
  z-index: 10000;       /* ensure it overlays only when open */
}
</style>

<!-- Right panel header polish v3 -->
<style id="css-right-menu-polish-v3">
/* Add spacing between headers */
#right .panel .ph {
  margin-bottom: 6px !important;
  border-bottom: none !important;
  border-top: none !important;
}

/* Hover animation + text color fix */
#right .panel .ph {
  cursor: pointer;
  transition: background 250ms ease, color 250ms ease, transform 200ms ease, box-shadow 200ms ease;
  border-radius: 8px;
}
#right .panel .ph:hover {
  background: rgba(59,130,246,0.22);   /* brighter hover bg */
  transform: translateX(4px);          /* slide to right */
  box-shadow: 2px 0 6px rgba(59,130,246,0.35); /* glow effect */
}
#right .panel .ph:hover strong {
  color: #ffffff !important;           /* force white text */
}

/* Opened (expanded) section distinct style */
#right .panel:not(.collapsed) .ph {
  background: rgba(59,130,246,0.28);
  color: #ffffff !important;
  box-shadow: 0 0 0 1px rgba(59,130,246,0.45) inset;
}
</style>

<style id="css-fixes-20250829">
/* === SINGLE SOURCE OF TRUTH: 25×25 circular color inputs === */
#right input[type="color"],
header input[type="color"],
[data-sec] input[type="color"],
input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  display: inline-block !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
  vertical-align: middle !important;
}
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }
input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }

/* === Canvas panel: stable compact rows without :has() reliance === */
#canvasPanel .row-tight-2 {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  flex-wrap: nowrap !important;
  gap: 6px !important;
  margin-bottom: 8px !important;
}
#canvasPanel .row-tight-2 label.small {
  min-width: 50px !important;
  margin-right: 4px !important;
  white-space: nowrap !important;
  opacity: 1 !important;
  color: var(--text) !important;
}

/* Apply button consistent full-width & center */
#canvasPanel #canvasApplyRow {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 100% !important;
  padding: 0 !important;
  margin: 6px 0 !important;
}
#canvasPanel #canvasApplyRow > #applyCanvas {
  display: inline-flex !important;
  /* Do not stretch apply button across the row */
  flex: 0 0 auto !important;
  width: auto !important;
  height: 35px !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 0 14px !important;
}

/* Stroke panel: keep key sliders flexible to avoid overflow in narrow sidebars */
[data-sec="Stroke"] #strokeW,
[data-sec="Stroke"] #strokeAlpha {
  flex: 1 1 auto !important;
  min-width: 120px !important;
}

/* Minimal accessibility color contrast for hover states */
#right .panel .ph:hover {
  color: #e8eeff !important;
}

/* Fallback for browsers without :has() to reduce layout glitches */
@supports not (selector(:has(*))) {
  /* Remove rules that rely on :has() by enforcing default spacing */
  .row { gap: 8px; }
}
</style>

<style id="css-text-font-fixed-20250829">

/* Adopted from reference: fixed width for Text panel font family */
.panel[data-sec="Text"] #fontFamily {
  flex: 1 1 auto;
  min-width:160px;
}

</style>

<style id="css-text-font-wide-20250829">
/* Wider, readable font dropdown without breaking layout */
.panel[data-sec="Text"] #fontFamily {
  min-width: 200px !important;
  width: 240px !important;
  max-width: 40vw !important;
  flex: 0 0 auto !important;
}
/* Keep neighboring controls aligned */
.panel[data-sec="Text"] .row { gap: 10px; }
</style>

<style id="css-text-font-border-20250829">
/* Match reference visual style for the Font dropdown */
.panel[data-sec="Text"] #fontFamily {
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;   /* same border width as reference */
  border-radius: 10px !important;
  color: var(--text) !important;
  padding: 0 34px 0 12px !important;           /* room for native chevron */
  height: var(--rowHeight) !important;
  line-height: var(--rowHeight) !important;
  min-height: var(--rowHeight) !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
}

/* Hover/Focus to mirror reference behavior */
.panel[data-sec="Text"] #fontFamily:hover {
  border-color: var(--accent-2) !important;
}
.panel[data-sec="Text"] #fontFamily:focus {
  border-color: var(--accent-2) !important;
  outline: none !important;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25) !important;
}
</style>

<style id="css-text-font-chevron-20250829">
/* Replace native arrow with custom inline SVG chevron for Font dropdown */
.panel[data-sec="Text"] #fontFamily {
  background-image:
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 10 10'><path d='M2 3 L5 6 L8 3' fill='none' stroke='%2394a3b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>");
  background-repeat: no-repeat !important;
  background-position: right 12px center !important;
  background-size: 12px 12px !important;
  padding-right: 34px !important; /* space for chevron */
}
/* Hide native arrow in different browsers */
.panel[data-sec="Text"] #fontFamily::-ms-expand { display: none; }
.panel[data-sec="Text"] #fontFamily::-webkit-inner-spin-button,
.panel[data-sec="Text"] #fontFamily::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
</style>

<style id="css-text-font-chevron-fix-20250829">
/* Unhide native font select (reference had a rule hiding it) */
#right .panel[data-sec="Text"] select#fontFamily {
  display: inline-block !important;
  visibility: visible !important;
}

/* Ensure background chevron wins over any shorthand 'background' rules */
.panel[data-sec="Text"] #fontFamily {
  background-color: #1f2937 !important;
  background-image:
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 10 10'><path d='M2 3 L5 6 L8 3' fill='none' stroke='%2394a3b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>") !important;
  background-repeat: no-repeat !important;
  background-position: right 12px center !important;
  background-size: 12px 12px !important;
  padding-right: 34px !important;
}
</style>

<style id="css-topbar-fmt-style-20250829">
/* Match Text font dropdown design for top bar export format select (#fmt) */
header select#fmt {
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  border-radius: 10px !important;
  color: var(--text) !important;
  padding: 0 34px 0 12px !important;
  height: var(--rowHeight) !important;
  line-height: var(--rowHeight) !important;
  min-height: var(--rowHeight) !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  cursor: pointer !important;
  min-width: 140px !important;
}

/* Custom chevron */
header select#fmt {
  background-image:
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 10 10'><path d='M2 3 L5 6 L8 3' fill='none' stroke='%2394a3b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>");
  background-repeat: no-repeat !important;
  background-position: right 12px center !important;
  background-size: 12px 12px !important;
}

/* Hover/Focus */
header select#fmt:hover {
  border-color: var(--accent-2) !important;
}
header select#fmt:focus {
  border-color: var(--accent-2) !important;
  outline: none !important;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25) !important;
}
</style>

<style id="css-topbar-customselect-selected-20250829">
/* Apply Font dropdown visual design to the header custom-select */
header .custom-select .selected {
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  border-radius: 10px !important;
  color: var(--text) !important;
  height: var(--rowHeight) !important;
  line-height: var(--rowHeight) !important;
  min-height: var(--rowHeight) !important;
  padding: 0 34px 0 12px !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25) !important;
  cursor: pointer !important;
  user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  min-width: 140px !important;
}

/* Chevron color and size to match Font dropdown */
header .custom-select .selected::after {
  width: 12px !important;
  height: 12px !important;
  background: #94a3b8 !important; /* muted gray like font chevron */
  opacity: .95 !important;
}

/* Hover/Focus states */
header .custom-select .selected:hover {
  border-color: var(--accent-2) !important;
}
header .custom-select.open .selected,
header .custom-select .selected:focus {
  border-color: var(--accent-2) !important;
  outline: none !important;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25) !important;
}
</style>

<style id="css-topbar-customselect-selected-FINAL-20250829">
/* High-specificity final pass to ensure visibility */
header .custom-select.custom-select .selected.selected {
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  border-radius: 10px !important;
  color: var(--text) !important;
  height: var(--rowHeight) !important;
  line-height: var(--rowHeight) !important;
  min-height: var(--rowHeight) !important;
  padding: 0 34px 0 12px !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25) !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: flex-start !important;
  min-width: 140px !important;
  z-index: 1 !important;
}
/* Chevron override */
header .custom-select.custom-select .selected.selected::after {
  width: 12px !important;
  height: 12px !important;
  background: #94a3b8 !important;
  opacity: .95 !important;
}

/* Ensure container doesn't clip or override the selected */
header .custom-select.custom-select {
  height: var(--rowHeight) !important;
  display: inline-flex !important;
  align-items: center !important;
}

/* When open, keep same look */
header .custom-select.custom-select.open .selected.selected {
  border-color: var(--accent-2) !important;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25) !important;
}
</style>

<style id="css-fmtCustom-selected-20250829">
/* Target the concrete instance to beat any competing styles */
header #fmtCustom {
  display: inline-flex !important;
  align-items: center !important;
  height: var(--rowHeight) !important;
}
header #fmtCustom .selected {
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  border-radius: 10px !important;
  color: var(--text) !important;
  height: var(--rowHeight) !important;
  line-height: var(--rowHeight) !important;
  min-height: var(--rowHeight) !important;
  padding: 0 34px 0 12px !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25) !important;
  display: inline-flex !important;
  align-items: center !important;
  min-width: 140px !important;
}
header #fmtCustom .selected::after {
  content: "";
  position: absolute;
  width: 12px;
  height: 12px;
  right: 12px;
  pointer-events: none;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #94a3b8;
  opacity: .95;
}
/* Ensure positioning context for the chevron */
header #fmtCustom { position: relative; }
header #fmtCustom .selected { position: relative; }
</style>

<style id="css-text-font-custom-20250829">
/* Hide native Text panel font select; custom-select mirror will display */
#right .panel[data-sec="Text"] select#fontFamily { display: none !important; }

/* Custom-select 'selected' look inside Text panel */
#right .panel[data-sec="Text"] .custom-select .selected {
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  border-radius: 10px !important;
  color: var(--text) !important;
  height: var(--rowHeight) !important;
  line-height: var(--rowHeight) !important;
  min-height: var(--rowHeight) !important;
  padding: 0 34px 0 12px !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25) !important;
  display: inline-flex !important;
  align-items: center !important;
  min-width: 200px !important;
}

/* Chevron */
#right .panel[data-sec="Text"] .custom-select .selected::after {
  content: "";
  position: absolute;
  right: 12px;
  width: 12px; height: 12px;
  pointer-events: none;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #94a3b8;
  opacity: .95;
}

/* Options popup */
#right .panel[data-sec="Text"] .custom-select .options {
  background: #0f172a !important;
  border: 1px solid var(--muted) !important;
  border-radius: 12px !important;
  padding: 6px 0 !important;
  margin-top: 6px !important;
  box-shadow: 0 12px 24px rgba(0,0,0,0.35) !important;
  max-height: 240px !important;
  overflow: auto !important;
}
#right .panel[data-sec="Text"] .custom-select .options li {
  padding: 8px 12px !important;
  color: var(--text) !important;
  cursor: pointer !important;
  border-radius: 8px !important;
}
#right .panel[data-sec="Text"] .custom-select .options li:hover,
#right .panel[data-sec="Text"] .custom-select .options li.active {
  background: rgba(59,130,246,0.20) !important;
  color: #e5f0ff !important;
}
</style>

<style id="css-stroke-align-compact-20250829">
/* Restore compact width for Stroke Align dropdown, without affecting other custom-selects */
#right .panel[data-sec="Stroke"] .custom-select .selected {
  min-width: 96px !important;
  width: auto !important;
  padding-right: 28px !important; /* room for chevron */
}
#right .panel[data-sec="Stroke"] .custom-select .options {
  min-width: 120px !important;
  width: max-content !important;
}
</style>

<style id="css-text-font-fixed-width">
/* Scope: Text panel only — keeps Font list from stretching the row */
#right .panel[data-sec="Text"] select#fontFamily {
  width: clamp(180px, 24vw, 260px) !important;
  max-width: 260px !important;
  flex: 0 0 auto !important;
  white-space: nowrap !important;
  text-overflow: ellipsis !important;
  overflow: hidden !important;
}

#right .panel[data-sec="Text"] #textRowSizeAlign {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
}
</style>

<style id="css-text-align-fix-v2">
/* === Text panel: Align button should not cross panel border === */
#right .panel[data-sec="Text"] #textRowSizeAlign{
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;   /* keep everything on one line */
}

/* Constrain the custom Align select (created earlier) */
#right .panel[data-sec="Text"] .custom-select-align{
  flex: 0 0 auto !important;
  width: clamp(96px, 16vw, 140px) !important; /* fixed-but-responsive */
  max-width: 140px !important;
}

/* Make the visible trigger respect the box and never overflow */
#right .panel[data-sec="Text"] .custom-select-align .selected{
  box-sizing: border-box !important;
  width: 100% !important;
  padding-right: 30px !important;  /* room for the chevron */
  border-radius: 10px !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
}

/* Ensure the native select stays hidden so it canvas't stretch anything */
#right .panel[data-sec="Text"] select#textAlign{
  display: none !important;
}
</style>

<style id="css-text-align-fix-v3">
/* HARD WIDTH FIX for Text → Align control */
#right .panel[data-sec="Text"] #textRowSizeAlign{
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
}

/* Wrapper must never grow or shrink */
#right .panel[data-sec="Text"] .custom-select-align{
  width: 120px !important;
  max-width: 120px !important;
  min-width: 120px !important;
  flex: 0 0 120px !important;
  overflow: hidden !important;
}

/* Visible trigger respects the box */
#right .panel[data-sec="Text"] .custom-select-align .selected{
  width: 100% !important;
  height: 35px !important;
  line-height: 35px !important;
  padding: 0 28px 0 10px !important; /* space for chevron */
  border-radius: 10px !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
}

/* Align label stays compact */
#right .panel[data-sec="Text"] #textRowSizeAlign label.small{
  min-width: 40px !important;
  width: 40px !important;
  flex: 0 0 40px !important;
}

/* Native select stays hidden */
#right .panel[data-sec="Text"] select#textAlign{ display: none !important; }
</style>

<style id="css-text-align-fix-v3b">
/* Allow dropdown to render outside the trigger; keep hard width */
#right .panel[data-sec="Text"] .custom-select-align{
  overflow: visible !important;    /* was hidden */
  position: relative !important;   /* anchor for absolute options */
  z-index: 20 !important;          /* above row */
}

/* Options panel: absolute popup with high z-index */
#right .panel[data-sec="Text"] .custom-select-align .options{
  position: absolute !important;
  left: 0 !important;
  right: auto !important;
  top: calc(100% + 6px) !important;
  z-index: 9999 !important;
  background: #0f172a !important;
  border: 1px solid #334155 !important;
  border-radius: 12px !important;
  box-shadow: 0 12px 32px rgba(0,0,0,.35) !important;
  padding: 6px !important;
  list-style: none !important;
  margin: 0 !important;
  display: none !important;
  min-width: 100% !important;
  max-height: 240px !important;
  overflow: auto !important;
}

#right .panel[data-sec="Text"] .custom-select-align.open .options{
  display: block !important;
}
</style>

<style id="css-text-align-hide-native-strong">
/* Hide the native Align select with maximum strength */
#right .panel[data-sec="Text"] #textRowSizeAlign select#textAlign {
  display: none !important;
  visibility: hidden !important;
  width: 0 !important;
  height: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
  border: 0 !important;
  position: absolute !important;
  left: -99999px !important;
}
</style>

<style id="css-ui-polish-aug2025">
/* === Consolidated polish: accessibility, motion, hover === */

/* Accessible focus for all interactive controls */
button.btn:focus-visible,
header button:focus-visible,
input:focus-visible,
select:focus-visible,
textarea:focus-visible,
#left .tool:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25);
}

/* Left tool tiles: clearer hover/active states */
#left .tool {
  transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
}
#left .tool:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(0,0,0,.35);
}
#left .tool.active {
  box-shadow: 0 0 0 1px rgba(59,130,246,0.45) inset, 0 8px 22px rgba(59,130,246,.25);
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  * {
    animation: none !important;
    transition: none !important;
    scroll-behavior: auto !important;
  }
}

/* Improve clickable area for tiny controls in headers/panels */
header .row > *,
#right .panel .ph > * {
  min-height: 35px;
}
</style>

<style id="css-topbar-label-align">
/* Surgical patch — align top bar labels vertically center at 35px (exclude color inputs) */
header .row label.small,
header .row span.muted,
header .row strong,
header .row button,
header .row input:not([type="color"]),
header .row select {
  display: inline-flex !important;
  align-items: center !important;
  height: 35px !important;
  line-height: 35px !important;
}

/* Keep label text snug without extra offsets */
header .row label.small,
header .row span.muted {
  padding: 0 4px;
  margin: 0;
}
</style>
</head>
<body>
<div class="app">
<header>
<strong>Canvas Designer Pro</strong>
<div class="row">
<span class="muted">Zoom</span>
<button class="btn" id="zOut">−</button>
<!-- shorter zoom slider -->
<input id="zRange" max="4" min="0.1" step="0.05" style="width:110px" type="range" value="1"/>
<button class="btn" id="zIn">+</button>
<span class="muted" id="zLabel">100%</span>
<button class="btn" id="centerView" title="Center the view (pan)">Center View</button>
<button class="btn" id="centerX" title="Center selection horizontally on canvas">Center X</button>
<!-- Snap Color (top bar) -->
<label class="small" style="margin-left:6px">Snap Col</label>
<input id="snapColor" style="width:30px;height:26px;padding:0;border:1px solid var(--muted);border-radius:6px;background:#1f2937" title="Snap flash &amp; center-snap highlight color" type="color" value="#34d399"/>
<!-- Guides toggle + color (next to Snap Color) -->
<button class="btn" id="toggleGuides" title="Show/Hide center guides">Guides: Off</button>
<label class="small">Guide Col</label>
<input id="guideColor" style="width:30px;height:26px;padding:0;border:1px solid var(--muted);border-radius:6px;background:#1f2937" title="Center guide color" type="color" value="#60a5fa"/>
</div>
<div class="sp"></div>
<div class="row">
<button class="btn" id="openProj">Open</button>
<button class="btn primary" id="saveProj">Save .CDP</button>
<select id="fmt"><option value="image/png">PNG</option><option value="image/jpeg">JPG</option><option value="image/webp">WEBP</option></select>
<div class="custom-select" id="fmtCustom"><div class="selected">—</div><ul class="options"></ul></div>
<input id="quality" max="1" min="0.1" step="0.05" style="width:120px" type="range" value="0.92"/>
<button class="btn" id="exportImg">Export</button>
<button class="btn" id="printBtn">Print</button>
<button class="btn danger" id="clearAll" title="Remove all layers">Clear</button>
</div>
</header>
<div id="middle">
<aside id="left">
<div class="tool active" data-tool="select"><span>🖱️</span><small>Select</small></div>
<div class="tool" data-tool="rect"><span>▭</span><small>Rect</small></div>
<div class="tool" data-tool="roundrect"><span>⬒</span><small>Round</small></div>
<div class="tool" data-tool="ellipse"><span>◯</span><small>Ellipse</small></div>
<div class="tool" data-tool="line"><span>／</span><small>Line</small></div>
<div class="tool" data-tool="text"><span>T</span><small>Text</small></div>
<div class="tool" data-tool="pan"><span>✋</span><small>Hand</small></div>
<div class="tool" id="upload" style="margin-top:auto"><span>📤</span><small>Image</small></div>
</aside>
<div id="stageWrap">
<div id="stage">
<canvas id="overlay"></canvas>
<canvas id="canvas"></canvas>
<textarea id="textEdit" style="display:none;position:absolute;background:transparent;color:#fff;outline:2px dashed #3b82f6;padding:6px;border-radius:6px;resize:none"></textarea>
</div>
<div id="contextMenu"></div>
</div>
<aside id="right">
<!-- Canvas -->
<!-- Canvas -->
<div class="panel" data-sec="Canvas" id="canvasPanel">
  <div class="ph"><strong>Canvas</strong></div>
  <div class="pb">

    <!-- Row 1: Width + DPI -->
    <div class="row-tight-2">
      <label class="small">Width</label>
      <input id="cw" type="number" value="800"/>
      <label class="small">DPI</label>
      <input id="dpi" type="number" value="96"/>
    </div>

    <!-- Row 2: Height + Unit -->
    <div class="row-tight-2">
      <label class="small">Height</label>
      <input id="ch" type="number" value="600"/>
      <label class="small">Unit</label>
      <select id="unit">
        <option selected value="px">PX</option>
        <option value="cm">CM</option>
        <option value="in">INCH</option>
      </select>
    </div>

    <!-- Row 3: Apply button (full width) -->
    <div id="canvasApplyRow"
         style="display:flex;justify-content:center;width:100%;margin-top:10px;">
      <button class="btn" id="applyCanvas"
              style="min-width:120px;">Apply</button>
    </div>

    <!-- Row 4: Size + Show/Snap toggles -->
    <div id="canvasRow4" class="row-tight-2">
      <label class="small" for="gridSize">Size</label>
      <input id="gridSize" type="number" value="20"/>
      <input id="gridShow" type="checkbox" checked style="display:none"/>
      <button class="btn" id="gridShowBtn">Show: On</button>
      <input id="gridSnap" type="checkbox" checked style="display:none"/>
      <button class="btn" id="gridSnapBtn">Snap: On</button>
    </div>

  </div>
</div>

<!-- Transform -->
<div class="panel" data-sec="Transform">
<div class="ph"><strong>Transform</strong></div>
<div class="pb">
<div class="row" id="transformRowXY">
<label class="small">X</label><input id="tx" type="number"/>
<label class="small">Y</label><input id="ty" type="number"/>
</div>
<div class="row" id="transformRowWH">
<label class="small">W</label><input id="tw" type="number"/>
<label class="small">H</label><input id="th" type="number"/>
</div>
<div class="row" id="transformRowRotLock">
<label class="small">Rotate</label><input id="trot" type="number" value="0"/>
<label class="small">Lock</label><input id="tLock" type="checkbox"/>
</div>
</div>
</div>
<!-- Fill -->
<div class="panel" data-sec="Fill">
<div class="ph">
<strong>Fill</strong>
<div class="row">
<button class="btn" id="toCanvas">Canvas</button>
<button class="btn" id="toShape">Shape</button>
<button class="btn" id="toText">Text</button>
</div>
</div>
    <!-- Combined Mode + Angle row -->
    <!--
      Fill mode row: contains the fill type selector and the optional angle controls.
      When the fill type is set to “gradient”, the Angle label and slider become visible.
      We assign an id to the Angle label (gAngleLabel) so it canvas be toggled via script.
    -->
    <div class="row" id="fillModeRow" style="display:flex; align-items:center; gap:8px;">
      <label class="small">Mode</label>
      <select id="fillMode">
        <option value="none">NONE</option>
        <option value="solid" selected>SOLID</option>
        <option value="gradient">GRADIENT</option>
      </select>
      <!-- Angle controls are wrapped together so they canvas be shown/hidden as a group -->
      <div id="gAngleWrap" style="display:flex; align-items:center; gap:8px;">
        <label id="gAngleLabel" class="small">Angle</label>
        <input id="gAngle" max="180" min="-180" step="1" type="range" value="0"/>
        <span id="gAngleL">0°</span>
      </div>
    </div>
<div class="row" id="fillSolid">
<label class="small">Color</label><input id="fillColor" type="color" value="#1e90ff"/>
<label class="small">α</label><input id="fillAlpha" max="1" min="0" step="0.01" type="range" value="1"/><span id="fillAlphaL">1.00</span>
</div>
<div id="fillGrad" style="display:none;">
  <div class="grid-2">
<div class="row"><label class="small">S1</label><input id="g1" type="color" value="#1e90ff"/><input id="g1a" max="1" min="0" step="0.01" type="range" value="1"/></div>
<div class="row"><label class="small">S2</label><input id="g2" type="color" value="#7aa7ff"/><input id="g2a" max="1" min="0" step="0.01" type="range" value="1"/></div>
<div class="row"><label class="small">S3</label><input id="g3" type="color" value="#b3d2ff"/><input id="g3a" max="1" min="0" step="0.01" type="range" value="1"/></div>
<div class="row"><label class="small">S4</label><input id="g4" type="color" value="#ffffff"/><input id="g4a" max="1" min="0" step="0.01" type="range" value="1"/></div>
</div>
</div>
</div>
<!-- Stroke -->
<div class="panel" data-sec="Stroke">
<div class="ph"><strong>Stroke</strong></div>
    <!-- Row 1: Type + Transparent -->
    <div class="row" id="strokeTypeRow" style="display:flex; align-items:center; gap:8px;">
      <label class="small" for="strokeType" style="white-space:nowrap;">Type</label>
      <select id="strokeType" style="width:90px;">
        <option value="solid" selected>SOLID</option>
        <option value="gradient">GRADIENT</option>
        <option value="none">NONE</option>
      </select>
      <button class="btn transparent-inline" id="transparentShapeBtn"
              style="padding:2px 8px; font-size:12px; line-height:1; white-space:nowrap;"
              title="Make selected shape fill transparent (no fill)">
        Transparent
      </button>
    </div>
    <!-- Row 2: Width -->
    <div class="row" id="strokeWidthRow" style="display:flex; align-items:center; gap:8px;">
      <label class="small" style="white-space:nowrap;">Width</label>
      <input id="strokeW" max="32" min="0" type="range" value="2" style="flex:1 1 auto; min-width:0;"/>
      <span id="strokeWL">2</span>
    </div>
    <!-- Row 3: Dash + Color -->
    <div class="row" id="strokeDashColorRow" style="display:flex; align-items:center; gap:8px;">
      <label class="small" style="white-space:nowrap;">Dash</label>
      <input id="strokeDash" type="number" value="0" style="width:60px;"/>
      <label class="small" style="white-space:nowrap; margin-left:12px;">Color</label>
      <input id="strokeColor" type="color" value="#000000"/>
    </div>

    <!-- Row 3b: Round corners (enabled only for roundrect shapes) -->
    <div class="row" id="strokeRoundRow">
      <div class="corner-pair"><label class="small">TL</label><input id="cornerTL" type="number" min="0" value="0" /></div>
      <div class="corner-pair"><label class="small">TR</label><input id="cornerTR" type="number" min="0" value="0" /></div>
      <div class="corner-pair"><label class="small">BL</label><input id="cornerBL" type="number" min="0" value="0" /></div>
      <div class="corner-pair"><label class="small">BR</label><input id="cornerBR" type="number" min="0" value="0" /></div>
    </div>
    <!-- Row 4: Alpha -->
    <div class="row" id="strokeAlphaRow" style="display:flex; align-items:center; gap:8px;">
      <label class="small" style="white-space:nowrap;">α</label>
      <input id="strokeAlpha" max="1" min="0" step="0.01" type="range" value="1" style="flex:1 1 auto; min-width:0;"/>
      <span id="strokeAlphaL">1.00</span>
    </div>
</div>
<!-- Effects -->
<div class="panel" data-sec="Effects">
  <div class="ph"><strong>Effects</strong></div>

  <!-- Row 1: None + Blend list + Shadow + Alpha slider -->
  <div class="row" id="effectsTopRow" style="display:flex; align-items:center; gap:8px;">
    <button class="btn" id="effectsNone" title="Clear shadow, filters and reset blend" style="min-width:70px;">None</button>
    <select id="blendMode" style="flex:1 1 auto; min-width:0;">
      <option value="source-over">Normal</option>
      <option>Multiply</option><option>Screen</option><option>Overlay</option>
      <option>Darken</option><option>Lighten</option><option>Color-burn</option><option>Color-dodge</option>
      <option>Difference</option><option>Exclusion</option><option>Hard-light</option><option>Soft-light</option>
      <option>Lighter</option>
    </select>
    <label class="small" style="white-space:nowrap;">Shadow</label>
    <input id="shColor" type="color" value="#000000"/>
    <label class="small" style="margin-left:8px; white-space:nowrap;">α</label>
    <input id="shAlpha" type="range" min="0" max="1" step="0.01" value="0" style="flex:1 1 auto; min-width:0;"/>
    <span id="shAlphaL">0.00</span>
  </div>

  <!-- Row 3: X / Y -->
  <div class="row" id="effectsRowXY" style="display:flex; align-items:center; gap:8px; flex-wrap:nowrap;">
    <label class="small" style="white-space:nowrap;">X</label>
    <input id="shX" type="number" value="0" style="width:60px;"/>
    <label class="small" style="white-space:nowrap; margin-left:8px;">Y</label>
    <input id="shY" type="number" value="0" style="width:60px;"/>
  </div>

  <!-- Row 4: Blur / Filter -->
  <div class="row" id="effectsRowBlurFilter" style="display:flex; align-items:center; gap:8px; flex-wrap:nowrap;">
    <label class="small" style="white-space:nowrap;">Blur</label>
    <input id="shBlur" type="number" value="12" style="width:60px;"/>
    <label class="small" style="white-space:nowrap; margin-left:8px;">Filter</label>
    <select id="filterSel" style="width:100%;">
      <option value="none">None</option>
      <option value="Grayscale(1)">grayscale</option>
      <option value="Sepia(1)">sepia</option>
      <option value="Contrast(1.3)">contrast +</option>
      <option value="Brightness(1.2)">brightness +</option>
      <option value="Blur(2px)">blur</option>
    </select>
  </div>
</div>

<!-- Text -->
<div class="panel" data-sec="Text">
<div class="ph"><strong>Text</strong></div>
<div class="row" style="margin-bottom:8px">
<textarea id="textValue" placeholder="Double-click a text layer to edit..." rows="3" style="width:100%;background:#1f2937;border:1px solid var(--muted);border-radius:10px;padding:8px"></textarea>
</div>
<div class="row" style="margin-bottom:8px">
<label class="small">Font</label>
<select id="fontFamily" style="flex:1">
<option>Arial</option>
<option>Helvetica</option>
<option>Tahoma</option>
<option>Roboto</option>
<option>Georgia</option>
<option>Times New Roman</option>
<option>Courier</option>
<option>Consolas</option>
<option>Monotype Corsiva</option>
<option>Brush Script MT</option>
<option>Lucida Handwriting</option>
<option>Comic Sans MS</option>
<option>Pacifico</option>
<option>Great Vibes</option>
<option>Dancing Script</option>
<option>Lobster</option>
</select>
</div><div class="row" id="textRowSizeAlign"><label class="small">Size</label><input id="fontSize" style="width:90px" type="number" value="28"/><label class="small" for="textAlign" style="display:inline-flex; width:auto; margin:0; padding:0; white-space:nowrap;">
      Align
    </label><select id="textAlign" style="width:70px;">
<option>Left</option>
<option>Center</option>
<option>Right</option>
<option>Justify</option>
</select></div>
<div class="row" id="textRowLineBIU">
  <label class="small">Line</label>
  <input id="lineHeight" type="number" step="0.1" value="1.3"/>
  <!-- Hidden checkboxes kept for backward compatibility -->
  <input id="bold" type="checkbox" style="display:none"/>
  <button class="btn" id="boldBtn" title="Bold">B</button>
  <input id="italic" type="checkbox" style="display:none"/>
  <button class="btn" id="italicBtn" title="Italic">I</button>
  <input id="underline" type="checkbox" style="display:none"/>
  <button class="btn" id="underlineBtn" title="Underline">U</button>
</div>

</div>
<!-- Layers -->
<div class="panel" data-sec="Layers">
<div class="ph"><strong>Layers</strong></div>
<div id="layers" style="max-height:calc(100vh - 460px); overflow:auto"></div>
<!-- Row: Bring / Send -->
<div style="margin-top:10px; display:flex; justify-content:center; align-items:center; gap:8px;">
<div style="display:flex; align-items:center; gap:2px;">
<button class="btn" id="bringF" style="padding:4px 10px; font-size:13px; line-height:1; white-space:nowrap; min-width:70px;" title="Bring Forward">
        Bring
      </button>
</div>
<div style="display:flex; align-items:center; gap:2px;">
<button class="btn" id="sendB" style="padding:4px 10px; font-size:13px; line-height:1; white-space:nowrap; min-width:70px;" title="Send Back">
        Send
      </button>
</div>
</div>
</div>
</aside>
</div>
</div>
<!-- hidden inputs -->
<input accept="image/*" id="imgInput" style="display:none" type="file"/>
<input accept=".cdp,.json" id="projInput" style="display:none" type="file"/>

<script>

// ===== Canvas Elements =====
const canvas = document.getElementById("canvas");
const overlay  = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const octx = overlay.getContext("2d");

(function(){
  // Helpers to locate a Fabric.js canvas if present
  function getCanvas(){
    // Primary known globals
    var c = window.canvas || window.fabricCanvas || (window.editor && window.editor.canvas) || null;
    if (c && typeof c.getActiveObject === 'function') return c;
    // Fabric fallback: find .upper-canvas and read __canvas
    try {
      var upper = document.querySelector('.upper-canvas');
      if (upper && upper.__canvas && typeof upper.__canvas.getActiveObject === 'function') return upper.__canvas;
    } catch(e){}
    // Try id #c (common)
    try {
      var el = document.getElementById('c');
      if (el && el.__canvas && typeof el.__canvas.getActiveObject === 'function') return el.__canvas;
    } catch(e){}
    return null;
  }
  function getActiveTextObject(c){
    if(!c || !c.getActiveObject) return null;
    const obj = c.getActiveObject();
    if(!obj) return null;
    const t = (obj.type || '').toLowerCase();
    if(t === 'textbox' || t === 'text') return obj;
    return null;
  }
  function requestRender(c){
    try { c.requestRenderAll && c.requestRenderAll(); } catch(e){}
  }

  // 1) Text alignment: wire up #textAlign and [data-align] buttons
  function installTextAlignHandlers(){
    const c = getCanvas();
    function applyAlign(align){
      const canvas = getCanvas();
      const obj = getActiveTextObject(canvas);
      if(obj){
        try {
          obj.set({ textAlign: align });
          if (obj.setSelectionStyles) {
            obj.setSelectionStyles({ textAlign: align });
          }
          requestRender(canvas);
        } catch(e){ console.warn('align error', e); }
      }
    }
    const sel = document.getElementById('textAlign');
    if (sel) {
      sel.addEventListener('change', function(e){ applyAlign(e.target.value); });
    }
    document.querySelectorAll('[data-align]').forEach(btn => {
      btn.addEventListener('click', function(){
        applyAlign(this.getAttribute('data-align'));
      });
    });
  }

  // 2) Clear Text panel input after editing so it doesn't carry to next textbox
  function installTextPanelClear(){
    const right = document.getElementById('right');
    if(!right) return;
    const textPanel = Array.from(right.querySelectorAll('.panel')).find(p => {
      const title = p.querySelector(':scope > .ph > strong');
      return title && title.textContent.trim().toLowerCase() === 'text';
    });
    if(!textPanel) return;
    const pb = textPanel.querySelector(':scope > .pb') || textPanel;
    // candidate fields: textarea or input[type=text]
    const input = pb.querySelector('textarea, input[type="text"], input[type="search"]');
    if(!input) return;

    // When user finishes editing here, clear it so it won't seed the next textbox
    function clearOnDone(){
      // Delay a tick to allow any existing handlers to read the value
      setTimeout(()=>{ input.value = ''; }, 50);
    }
    ['change','blur','keydown'].forEach(ev => {
      input.addEventListener(ev, function(e){
        if (ev === 'keydown' && e.key !== 'Enter') return;
        clearOnDone();
      });
    });

    // Also clear whenever selection changes away from a text object
    const c = getCanvas();
    if(c && c.on){
      const maybeClear = ()=>{
        const obj = getActiveTextObject(c);
        if(!obj){ input.value = ''; }
      };
      c.on('selection:cleared', maybeClear);
      c.on('selection:updated', maybeClear);
      c.on('selection:created', maybeClear);
      c.on('object:added', function(){ /* new object shouldn't take stale panel value */ input.value = ''; });
    }
  }

  // 3) Spacing normalization already handled via CSS; ensure no underlines on headers
  function removeUnderlines(){
    // Most handled via CSS; nothing to do here.
  }

  try {
    installTextAlignHandlers();
    installTextPanelClear();
    removeUnderlines();
  } catch(e){
    console.error('v2 inject error:', e);
  }
})();
</script><script>
(function(){
  function findPanelByTitle(name){
    const right = document.getElementById('right');
    if(!right) return null;
    name = name.toLowerCase();
    return Array.from(right.querySelectorAll('.panel')).find(p => {
      const s = p.querySelector(':scope > .ph > strong');
      return s && s.textContent.trim().toLowerCase() === name;
    });
  }
  function ensureBody(panel){ return panel.querySelector(':scope > .pb') || panel; }
  function byLabel(pb, name){
    name = name.toLowerCase();
    const lab = Array.from(pb.querySelectorAll('label')).find(l => {
      const t = (l.textContent||'').trim().toLowerCase();
      return t === name || t.startsWith(name);
    });
    if(!lab) return null;
    const id = lab.getAttribute('for');
    const ctrl = id ? document.getElementById(id) : (function(n){ while(n && n.tagName==='LABEL') n=n.nextElementSibling; return n; })(lab.nextElementSibling);
    return { label: lab, ctrl: ctrl };
  }
  function makeRow(items){
    const row = document.createElement('div');
    row.className = 'row tight';
    items.forEach(x => {
      if(!x) return;
      if (x.label && x.ctrl){
        const f = document.createElement('div'); f.className='field';
        f.appendChild(x.label); f.appendChild(x.ctrl);
        row.appendChild(f);
      } else {
        // bare element (button/checkbox group etc.)
        row.appendChild(x);
      }
    });
    return row;
  }
  function makeCheck(labObj){
    if(!labObj || !labObj.ctrl) return null;
    const wrap = document.createElement('div'); wrap.className='field';
    // some UIs put checkbox THEN label; preserve found order:
    const input = labObj.ctrl;
    // ensure input is checkbox; if label wraps input, adjust
    if (input && input.tagName === 'INPUT' && input.type === 'checkbox'){
      wrap.appendChild(input);
      wrap.appendChild(labObj.label);
      return wrap;
    }
    // If structure is different, just append both
    wrap.appendChild(labObj.label);
    if (input) wrap.appendChild(input);
    return wrap;
  }
  function reflowCanvasStrict(){
    const panel = findPanelByTitle('canvas'); if(!panel) return;
    const pb = ensureBody(panel);
    // Disable automatic Canvas reflow: preserve original DOM order defined in HTML.
    // The Canvas layout is now handled directly via markup and CSS.
    return;

    const H = byLabel(pb, 'height');
    const U = byLabel(pb, 'unit');
    const W = byLabel(pb, 'width');
    const D = byLabel(pb, 'dpi');
    const Show = byLabel(pb, 'show');
    const Snap = byLabel(pb, 'snap');
    const Size = byLabel(pb, 'size');

    // Find Apply button (by text)
    let Apply = Array.from(pb.querySelectorAll('button, .btn')).find(b => (b.textContent||'').trim().toLowerCase() === 'apply');
    if (!Apply) {
      // heuristic: any button with aria/ title Apply
      Apply = Array.from(pb.querySelectorAll('button, .btn')).find(b => {
        const t = ((b.getAttribute('title')||'') + ' ' + (b.getAttribute('aria-label')||'')).toLowerCase();
        return t.includes('apply');
      });
    }

    // Collect unique nodes to avoid duplicates when inserting
    const rows = [];

    // Build rows in user‑requested order:
    // Row 1: Width + DPI
    if (W || D) rows.push(makeRow([W, D]));
    // Row 2: Height + Unit
    if (H || U) rows.push(makeRow([H, U]));
    // Row 3: Apply button only
    const rowApply = document.createElement('div');
    rowApply.className = 'row tight';
    if (Apply) rowApply.appendChild(Apply);
    rows.push(rowApply);
    // Row 4: Size input followed by Show and Snap toggles
    const rowSize = document.createElement('div');
    rowSize.className = 'row tight';
    // Size field first
    if (Size && Size.label && Size.ctrl) {
      const f = document.createElement('div');
      f.className = 'field';
      f.appendChild(Size.label);
      f.appendChild(Size.ctrl);
      rowSize.appendChild(f);
    }
    // Show toggle
    const cShow2 = makeCheck(Show);
    if (cShow2) rowSize.appendChild(cShow2);
    // Snap toggle
    const cSnap2 = makeCheck(Snap);
    if (cSnap2) rowSize.appendChild(cSnap2);
    rows.push(rowSize);

    // Insert rows at the very top of pb (reverse order for prepend)
    for (let i = rows.length -1; i >= 0; i--) {
      const r = rows[i];
      if (r && pb.firstChild) pb.insertBefore(r, pb.firstChild);
      else if (r) pb.appendChild(r);
    }
  }

  try { reflowCanvasStrict(); } catch(e){ console.error('v8 canvas reflow error', e); }
})();
</script>

<!-- Final override to constrain gradient stop slider widths in Fill panel. This rule is placed at the end of
     the document to ensure it overrides any previous width declarations for these sliders. -->
<style id="css-fill-gradient-width-final">
  /* In the Fill section, limit gradient stop range sliders to 120px maximum so they don't overflow their grid cells. */
  #right .panel[data-sec="Fill"] #fillGrad input[type="range"] {
    /* Cap the gradient stop sliders to a relatively small width so the colour picker and label
       remain clearly visible and the slider stays well within its grid cell. */
    width: 100% !important;
    max-width: 100px !important;
  }

  /* Ensure the gradient colour stops are arranged in two columns and each stop's controls
     (label, colour picker, slider) appear on a single row. This overrides any previous
     layout definitions for the Fill panel's gradient grid. */
  #right .panel[data-sec="Fill"] #fillGrad .grid-2 {
    display: grid !important;
    grid-template-columns: repeat(2, 1fr) !important;
    gap: 8px 16px !important;
  }
  #right .panel[data-sec="Fill"] #fillGrad .grid-2 > .row {
    display: flex !important;
    flex-direction: row !important;
    align-items: center !important;
    gap: 6px !important;
    margin: 0 !important;
  }
</style>

<!-- Removed duplicate Canvas layout fix (moved to final location) -->
<script>
(function(){
  // ---------- helpers ----------
  function getCanvas(){
    // Primary known globals
    var c = window.canvas || window.fabricCanvas || (window.editor && window.editor.canvas) || null;
    if (c && typeof c.getActiveObject === 'function') return c;
    // Fabric fallback: find .upper-canvas and read __canvas
    try {
      var upper = document.querySelector('.upper-canvas');
      if (upper && upper.__canvas && typeof upper.__canvas.getActiveObject === 'function') return upper.__canvas;
    } catch(e){}
    // Try id #c (common)
    try {
      var el = document.getElementById('c');
      if (el && el.__canvas && typeof el.__canvas.getActiveObject === 'function') return el.__canvas;
    } catch(e){}
    return null;
  }
  function isTextObject(obj){
    if (!obj) return false;
    const t = String(obj.type || '').toLowerCase();
    return t === 'textbox' || t === 'text' || t === 'itext';
  }
  function getActiveTextObject(c){
    if (!c || !c.getActiveObject) return null;
    const obj = c.getActiveObject();
    return isTextObject(obj) ? obj : null;
  }
  function requestRender(c){
    try { c.requestRenderAll && c.requestRenderAll(); } catch(e){}
  }
  function snapshotOriginalIfNeeded(obj){
    if (!obj || !isTextObject(obj)) return;
    if (typeof obj.__origText === 'undefined') {
      obj.__origText = obj.text; // store original text to support ESC cancel
    }
  }
  function clearSnapshot(obj){
    if (obj && isTextObject(obj)) {
      delete obj.__origText;
    }
  }

  // ---------- elements ----------
  const btn = document.getElementById('textEditBtn');
  if (!btn) return;

  // ---------- enter editing on click ----------
  btn.addEventListener('click', function(){
    const c = getCanvas();
    const obj = getActiveTextObject(c);
    if (!obj) return;
    try {
      obj.set({ editable: true, selectable: true });
      snapshotOriginalIfNeeded(obj);
      if (obj.enterEditing) obj.enterEditing();
      // place caret at the end to avoid overwriting full text on first key
      try { if (typeof obj.text === 'string') { obj.selectionStart = obj.selectionEnd = obj.text.length; } } catch(e){}
      if (obj.hiddenTextarea) obj.hiddenTextarea.focus();
      requestRender(c);
      updateBtnState(); // reflect state immediately /*__CARET_PATCH__*/
    } catch (e) {
      console.warn('Text edit failed', e);
    }
  });

  // ---------- enable/disable button ----------
  function updateBtnState(){
    const c = getCanvas();
    const obj = getActiveTextObject(c);
    const isOnText = !!obj;
    btn.disabled = !isOnText;
    btn.setAttribute('aria-disabled', String(!isOnText));
    btn.title = isOnText ? (obj.isEditing ? 'Editing…' : 'Edit selected text') : 'Select a text to edit';
  }

  // ---------- auto-exit + snapshot on selection changes ----------
  function exitEditingIfNeeded(c){
    const obj = getActiveTextObject(c);
    if (!obj) return;
    if (obj.isEditing && !c.getActiveObject()) {
      try { obj.exitEditing && obj.exitEditing(); } catch(e){}
      requestRender(c);
    }
  }

  function onSelectionChange(){
    const c = getCanvas();
    const obj = getActiveTextObject(c);
    if (obj && obj.isEditing) snapshotOriginalIfNeeded(obj);
    updateBtnState();
    exitEditingIfNeeded(c);
  }

  // ---------- keyboard shortcuts while editing ----------
  function onKeyDown(e){
    const c = getCanvas();
    const obj = getActiveTextObject(c);
    if (!obj || !obj.isEditing) return;

    // Esc -> cancel and revert to original snapshot
    if (e.key === 'Escape') {
      e.preventDefault();
      try {
        if (typeof obj.__origText !== 'undefined') obj.text = obj.__origText;
        obj.exitEditing && obj.exitEditing();
        requestRender(c);
        clearSnapshot(obj);
      } catch(err){}
      return;
    }

    // Enter without Shift -> apply (exit editing)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault(); // prevent newline insertion
      try {
        obj.exitEditing && obj.exitEditing();
        requestRender(c);
        clearSnapshot(obj); // commit accepted
      } catch(err){}
      return;
    }

    // Shift+Enter -> allow newline (do nothing)
  }
  document.addEventListener('keydown', onKeyDown, true);

  // ---------- wire canvas events ----------
  function wireCanvasEvents(c){
    if (!c || !c.on || c.__textEditBtnWired) return;
    c.__textEditBtnWired = true;

    const refresh = () => onSelectionChange();

    // Selection lifecycle
    c.on('selection:created', refresh);
    c.on('selection:updated', refresh);
    c.on('selection:cleared', refresh);

    // When a different object is about to be selected, exit editing cleanly
    c.on('before:selection:cleared', function(e){
      const obj = e && e.target;
      if (isTextObject(obj) && obj.isEditing) {
        try { obj.exitEditing(); } catch(err){}
        clearSnapshot(obj);
      }
    });

    // Mouse interactions: clicking elsewhere should reflect state
    c.on('mouse:down', refresh);
    c.on('object:modified', refresh);

    // If the user double-clicks into a text to start editing, snapshot then
    c.on('mouse:dblclick', function(opt){
      const target = opt && opt.target;
      if (isTextObject(target)) snapshotOriginalIfNeeded(target);
    });

    // Initial state after wiring
    updateBtnState();
  }

  
  // ---------- resilience: periodic sync in case events miss ----------
(function startPanelSync(){
  function tick(){
    var c = getCanvas();
    var obj = getActiveTextObject(c);
    if (contentInput){
      if (obj){
        if (contentInput.readOnly && contentInput.value !== obj.text){
          contentInput.value = obj.text;  // keep in sync
        }
      } else {
        contentInput.value = '';
      }
    }
    setTimeout(tick, 250);
  }
  tick();
})();


  // ---------- wait for canvas, then wire ----------
  (function waitForCanvas(attempts){
    const c = getCanvas();
    if (c) { wireCanvasEvents(c); updateBtnState(); return; }
    if (attempts <= 0) {
      btn.disabled = true;
      btn.setAttribute('aria-disabled', 'true');
      btn.title = 'Canvas not ready';
      return;
    }
    setTimeout(() => waitForCanvas(attempts - 1), 150);
  })(40);
})();
</script>
<script>
// --- robust line-aware hitLayer (injected) ---
(function(){
  function distToSeg(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y, wx=p.x-a.x, wy=p.y-a.y;
    const c1=wx*vx+wy*vy; if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y);
    const c2=vx*vx+vy*vy; if(c2<=c1) return Math.hypot(p.x-b.x,p.y-b.y);
    const t=c1/c2; const proj={x:a.x+t*vx,y:a.y+t*vy};
    return Math.hypot(p.x-proj.x,p.y-proj.y);
  }
  if(typeof window.hitLayer === 'function'){
    const _orig = window.hitLayer;
    window.hitLayer = function(p){
      for(let i=state.layers.length-1;i>=0;i--){
        const L=state.layers[i]; if(!L.visible||L.locked) continue;
        if(L.type==='line'){
          const tol = 10 / (state.zoom||1);
          const d = distToSeg(p,{x:L.x,y:L.y},{x:L.x+L.w,y:L.y+L.h});
          if(d < tol) return L;
          continue;
        }
        if(p.x>=L.x&&p.x<=L.x+L.w&&p.y>=L.y&&p.y<=L.y+L.h) return L;
      }
      return null;
    };
  } else {
    window.hitLayer = function(p){
      for(let i=state.layers.length-1;i>=0;i--){
        const L=state.layers[i]; if(!L.visible||L.locked) continue;
        if(L.type==='line'){
          const tol = 10 / (state.zoom||1);
          const d = distToSeg(p,{x:L.x,y:L.y},{x:L.x+L.w,y:L.y+L.h});
          if(d < tol) return L;
          continue;
        }
        if(p.x>=L.x&&p.x<=L.x+L.w&&p.y>=L.y&&p.y<=L.y+L.h) return L;
      }
      return null;
    };
  }
})();
</script><script>
// Injected: client->canvas coordinate helper (matches existing toCanvas signature)
function toCanvasFromClient(clientX, clientY){
  const r = stage.getBoundingClientRect();
  return toCanvas(clientX - r.left, clientY - r.top);
}
</script><div id="debugHUD" style="position:fixed;right:8px;bottom:8px;z-index:99999;font:12px/1.2 system-ui,Arial;color:#e5e7eb;background:rgba(17,24,39,.8);border:1px solid #374151;padding:6px 8px;border-radius:6px;pointer-events:none;">HUD: idle</div><script>
(function(){
  const hud = document.getElementById('debugHUD');
  function hudSet(txt){ if(hud) hud.textContent = 'HUD: ' + txt; }

  // Hover feedback for selection
  stage.addEventListener('mousemove', (e)=>{
    const r = stage.getBoundingClientRect();
    const p = toCanvas(e.clientX - r.left, e.clientY - r.top);
    try {
      const h = hit(p);
      if (!h) { stage.style.cursor = 'default'; hudSet('hover: none'); return; }
      // detect handles too (if available)
      let cursor = 'move';
      try {
        const hd = (typeof handleAt==='function') ? handleAt(h, p) : null;
        if (hd && hd !== 'body') cursor = 'nwse-resize';
      } catch(_){}
      stage.style.cursor = cursor;
      hudSet('hover: ' + (h.type || '?') + ' #' + (h.id || '?'));
    } catch(err){
      hudSet('hover error: ' + err.message);
    }
  });

  // Mousedown selection report
  stage.addEventListener('mousedown', (e)=>{
    const r = stage.getBoundingClientRect();
    const p = toCanvas(e.clientX - r.left, e.clientY - r.top);
    try {
      const h = hit(p);
      hudSet('md: ' + (h ? (h.type + ' #' + h.id) : 'none'));
    } catch(err){
      hudSet('md error: ' + err.message);
    }
  });
})();
</script><script>
function pointToLineDistance(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;

  const dot = A * C + B * D;
  const len_sq = C * C + D * D;
  let param = -1;

  if (len_sq !== 0) param = dot / len_sq;

  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }

  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}
</script>
<script id="js-effects-wire-2">
(function(){
  function hex2rgb(h){
    h = (h||'').replace('#','').trim();
    if (h.length===3) { h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2]; }
    var r = parseInt(h.slice(0,2),16); if(isNaN(r)) r=0;
    var g = parseInt(h.slice(2,4),16); if(isNaN(g)) g=0;
    var b = parseInt(h.slice(4,6),16); if(isNaN(b)) b=0;
    return {r:r,g:g,b:b};
  }
  function selectedLayers(){
    try {
      var s = (window.state && window.state.selection) || [];
      var arr = [];
      if (!Array.isArray(s)) return arr;
      var layers = (window.state && window.state.layers) || [];
      s.forEach(function(id){
        var L = layers.find(function(x){ return x && x.id === id; });
        if (L) arr.push(L);
      });
      return arr;
    } catch(e){ return []; }
  }
  function ensureShadow(L){
    if (!L.sh) L.sh = {x:0,y:0,blur:12,color:{r:0,g:0,b:0,a:0}};
    if (!L.sh.color) L.sh.color = {r:0,g:0,b:0,a:0};
  }
  function redraw(){
    try {
      if (typeof window.drawAll === 'function') { window.drawAll(); return; }
      window.dispatchEvent(new Event('resize'));
    } catch(e){}
  }
  function clamp(v,min,max){ v=parseFloat(v); if(isNaN(v)) v=min; return Math.max(min, Math.min(max, v)); }

  function init(){
    var blendSel = document.getElementById('blendMode');
    var noneBtn  = document.getElementById('effectsNone');
    var shColor  = document.getElementById('shColor');
    var shAlpha  = document.getElementById('shAlpha');
    var shAlphaL = document.getElementById('shAlphaL');
    var shX      = document.getElementById('shX');
    var shY      = document.getElementById('shY');
    var shBlur   = document.getElementById('shBlur');
    var filterSel= document.getElementById('filterSel');

    if (blendSel && !blendSel.__wired){
      blendSel.addEventListener('change', function(){
        var val = blendSel.value || 'source-over';
        selectedLayers().forEach(function(L){ L.blend = val; });
        redraw();
      });
      blendSel.__wired = true;
    }

    if (noneBtn && !noneBtn.__wired){
      noneBtn.addEventListener('click', function(){
        selectedLayers().forEach(function(L){
          if (!L) return;
          L.blend = 'source-over';
          ensureShadow(L);
          L.sh.x = 0; L.sh.y = 0; L.sh.blur = 12;
          L.sh.color.a = 0;
          L.filters = 'none';
        });
        if (blendSel) blendSel.value = 'source-over';
        if (shAlpha) shAlpha.value = 0;
        if (shAlphaL) shAlphaL.textContent = '0.00';
        redraw();
      });
      noneBtn.__wired = true;
    }

    if (shColor && !shColor.__wired){
      shColor.addEventListener('input', function(){
        var rgb = hex2rgb(shColor.value||'#000000');
        selectedLayers().forEach(function(L){
          ensureShadow(L);
          L.sh.color.r = rgb.r; L.sh.color.g = rgb.g; L.sh.color.b = rgb.b;
        });
        redraw();
      });
      shColor.__wired = true;
    }

    if (shAlpha && !shAlpha.__wired){
      shAlpha.addEventListener('input', function(){
        var a = clamp(shAlpha.value,0,1);
        selectedLayers().forEach(function(L){
          ensureShadow(L);
          L.sh.color.a = a;
        });
        if (shAlphaL) shAlphaL.textContent = a.toFixed(2);
        redraw();
      });
      shAlpha.__wired = true;
    }

    function hookNum(inp, prop){
      if (!inp || inp.__wired) return;
      inp.addEventListener('input', function(){
        var v = parseFloat(inp.value);
        if (isNaN(v)) v = 0;
        selectedLayers().forEach(function(L){
          ensureShadow(L);
          if (prop==='x') L.sh.x = v;
          else if (prop==='y') L.sh.y = v;
          else if (prop==='b') L.sh.blur = v;
        });
        redraw();
      });
      inp.__wired = true;
    }
    hookNum(shX,'x'); hookNum(shY,'y'); hookNum(shBlur,'b');

    if (filterSel && !filterSel.__wired){
      filterSel.addEventListener('change', function(){
        var v = filterSel.value || 'none';
        selectedLayers().forEach(function(L){ L.filters = v; });
        redraw();
      });
      filterSel.__wired = true;
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  setTimeout(init, 120);
  setTimeout(init, 400);
})();
</script>
<script id="js-canvas-unit-custom-select">
(function(){
  function ready(fn){ if(document.readyState!=='loading'){ fn(); } else { document.addEventListener('DOMContentLoaded', fn); }}

  ready(function(){
    var unitSel = document.getElementById('unit');
    if(!unitSel || unitSel.dataset.enhanced === "1") return;

    // Build custom select after native select
    var wrap = document.createElement('div');
    wrap.className = 'custom-select custom-select-unit';
    wrap.id = 'unitCustom';
    var selected = document.createElement('div');
    selected.className = 'selected';
    selected.textContent = '—';
    var list = document.createElement('ul');
    list.className = 'options';
    wrap.appendChild(selected);
    wrap.appendChild(list);
    unitSel.insertAdjacentElement('afterend', wrap);

    // Populate options from native select
    Array.from(unitSel.options).forEach(function(opt){
      var li = document.createElement('li');
      li.textContent = opt.textContent || opt.value;
      li.dataset.value = opt.value;
      li.addEventListener('click', function(){
        unitSel.value = li.dataset.value;
        unitSel.dispatchEvent(new Event('change', {bubbles:true}));
        selected.textContent = li.textContent;
        wrap.classList.remove('open');
      });
      list.appendChild(li);
    });

    function syncFromNative(){
      var opt = unitSel.options[unitSel.selectedIndex];
      if(opt){ selected.textContent = opt.textContent || opt.value; }
    }

    selected.addEventListener('click', function(e){
      wrap.classList.toggle('open');
    });

    document.addEventListener('click', function(e){
      if(!wrap.contains(e.target)) wrap.classList.remove('open');
    });

    unitSel.addEventListener('change', syncFromNative);
    syncFromNative();
    unitSel.dataset.enhanced = "1";
  });
})();
</script>

<script id="js-fill-mode-custom-select">
(function(){
  function ready(fn){ if(document.readyState!=='loading'){ fn(); } else { document.addEventListener('DOMContentLoaded', fn); }}

  ready(function(){
    var sel = document.getElementById('fillMode');
    if(!sel || sel.dataset.enhanced === "1") return;

    var wrap = document.createElement('div');
    wrap.className = 'custom-select custom-select-fill';
    wrap.id = 'fillModeCustom';
    var selected = document.createElement('div');
    selected.className = 'selected';
    selected.textContent = '—';
    var list = document.createElement('ul');
    list.className = 'options';
    wrap.appendChild(selected);
    wrap.appendChild(list);
    sel.insertAdjacentElement('afterend', wrap);

    Array.from(sel.options).forEach(function(opt){
      var li = document.createElement('li');
      li.textContent = opt.textContent || opt.value;
      li.dataset.value = opt.value;
      li.addEventListener('click', function(){
        sel.value = li.dataset.value;
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        selected.textContent = li.textContent;
        wrap.classList.remove('open');
      });
      list.appendChild(li);
    });

    function syncFromNative(){
      var opt = sel.options[sel.selectedIndex];
      if(opt){ selected.textContent = opt.textContent || opt.value; }
    }

    selected.addEventListener('click', function(e){
      wrap.classList.toggle('open');
    });

    document.addEventListener('click', function(e){
      if(!wrap.contains(e.target)) wrap.classList.remove('open');
    });

    sel.addEventListener('change', syncFromNative);
    syncFromNative();
    sel.dataset.enhanced = "1";
  });
})();
</script>

<script id="js-stroke-type-custom-select">
(function(){
  function ready(fn){ if(document.readyState!=='loading'){ fn(); } else { document.addEventListener('DOMContentLoaded', fn); }}

  ready(function(){
    var sel = document.getElementById('strokeType');
    if(!sel || sel.dataset.enhanced === "1") return;

    // Build custom select right after the native select
    var wrap = document.createElement('div');
    wrap.className = 'custom-select custom-select-stroke';
    wrap.id = 'strokeTypeCustom';
    var selected = document.createElement('div');
    selected.className = 'selected';
    selected.textContent = '—';
    var list = document.createElement('ul');
    list.className = 'options';
    wrap.appendChild(selected);
    wrap.appendChild(list);
    sel.insertAdjacentElement('afterend', wrap);

    // Populate options from native select
    Array.from(sel.options).forEach(function(opt){
      var li = document.createElement('li');
      li.textContent = opt.textContent || opt.value;
      li.dataset.value = opt.value;
      li.addEventListener('click', function(){
        sel.value = li.dataset.value;
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        selected.textContent = li.textContent;
        wrap.classList.remove('open');
      });
      list.appendChild(li);
    });

    function syncFromNative(){
      var opt = sel.options[sel.selectedIndex];
      if(opt){ selected.textContent = opt.textContent || opt.value; }
    }

    selected.addEventListener('click', function(e){
      wrap.classList.toggle('open');
    });

    document.addEventListener('click', function(e){
      if(!wrap.contains(e.target)) wrap.classList.remove('open');
    });

    sel.addEventListener('change', syncFromNative);
    syncFromNative();
    sel.dataset.enhanced = "1";
  });
})();
</script>

<script id="js-effects-blend-custom-select">
(function(){
  function ready(fn){ if(document.readyState!=='loading'){ fn(); } else { document.addEventListener('DOMContentLoaded', fn); }}

  ready(function(){
    var sel = document.getElementById('blendMode');
    if(!sel || sel.dataset.enhanced === "1") return;

    // Build custom select right after the native select
    var wrap = document.createElement('div');
    wrap.className = 'custom-select custom-select-effects';
    wrap.id = 'blendModeCustom';
    var selected = document.createElement('div');
    selected.className = 'selected';
    selected.textContent = '—';
    var list = document.createElement('ul');
    list.className = 'options';
    wrap.appendChild(selected);
    wrap.appendChild(list);
    sel.insertAdjacentElement('afterend', wrap);

    // Populate options from native select
    Array.from(sel.options).forEach(function(opt){
      var li = document.createElement('li');
      li.textContent = opt.textContent || opt.value;
      li.dataset.value = opt.value;
      li.addEventListener('click', function(){
        sel.value = li.dataset.value;
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        selected.textContent = li.textContent;
        wrap.classList.remove('open');
      });
      list.appendChild(li);
    });

    function syncFromNative(){
      var opt = sel.options[sel.selectedIndex];
      if(opt){ selected.textContent = opt.textContent || opt.value; }
    }

    selected.addEventListener('click', function(e){
      wrap.classList.toggle('open');
    });

    document.addEventListener('click', function(e){
      if(!wrap.contains(e.target)) wrap.classList.remove('open');
    });

    sel.addEventListener('change', syncFromNative);
    syncFromNative();
    sel.dataset.enhanced = "1";
  });
})();
</script>

<script id="js-effects-filter-custom-select">
(function(){
  function ready(fn){ if(document.readyState!=='loading'){ fn(); } else { document.addEventListener('DOMContentLoaded', fn); }}

  ready(function(){
    var sel = document.getElementById('filterSel');
    if(!sel || sel.dataset.enhanced === "1") return;

    // Build custom select right after the native select
    var wrap = document.createElement('div');
    wrap.className = 'custom-select custom-select-filter';
    wrap.id = 'filterSelCustom';
    var selected = document.createElement('div');
    selected.className = 'selected';
    selected.textContent = '—';
    var list = document.createElement('ul');
    list.className = 'options';
    wrap.appendChild(selected);
    wrap.appendChild(list);
    sel.insertAdjacentElement('afterend', wrap);

    // Populate options from native select
    Array.from(sel.options).forEach(function(opt){
      var li = document.createElement('li');
      li.textContent = opt.textContent || opt.value;
      li.dataset.value = opt.value;
      li.addEventListener('click', function(){
        sel.value = li.dataset.value;
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        selected.textContent = li.textContent;
        wrap.classList.remove('open');
      });
      list.appendChild(li);
    });

    function syncFromNative(){
      var opt = sel.options[sel.selectedIndex];
      if(opt){ selected.textContent = opt.textContent || opt.value; }
    }

    selected.addEventListener('click', function(e){
      wrap.classList.toggle('open');
    });

    document.addEventListener('click', function(e){
      if(!wrap.contains(e.target)) wrap.classList.remove('open');
    });

    sel.addEventListener('change', syncFromNative);
    syncFromNative();
    sel.dataset.enhanced = "1";
  });
})();
</script>

<style id="css-right-collapse-ref">
/* --- Reference: Right panel collapse visuals --- */
#right .panel .ph {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(59, 130, 246, 0.1);
  border-bottom: 1px solid var(--muted);
  cursor: pointer;
  transition: background-color 0.2s ease;
}

#right .panel .ph:hover { background: rgba(59, 130, 246, 0.2); }

#right .panel .ph strong {
  font-weight: 600;
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

#right .panel .ph .caret {
  background: transparent;
  border: none;
  color: var(--text);
  font-size: 14px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  display: inline-block !important; /* override any previous hidden state */
}

#right .panel .ph .caret:hover { background: rgba(255, 255, 255, 0.1); }

#right .panel .pb {
  padding: 12px;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  overflow: hidden;
}

#right .panel.collapsed .pb {
  max-height: 0;
  opacity: 0;
  padding: 0;
  pointer-events: none;
}

/* Layers panel exception */
#right .panel[data-sec="Layers"] .ph { cursor: default; }
#right .panel[data-sec="Layers"] .ph .caret { display: none !important; }
</style>

<script id="js-right-collapse-ref">
(function(){
  // Fix right side panel collapse functionality
  function fixPanelCollapse() {
    const right = document.getElementById('right');
    if (!right) return;

    const panels = Array.from(right.querySelectorAll('.panel'));

    panels.forEach(panel => {
      // Ensure each panel has a header with proper structure
      let ph = panel.querySelector('.ph');
      if (!ph) {
        // Create header if it doesn't exist
        ph = document.createElement('div');
        ph.className = 'ph';

        // Find the strong element (title)
        const title = panel.querySelector('strong');
        if (title) {
          ph.appendChild(title.cloneNode(true));
          title.remove();
        } else {
          // Create title based on data-sec attribute
          const titleText = panel.getAttribute('data-sec') || 'Panel';
          const titleEl = document.createElement('strong');
          titleEl.textContent = titleText;
          ph.appendChild(titleEl);
        }

        // Add caret button
        const caret = document.createElement('button');
        caret.className = 'caret';
        caret.setAttribute('aria-label', 'Collapse/Expand');
        caret.textContent = '▾';
        ph.appendChild(caret);

        panel.insertBefore(ph, panel.firstChild);
      } else {
        // Ensure header has a caret button
        if (!ph.querySelector('.caret')) {
          const caret = document.createElement('button');
          caret.className = 'caret';
          caret.setAttribute('aria-label', 'Collapse/Expand');
          caret.textContent = '▾';
          ph.appendChild(caret);
        }
      }

      // Ensure panel has a body wrapper
      let pb = panel.querySelector(':scope > .pb');
      if (!pb) {
        pb = document.createElement('div');
        pb.className = 'pb';
        // Move all non-header elements to the body
        const children = Array.from(panel.children);
        children.forEach(child => {
          if (child !== ph) pb.appendChild(child);
        });
        panel.appendChild(pb);
      }

      // Make panel collapsible (except Layers panel)
      const title = ph.querySelector('strong');
      const isLayers = title && title.textContent.trim().toLowerCase() === 'layers';

      if (!isLayers) {
        panel.classList.add('collapsible');

        // Initial state: collapsed (unless author already set collapsed/open)
        if (!panel.classList.contains('collapsed') && !panel.dataset.initOpen) {
          panel.classList.add('collapsed');
        }

        // Click on header toggles (ignore interactive controls)
        ph.style.cursor = 'pointer';
        ph.addEventListener('click', (e) => {
          if (e.target.closest('button, input, select, textarea, a')) return;
          panel.classList.toggle('collapsed');
          const caret = ph.querySelector('.caret');
          if (caret) caret.textContent = panel.classList.contains('collapsed') ? '▸' : '▾';
        });

        // Caret click toggles without bubbling
        const caret = ph.querySelector('.caret');
        if (caret) {
          caret.textContent = panel.classList.contains('collapsed') ? '▸' : '▾';
          caret.addEventListener('click', (e) => {
            e.stopPropagation();
            panel.classList.toggle('collapsed');
            caret.textContent = panel.classList.contains('collapsed') ? '▸' : '▾';
          });
        }
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixPanelCollapse, { once: true });
  } else {
    fixPanelCollapse();
  }
})();
</script>

<style id="css-collapse-overflow-fix">
/* Allow dropdowns to overflow the panel body when expanded */
#right .panel .pb { 
  overflow: visible !important; 
}

/* Keep clipping only while collapsed */
#right .panel.collapsed .pb { 
  overflow: hidden !important; 
}

/* Make sure headers don't clip any positioned children */
#right .panel .ph { 
  overflow: visible !important; 
}

/* Raise popup lists above panel content */
#right .panel .options,
#right .custom-select .options,
#right .custom-select-unit .options,
#right .panel[data-sec="Fill"] .custom-select-fill .options {
  z-index: 9999 !important;
}
</style>

<script id="js-fixes-20250829">
(function(){
  // Helper: toggles a checkbox when a button is clicked, and adds/removes .active
  function wireToggle(btnId, chkId, ariaLabel){
    var btn = document.getElementById(btnId);
    var chk = document.getElementById(chkId);
    if(!btn || !chk) return;
    // initial state
    if(chk.checked){ btn.classList.add('active'); }
    btn.setAttribute('role','button');
    btn.setAttribute('aria-pressed', chk.checked ? 'true' : 'false');
    if(ariaLabel && !btn.getAttribute('aria-label')) btn.setAttribute('aria-label', ariaLabel);
    btn.addEventListener('click', function(e){
      e.preventDefault();
      chk.checked = !chk.checked;
      btn.classList.toggle('active', chk.checked);
      btn.setAttribute('aria-pressed', chk.checked ? 'true' : 'false');
      // fire change for any listeners
      var evt = new Event('change', {bubbles:true});
      chk.dispatchEvent(evt);
    });
  }

  // Grid Show/Snap buttons (Canvas panel)
  wireToggle('gridShowBtn', 'gridShow', 'Toggle grid visibility');
  wireToggle('gridSnapBtn', 'gridSnap', 'Toggle snap to grid');

  // Optional: Bold/Italic/Underline if present (Text panel)
  wireToggle('boldBtn', 'bold', 'Toggle bold');
  wireToggle('italicBtn', 'italic', 'Toggle italic');
  wireToggle('underlineBtn', 'underline', 'Toggle underline');

  // Header custom export dropdown -> sync back to hidden native select#fmt if present
  (function(){
    var real = document.querySelector('header select#fmt');
    var custom = document.querySelector('header .custom-select');
    if(!real || !custom) return;
    var selected = custom.querySelector('.selected');
    var list = custom.querySelector('.options');
    function close(){ custom.classList.remove('open'); }
    selected.addEventListener('click', function(e){
      e.stopPropagation();
      custom.classList.toggle('open');
    });
    list.addEventListener('click', function(e){
      var li = e.target.closest('li[data-value]');
      if(!li) return;
      var val = li.getAttribute('data-value');
      // update native select
      var opt = Array.from(real.options).find(o => o.value == val || o.textContent.trim() == li.textContent.trim());
      if(opt){ real.value = opt.value; real.dispatchEvent(new Event('change', {bubbles:true})); }
      selected.textContent = li.textContent.trim();
      close();
    });
    document.addEventListener('click', close);
  })();

  // Canvas Unit custom-select -> sync with hidden select#unit if present
  (function(){
    var unitReal = document.querySelector('#canvasPanel select#unit');
    var cs = document.querySelector('#canvasPanel .custom-select-unit');
    if(!unitReal || !cs) return;
    var selected = cs.querySelector('.selected');
    var list = cs.querySelector('.options');
    function close(){ cs.classList.remove('open'); }
    selected.addEventListener('click', function(e){
      e.stopPropagation();
      cs.classList.toggle('open');
    });
    list.addEventListener('click', function(e){
      var li = e.target.closest('li[data-value]');
      if(!li) return;
      var val = li.getAttribute('data-value');
      var opt = Array.from(unitReal.options).find(o => o.value == val || o.textContent.trim() == li.textContent.trim());
      if(opt){ unitReal.value = opt.value; unitReal.dispatchEvent(new Event('change', {bubbles:true})); }
      selected.textContent = li.textContent.trim();
      close();
    });
    document.addEventListener('click', close);
  })();
})();
</script>

<!-- Injected from reference: Stroke Width & Align logic -->

<script>
(function(){
  function makePanelBodiesCollapsible(){
    const right = document.getElementById('right');
    if(!right) return;
    const panels = Array.from(right.querySelectorAll('.panel'));
    panels.forEach(p => {
      const ph = p.querySelector(':scope > .ph');
      if(!ph) return;
      // Wrap all siblings after .ph into .pb
      let sib = ph.nextSibling;
      const wrapper = document.createElement('div');
      wrapper.className = 'pb';
      const nodesToMove = [];
      while (sib) {
        const next = sib.nextSibling;
        if (sib.nodeType === Node.ELEMENT_NODE || (sib.nodeType === Node.TEXT_NODE && sib.textContent.trim().length)){
          nodesToMove.push(sib);
        }
        sib = next;
      }
      nodesToMove.forEach(n => wrapper.appendChild(n));
      p.appendChild(wrapper);

      // Add caret to header
      const titleEl = ph.querySelector('strong');
      const caret = document.createElement('button');
      caret.className = 'caret';
      caret.setAttribute('aria-label', 'Collapse/Expand');
      caret.textContent = '▾';
      // place caret at the right side next to title
      if (titleEl && titleEl.nextSibling) {
        titleEl.after(caret);
      } else {
        ph.appendChild(caret);
      }

      // Determine whether this panel should be collapsible
      const title = (titleEl ? titleEl.textContent.trim() : '').toLowerCase();
      const isLayers = title === 'layers';

      // Default: collapsed for all except Layers (which stays open and not collapsible)
      if (!isLayers) {
        p.classList.add('collapsible');
        p.classList.add('collapsed'); // start collapsed for compact UI
        caret.addEventListener('click', () => {
          p.classList.toggle('collapsed');
          caret.textContent = p.classList.contains('collapsed') ? '▸' : '▾';
        });
        // set initial caret state
        caret.textContent = '▸';
      } else {
        // Layers stays open and caret does nothing (or hidden)
        caret.style.visibility = 'hidden';
      }
    });
  }

  function moveHeaderControls(){
    const right = document.getElementById('right');
    if(!right) return;

    function moveIfExists(panelTitle, selectorInHeader){
      const panel = Array.from(right.querySelectorAll('.panel')).find(p => {
        const title = p.querySelector(':scope > .ph > strong');
        return title && title.textContent.trim().toLowerCase() === panelTitle;
      });
      if(!panel) return;
      const ph = panel.querySelector(':scope > .ph');
      const pb = panel.querySelector(':scope > .pb') || (function(){
        const w = document.createElement('div'); w.className='pb'; panel.appendChild(w); return w;
      })();
      const inHeader = ph.querySelector(selectorInHeader);
      if(inHeader){
        // move the element to top of body
        pb.insertBefore(inHeader, pb.firstChild);
      }
    }

    // Canvas: move the row with Show/Snap/Size (the small row inside header .ph)
    moveIfExists('canvas', '.row');

    // Fill: move the button row (Canvas / Shape / Text) from header to body
    moveIfExists('fill', '.row');

    // Effects: move the None button into the body
    moveIfExists('effects', '#effectsNone');
  }

  // Run after DOM is fully ready (script is appended at end of body anyway)
  try {
    makePanelBodiesCollapsible();
    moveHeaderControls();
  } catch(e){
    console.error('Panel injection error:', e);
  }

  // --- Panel input editing ---
  if (contentInput) {
    contentInput.addEventListener('input', function(){
  const c = getCanvas();
  const obj = getActiveTextObject(c);
  if (!obj || contentInput.readOnly) return;
  obj.text = contentInput.value;   // push panel input → canvas object
  requestRender(c);
});

    contentInput.addEventListener('keydown', function(e){
      const c = getCanvas();
      const obj = getActiveTextObject(c);
      if (!obj || contentInput.readOnly) return;
      if (e.key === 'Escape') {
        e.preventDefault();
        try { if (typeof obj.__origText !== 'undefined') { obj.text = obj.__origText; contentInput.value = obj.__origText; } } catch(err){}
        contentInput.readOnly = true;
        requestRender(c);
        clearSnapshot(obj);
        return;
      }
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        contentInput.readOnly = true; // apply & lock
        try { clearSnapshot(obj); } catch(err){}
        requestRender(c);
        return;
      }
    });
    contentInput.addEventListener('blur', function(){
      // If user clicks away, treat as apply (keep value, lock editing)
      const c = getCanvas();
      const obj = getActiveTextObject(c);
      if (!obj || contentInput.readOnly) return;
      contentInput.readOnly = true;
      try { clearSnapshot(obj); } catch(err){}
      requestRender(c);
    });
  }
})();
</script>

<script>
(function(){
  // Fabric helpers
  function getCanvas(){
    // Primary known globals
    var c = window.canvas || window.fabricCanvas || (window.editor && window.editor.canvas) || null;
    if (c && typeof c.getActiveObject === 'function') return c;
    // Fabric fallback: find .upper-canvas and read __canvas
    try {
      var upper = document.querySelector('.upper-canvas');
      if (upper && upper.__canvas && typeof upper.__canvas.getActiveObject === 'function') return upper.__canvas;
    } catch(e){}
    // Try id #c (common)
    try {
      var el = document.getElementById('c');
      if (el && el.__canvas && typeof el.__canvas.getActiveObject === 'function') return el.__canvas;
    } catch(e){}
    return null;
  }
  function getActiveTextObject(c){
    if(!c || !c.getActiveObject) return null;
    const obj = c.getActiveObject();
    if(!obj) return null;
    const t = (obj.type || '').toLowerCase();
    if(t === 'textbox' || t === 'text' || t === 'itext') return obj;
    return null;
  }
  function applyTextAlign(align){
    const c = getCanvas();
    const obj = getActiveTextObject(c);
    if(!obj) return;
    try{
      obj.set({ textAlign: align });
      // Some setups store alignment in styles; try to reflect that too for selected range
      if (obj.setSelectionStyles && obj.selectionStart != null && obj.selectionEnd != null) {
        obj.setSelectionStyles({ textAlign: align });
      }
      c && c.requestRenderAll && c.requestRenderAll();
    }catch(e){ console.warn('applyTextAlign error', e); }
  }

  function installBroadTextAlignHandlers(){
    // 1) Traditional select with id textAlign
    const sel = document.getElementById('textAlign');
    if (sel && !sel._alignWired) {
      sel.addEventListener('change', e => applyTextAlign(e.target.value));
      sel._alignWired = true;
    }
    // 2) Buttons with explicit data-align
    document.querySelectorAll('[data-align]').forEach(el => {
      if (el._alignWired) return;
      el.addEventListener('click', () => applyTextAlign((el.getAttribute('data-align')||'').toLowerCase()));
      el._alignWired = true;
    });
    // 3) Heuristics: buttons by title/aria-label/text
    const candidates = Array.from(document.querySelectorAll('button, .btn'))
      .filter(b => {
        const t = (b.getAttribute('title')||b.getAttribute('aria-label')||b.textContent||'').toLowerCase();
        return /(align|text[- ]?align)/.test(t) || /\bleft\b|\bcenter\b|\bright\b/.test(t);
      });
    candidates.forEach(b => {
      if (b._alignWired) return;
      const t = (b.getAttribute('title')||b.getAttribute('aria-label')||b.textContent||'').toLowerCase();
      let a = null;
      if (t.includes('center')) a = 'center';
      else if (t.includes('right')) a = 'right';
      else if (t.includes('left')) a = 'left';
      if (a){
        b.addEventListener('click', () => applyTextAlign(a));
        b._alignWired = true;
      }
    });
  }

  // Layout helpers
  function findPanelByTitle(name){
    const right = document.getElementById('right');
    if(!right) return null;
    name = name.toLowerCase();
    return Array.from(right.querySelectorAll('.panel')).find(p => {
      const strong = p.querySelector(':scope > .ph > strong');
      return strong && strong.textContent.trim().toLowerCase() === name;
    });
  }
  function ensureBody(panel){
    if(!panel) return null;
    return panel.querySelector(':scope > .pb') || panel;
  }
  function labelFor(panel, txt){
    if(!panel) return null;
    txt = txt.toLowerCase();
    const labs = Array.from(panel.querySelectorAll('label'));
    // prefer exact startsWith match
    let best = labs.find(l => l.textContent.trim().toLowerCase().startsWith(txt));
    if(!best) best = labs.find(l => l.textContent.trim().toLowerCase().includes(txt));
    return best;
  }
  function fieldForLabel(label){
    if(!label) return null;
    const id = label.getAttribute('for');
    if (id){
      const el = document.getElementById(id);
      if (el) return el;
    }
    // fallback: nextElementSibling
    let el = label.nextElementSibling;
    while (el && el.tagName === 'LABEL') el = el.nextElementSibling;
    return el;
  }
  function makeRow(items){
    const row = document.createElement('div');
    row.className = 'row tight';
    items.forEach(el => {
      if(!el) return;
      const wrap = document.createElement('div');
      wrap.className = 'field';
      // If it's a label, keep it and append its control next to it
      if (el.tagName === 'LABEL'){
        const ctrl = fieldForLabel(el);
        if (ctrl){
          wrap.appendChild(el);
          wrap.appendChild(ctrl);
          row.appendChild(wrap);
        } else {
          row.appendChild(el);
        }
      } else {
        row.appendChild(el);
      }
    });
    return row;
  }

  function reflowCanvas(){
    // Disable automatic Canvas reflow: use DOM order defined in HTML.
    return;
  }

  function reflowTransform(){
    const p = findPanelByTitle('transform');
    if(!p) return;
    const pb = ensureBody(p);
    // nothing to move specifically; CSS aligns vertically
    pb.classList.add('transform-tight');
  }

  function reflowFill(){
    const p = findPanelByTitle('fill');
    if(!p) return;
    const pb = ensureBody(p);
    // Buttons Canvas/Shape/Text likely already present; find them
    const btns = Array.from(pb.querySelectorAll('button, .btn')).filter(b=>{
      const t = (b.textContent||'').trim().toLowerCase();
      return t === 'canvas' || t === 'shape' || t === 'text';
    });
    const mode = pb.querySelector('select');
    if (btns.length && mode){
      const row = makeRow(btns.concat([mode]));
      pb.insertBefore(row, pb.firstChild);
    }
  }

  function reflowEffects(){
    const p = findPanelByTitle('effects');
    if(!p) return;
    const pb = ensureBody(p);
    const noneBtn = Array.from(pb.querySelectorAll('button, .btn')).find(b=> (b.textContent||'').trim().toLowerCase() === 'none');
    // First select that looks like Blend mode
    const blendSel = Array.from(pb.querySelectorAll('select')).find(s => {
      const id = (s.id||'').toLowerCase();
      const name = (s.name||'').toLowerCase();
      return id.includes('blend') || name.includes('blend') || s.closest('.field') && s.closest('.field').textContent.toLowerCase().includes('blend');
    }) || pb.querySelector('select');
    if (noneBtn && blendSel){
      const row = makeRow([noneBtn, blendSel]);
      pb.insertBefore(row, pb.firstChild);
    }
  }

  function tighten(){
    installBroadTextAlignHandlers();
    reflowCanvas();
    reflowTransform();
    reflowFill();
    reflowEffects();
  }

  try { tighten(); } catch(e){ console.error('v3 inject error', e); }
})();
</script>

<script>
(function(){
  // ---------- Fabric helpers ----------
  function getCanvas(){
    // Primary known globals
    var c = window.canvas || window.fabricCanvas || (window.editor && window.editor.canvas) || null;
    if (c && typeof c.getActiveObject === 'function') return c;
    // Fabric fallback: find .upper-canvas and read __canvas
    try {
      var upper = document.querySelector('.upper-canvas');
      if (upper && upper.__canvas && typeof upper.__canvas.getActiveObject === 'function') return upper.__canvas;
    } catch(e){}
    // Try id #c (common)
    try {
      var el = document.getElementById('c');
      if (el && el.__canvas && typeof el.__canvas.getActiveObject === 'function') return el.__canvas;
    } catch(e){}
    return null;
  }
  function isText(o){
    if(!o) return false;
    const t = (o.type||'').toLowerCase();
    return t === 'textbox' || t === 'text' || t === 'itext';
  }
  function getActiveTextObject(c){
    if(!c || !c.getActiveObject) return null;
    const o = c.getActiveObject();
    return isText(o) ? o : null;
  }
  function requestRender(c){ try{ c && c.requestRenderAll && c.requestRenderAll(); }catch(e){} }

  // ---------- Text alignment: robust wiring ----------
  function applyTextAlign(align){
    align = (align||'').toLowerCase();
    if(!/^(left|center|right|justify)$/.test(align)) return;
    const c = getCanvas();
    if(!c) return;
    const obj = getActiveTextObject(c);
    if(!obj) return;
    try{
      obj.set('textAlign', align);
      if (obj.hiddenTextarea) { // keep caret / style consistent
        obj.hiddenTextarea.style.textAlign = align;
      }
      requestRender(c);
    }catch(e){ console.warn('applyTextAlign failed', e); }
  }

  function wireAlignment(){
    // 1) Explicit select with id=textAlign
    const sel = document.getElementById('textAlign');
    if (sel && !sel._wiredAlign) {
      sel.addEventListener('change', e => {
        const v = (e.target.value || (e.target.selectedOptions[0] && e.target.selectedOptions[0].text) || '').toLowerCase();
        applyTextAlign(v);
      });
      sel._wiredAlign = true;
    }
    // 2) Buttons with data-align attr
    document.querySelectorAll('[data-align]').forEach(btn => {
      if (btn._wiredAlign) return;
      btn.addEventListener('click', () => applyTextAlign(btn.getAttribute('data-align')));
      btn._wiredAlign = true;
    });
    // 3) Heuristic: any button/select clearly for alignment
    document.addEventListener('click', function(e){
      const t = e.target;
      if (!t) return;
      let txt = (t.getAttribute('title')||t.getAttribute('aria-label')||t.textContent||'').toLowerCase();
      if (/(^|\s)(left|center|right|justify)(\s|$)/.test(txt) && (t.tagName === 'BUTTON' || t.classList.contains('btn'))) {
        const m = txt.match(/left|center|right|justify/);
        if (m) applyTextAlign(m[0]);
      }
    }, true);
    document.addEventListener('change', function(e){
      const t = e.target;
      if (t && t.tagName === 'SELECT') {
        const opts = Array.from(t.options).map(o => o.text.toLowerCase());
        if (opts.includes('left') && opts.includes('center') && opts.includes('right')){
          const v = (t.value || (t.selectedOptions[0] && t.selectedOptions[0].text) || '').toLowerCase();
          applyTextAlign(v);
        }
      }
    }, true);
  }

  // ---------- Make saved text editable (double-click, ensure editable flags) ----------
  function enableEditableText(){
    const c = getCanvas();
    if(!c) return;
    // Ensure newly added text objects are editable/selectable
    c.on('object:added', function(e){
      const o = e.target;
      if (isText(o)){
        o.set({ editable: true, selectable: true, evented: true, hasControls: true, lockMovementX: false, lockMovementY: false });
      }
    });
    // Double-click to edit
    c.on('mouse:dblclick', function(opt){
      const target = opt && opt.target;
      if (isText(target)){
        try{
          target.enterEditing && target.enterEditing();
          if (target.hiddenTextarea) target.hiddenTextarea.focus();
          requestRender(c);
        }catch(e){ console.warn('enterEditing failed', e); }
      }
    });
    // Fallback: if user single-selects a text object, make sure it's editable
    c.on('selection:created', function(e){
      const t = e && e.selected && e.selected[0];
      if (isText(t)){
        t.set({ editable: true, selectable: true });
      }
    });
  }

  // ---------- Layout reflows: exact rows as requested ----------
  function findPanelByTitle(name){
    const right = document.getElementById('right');
    if(!right) return null;
    name = name.toLowerCase();
    return Array.from(right.querySelectorAll('.panel')).find(p => {
      const s = p.querySelector(':scope > .ph > strong');
      return s && s.textContent.trim().toLowerCase() === name;
    });
  }
  function ensureBody(panel){
    return panel.querySelector(':scope > .pb') || panel;
  }
  function byLabel(pb, name){
    name = name.toLowerCase();
    const lab = Array.from(pb.querySelectorAll('label')).find(l => {
      const t = (l.textContent||'').trim().toLowerCase();
      return t.startsWith(name) || t === name;
    });
    if(!lab) return null;
    const id = lab.getAttribute('for');
    const ctrl = id ? document.getElementById(id) : (function(next){
      while (next && next.tagName === 'LABEL') next = next.nextElementSibling;
      return next;
    })(lab.nextElementSibling);
    return { label: lab, ctrl };
  }
  function makeRow(items){
    const row = document.createElement('div');
    row.className = 'row tight';
    items.forEach(x => {
      if (!x) return;
      // If passed {label, ctrl}
      if (x.label && x.ctrl){
        const f = document.createElement('div'); f.className = 'field';
        f.appendChild(x.label); f.appendChild(x.ctrl);
        row.appendChild(f);
      } else {
        row.appendChild(x);
      }
    });
    return row;
  }

  function reflowCanvas(){
    // Disabled: use DOM order for Canvas panel rows.
    return;
  }

  function reflowTransform(){
    const panel = findPanelByTitle('transform'); if(!panel) return;
    const pb = ensureBody(panel);
    // CSS already vertically centers; nothing else needed
  }

  function reflowFill(){
    const panel = findPanelByTitle('fill'); if(!panel) return;
    const pb = ensureBody(panel);
    const btns = Array.from(pb.querySelectorAll('button, .btn')).filter(b => {
      const t = (b.textContent||'').trim().toLowerCase();
      return t === 'canvas' || t === 'shape' || t === 'text';
    });
    // Mode select by label or first select with options
    let modeSel = null;
    const modeL = byLabel(pb, 'mode');
    if (modeL && modeL.ctrl && modeL.ctrl.tagName === 'SELECT') modeSel = modeL.ctrl;
    if (!modeSel) {
      modeSel = Array.from(pb.querySelectorAll('select')).find(s => {
        const opts = Array.from(s.options).map(o=>o.text.toLowerCase());
        return opts.includes('linear gradient') || opts.includes('solid') || opts.length>0;
      });
    }
    if (btns.length && modeSel){
      const row = makeRow(btns.concat([modeSel]));
      pb.insertBefore(row, pb.firstChild);
    }
  }

  function reflowEffects(){
    const panel = findPanelByTitle('effects'); if(!panel) return;
    const pb = ensureBody(panel);
    const noneBtn = Array.from(pb.querySelectorAll('button, .btn')).find(b => (b.textContent||'').trim().toLowerCase() === 'none');
    // Blend select by label or heuristic
    let blendSel = null;
    const blendL = byLabel(pb, 'blend');
    if (blendL && blendL.ctrl && blendL.ctrl.tagName === 'SELECT') blendSel = blendL.ctrl;
    if (!blendSel) {
      blendSel = Array.from(pb.querySelectorAll('select')).find(s => {
        const id = (s.id||'').toLowerCase(); const name = (s.name||'').toLowerCase();
        return id.includes('blend') || name.includes('blend');
      }) || pb.querySelector('select');
    }
    if (noneBtn && blendSel){
      const row = makeRow([noneBtn, blendSel]);
      pb.insertBefore(row, pb.firstChild);
    }
  }

  function run(){
    wireAlignment();
    enableEditableText();
    reflowCanvas();
    reflowTransform();
    reflowFill();
    reflowEffects();
  }

  try { run(); } catch(e){ console.error('v4 inject error', e); }
})();
</script>

<script id="js-right-collapse-delegated">
(function(){
  // Delegated collapse/accordion for #right .panel > .ph
  function isHeader(el){ return !!(el && el.classList && el.classList.contains('ph')); }
  function findHeader(target){
    try { return target && target.closest ? target.closest('#right .panel > .ph') : null; }
    catch(e){ return null; }
  }
  function isInteractive(t){
    return !!(t && t.closest && t.closest('button,select,input,textarea,a,[role="switch"],[role="combobox"],[contenteditable="true"]'));
  }
  function sync(panel){
    var pb = panel.querySelector(':scope > .pb');
    var ph = panel.querySelector(':scope > .ph');
    if(pb){
      if(panel.classList.contains('collapsed')) pb.style.display = 'none';
      else pb.style.display = '';
    }
    if(ph){
      ph.setAttribute('aria-expanded', String(!panel.classList.contains('collapsed')));
      ph.tabIndex = 0;
      ph.setAttribute('role','button');
    }
  }
  function toggle(panel, allPanels){
    // previously: accordion closed all sibling panels when one was opened.  Users requested the ability
    // to keep multiple panels open simultaneously, so simply toggle the clicked panel without
    // affecting others.
    panel.classList.toggle('collapsed');
    sync(panel);
  }
  function init(){
    var right = document.getElementById('right');
    if(!right) return;
    var allPanels = Array.from(right.querySelectorAll(':scope .panel'));
    if(allPanels.length===0) return;

    // If everything collapsed, open first
    if(allPanels.every(p => p.classList.contains('collapsed'))){
      allPanels[0].classList.remove('collapsed');
    }
    allPanels.forEach(sync);

    function handleClick(e){
      var hdr = findHeader(e.target);
      if(!hdr) return;
      if(isInteractive(e.target)) return; // don't toggle when clicking controls inside header
      var panel = hdr.parentElement; // header is direct child of .panel
      if(!panel || !panel.classList || !panel.classList.contains('panel')) return;
      e.preventDefault();
      toggle(panel, allPanels);
    }
    function handleKey(e){
      if(!isHeader(e.target)) return;
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        var panel = e.target.parentElement;
        if(panel) toggle(panel, allPanels);
      }
    }

    // High-reliability delegation (capture + bubble + pointerdown)
    right.addEventListener('click', handleClick, true);
    right.addEventListener('click', handleClick, false);
    right.addEventListener('pointerdown', handleClick, true);
    right.addEventListener('keydown', handleKey, false);
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else {
    setTimeout(init, 0);
  }
})();
</script>

<script id="stroke-align-clean-js">
(function(){
  if (window.__strokeAlignClean) return;
  window.__strokeAlignClean = true;

  const app = window.app || (window.app = {});
  app.strokeAlign = app.strokeAlign || 'center';

  function requestRender(){
    if (typeof window.requestRender === 'function') return window.requestRender();
    if (typeof window.renderStage === 'function') return window.renderStage();
    if (typeof window.drawAll === 'function') return window.drawAll();
    // Fallback: simple stage clear to cause minimal refresh if custom loop exists
    const c = document.getElementById('canvas');
    if (c && c.getContext){
      const ctx = c.getContext('2d');
      try { ctx.canvas.dispatchEvent(new Event('needsRender')); } catch(e){}
    }
  }

  function setStrokeAlignUI(val){
    const btns = document.querySelectorAll('#strokeAlignGroup .btn');
    btns.forEach(b => {
      const on = (b.dataset.align === val);
      b.classList.toggle('active', on);
      if (on){
        b.style.background = 'var(--accent)';
        b.style.borderColor = 'var(--accent-2)';
        b.style.color = '#fff';
      } else {
        b.style.background = '#1f2937';
        b.style.borderColor = 'var(--muted)';
        b.style.color = 'var(--text)';
      }
    });
  }

  function setStrokeAlign(val){
    val = (val || 'center').toLowerCase();
    if (val === 'inner') val = 'inside';
    if (!['inside','center','outside'].includes(val)) val = 'center';
    app.strokeAlign = val;
    setStrokeAlignUI(val);
    // Reflect into active layer if app exposes it (non-blocking)
    try {
      if (typeof getPrimary === 'function'){
        const L = getPrimary();
        if (L) L.strokeAlign = val;
      }
    } catch(e){}
    requestRender();
  }

  function insertUI(){
    const strokePanel = document.querySelector('#right .panel[data-sec="Stroke"] .pb') || document.querySelector('#right .panel[data-sec="Stroke"]');
    if (!strokePanel || document.getElementById('strokeAlignRow')) return;

    const row = document.createElement('div');
    row.id = 'strokeAlignRow';
    row.className = 'row';

    const lab = document.createElement('label');
    lab.className = 'small';
    lab.textContent = 'Align';

    const grp = document.createElement('div');
    grp.id = 'strokeAlignGroup';

    [['Inside','inside'],['Center','center'],['Outside','outside']].forEach(([txt,val]) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'btn';
      b.textContent = txt;
      b.dataset.align = val;
      b.addEventListener('click', e => { e.preventDefault(); setStrokeAlign(val); });
      grp.appendChild(b);
    });

    row.appendChild(lab);
    row.appendChild(grp);

    // Insert after the row that contains #strokeW (robustly without :has)
    const w = strokePanel.querySelector('#strokeW');
    const wRow = w ? (w.closest('.row') || strokePanel.firstElementChild) : null;
    if (wRow && wRow.nextSibling){
      wRow.parentNode.insertBefore(row, wRow.nextSibling);
    } else {
      strokePanel.appendChild(row);
    }

    setStrokeAlign(app.strokeAlign);
  }

  // Patch CanvasRenderingContext2D.stroke with offscreen mask, with recursion bypass
  function patchCtx(){
    const P = CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
    if (!P || P.__strokeAlignCleanPatched) return;
    P.__strokeAlignCleanPatched = true;

    // Mirror path into a recorder so we canvas stroke() without args
    const orig = {
      beginPath: P.beginPath, moveTo: P.moveTo, lineTo: P.lineTo, rect: P.rect,
      roundRect: P.roundRect, arc: P.arc, arcTo: P.arcTo, ellipse: P.ellipse,
      bezierCurveTo: P.bezierCurveTo, quadraticCurveTo: P.quadraticCurveTo, closePath: P.closePath,
      stroke: P.stroke, fill: P.fill, save: P.save, restore: P.restore,
      getTransform: P.getTransform, setTransform: P.setTransform, drawImage: P.drawImage,
      setLineDash: P.setLineDash, getLineDash: P.getLineDash
    };

    function rec(ctx){ if(!ctx.__sa_path) ctx.__sa_path = new Path2D(); return ctx.__sa_path; }
    function reset(ctx){ ctx.__sa_path = new Path2D(); }

    P.beginPath = function(){ reset(this); return orig.beginPath.apply(this, arguments); };
    P.moveTo = function(){ rec(this).moveTo(arguments[0],arguments[1]); return orig.moveTo.apply(this, arguments); };
    P.lineTo = function(){ rec(this).lineTo(arguments[0],arguments[1]); return orig.lineTo.apply(this, arguments); };
    P.rect = function(){ rec(this).rect(arguments[0],arguments[1],arguments[2],arguments[3]); return orig.rect.apply(this, arguments); };
    P.roundRect = function(){ try{ rec(this).roundRect.apply(rec(this), arguments);}catch(e){}; return orig.roundRect?orig.roundRect.apply(this, arguments):orig.rect.apply(this, arguments); };
    P.arc = function(){ rec(this).arc.apply(rec(this), arguments); return orig.arc.apply(this, arguments); };
    P.arcTo = function(){ rec(this).arcTo.apply(rec(this), arguments); return orig.arcTo.apply(this, arguments); };
    P.ellipse = function(){ rec(this).ellipse.apply(rec(this), arguments); return orig.ellipse.apply(this, arguments); };
    P.bezierCurveTo = function(){ rec(this).bezierCurveTo.apply(rec(this), arguments); return orig.bezierCurveTo.apply(this, arguments); };
    P.quadraticCurveTo = function(){ rec(this).quadraticCurveTo.apply(rec(this), arguments); return orig.quadraticCurveTo.apply(this, arguments); };
    P.closePath = function(){ rec(this).closePath(); return orig.closePath.apply(this, arguments); };

    P.stroke = function(pathMaybe){
      if (this.__sa_bypass) return orig.stroke.call(this, pathMaybe);
      const hasP2D = (typeof Path2D !== 'undefined');
      const isPath = hasP2D && (pathMaybe instanceof Path2D);
      const path = isPath ? pathMaybe : (this.__sa_path || null);
      const align = (app.strokeAlign || 'center').replace('inner','inside');

      if (!path || align === 'center'){
        return isPath ? orig.stroke.call(this, pathMaybe) : orig.stroke.apply(this, arguments);
      }

      // Offscreen
      const tmp = document.createElement('canvas');
      tmp.width = this.canvas.width; tmp.height = this.canvas.height;
      const t = tmp.getContext('2d');
      t.__sa_bypass = True = true; // mark bypass

      // Copy transform & stroke state
      try { const tr = this.getTransform && this.getTransform(); if (tr && t.setTransform) t.setTransform(tr); } catch(e){}
      try { t.lineWidth = this.lineWidth; }catch(e){}
      try { t.lineCap = this.lineCap; }catch(e){}
      try { t.lineJoin = this.lineJoin; }catch(e){}
      try { t.miterLimit = this.miterLimit; }catch(e){}
      try { t.strokeStyle = this.strokeStyle; }catch(e){}
      try { t.setLineDash(this.getLineDash ? this.getLineDash() : []); }catch(e){}
      try { t.lineDashOffset = this.lineDashOffset || 0; }catch(e){}
      try { t.globalAlpha = this.globalAlpha; }catch(e){}
      try { t.shadowBlur = this.shadowBlur; }catch(e){}
      try { t.shadowColor = this.shadowColor; }catch(e){}
      try { t.shadowOffsetX = this.shadowOffsetX; }catch(e){}
      try { t.shadowOffsetY = this.shadowOffsetY; }catch(e){}

      // Stroke onto temp with ORIGINAL
      try { orig.stroke.call(t, path); } catch(e){
        // Fallback to normal
        return isPath ? orig.stroke.call(this, pathMaybe) : orig.stroke.apply(this, arguments);
      }

      // Mask inside/outside
      t.save();
      if (align === 'inside'){
        t.globalCompositeOperation = 'destination-in';
        try { orig.fill.call(t, path, 'evenodd'); } catch(e){ try { orig.fill.call(t, path); } catch(_e){} }
      } else if (align === 'outside'){
        t.globalCompositeOperation = 'destination-out';
        try { orig.fill.call(t, path, 'evenodd'); } catch(e){ try { orig.fill.call(t, path); } catch(_e){} }
      }
      t.restore();

      // Composite back
      orig.save.call(this);
      try { if (orig.setTransform) this.setTransform(1,0,0,1,0,0); orig.drawImage.call(this, tmp, 0, 0); }
      finally { orig.restore.call(this); }
    };
  }

  function bindWidthSlider(){
    const w = document.getElementById('strokeW');
    if (!w) return;
    ['input','change'].forEach(ev => w.addEventListener(ev, requestRender));
  }

  function init(){
    insertUI();
    patchCtx();
    bindWidthSlider();
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init, {once:true});
  else init();
})();
</script>

<script id="stroke-align-rect-support">
(function(){
  // Extend the clean patch: align-aware strokeRect
  const P = CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
  if (!P || P.__sa_rectPatched) return;
  P.__sa_rectPatched = true;

  const orig = {
    strokeRect: P.strokeRect,
    stroke: P.stroke,
    save: P.save,
    restore: P.restore,
    getTransform: P.getTransform,
    setTransform: P.setTransform,
    drawImage: P.drawImage,
    fill: P.fill,
    setLineDash: P.setLineDash,
    getLineDash: P.getLineDash
  };

  // Reuse global app
  const app = window.app || (window.app = {});

  function strokePathAligned(ctx, path){
    // Route through the *patched* stroke so alignment masking applies
    return ctx.stroke(path);
  }

  P.strokeRect = function(x,y,w,h){
    const align = (app.strokeAlign || 'center').toLowerCase().replace('inner','inside');
    if (align === 'center' || this.__sa_bypass){
      return orig.strokeRect.call(this, x,y,w,h);
    }
    // Build a Path2D rect and reuse aligned stroke path
    const p = new Path2D();
    try { p.rect(x,y,w,h); } catch(e){ return orig.strokeRect.call(this, x,y,w,h); }
    return strokePathAligned.call(this, this, p);
  };
})();
</script>

<script id="js-stretch-enforcer">
(function(){
  const UIH = 35;                 // uniform control height
  const GAP = 3;                  // label ↔ button gap
  const COLOR = 25;               // color chip size

  const isButton = el => el && (el.tagName === 'BUTTON' || el.classList.contains('btn'));
  const isInput = el => el && el.tagName === 'INPUT';
  const isSelect = el => el && el.tagName === 'SELECT';
  const isLabel = el => el && el.tagName === 'LABEL' && el.classList.contains('small');

  function styleColor(el){
    el.style.width = el.style.height = COLOR + 'px';
    el.style.inlineSize = el.style.blockSize = COLOR + 'px';
    el.style.borderRadius = '9999px';
    el.style.padding = '0';
    el.style.margin = '0';
    el.style.border = 'none';
    el.style.display = 'inline-block';
    el.style.boxSizing = 'border-box';
    el.style.overflow = 'hidden';
    el.style.verticalAlign = 'middle';
  }

  function styleStretchChild(el){
    if (isButton(el) || isSelect(el) || (isInput(el) && !['checkbox','color'].includes(el.type))) {
      el.style.flex = '1 1 0';
      el.style.minWidth = '0';
      el.style.maxWidth = '100%';
      el.style.width = 'auto';
      el.style.height = UIH + 'px';
      el.style.lineHeight = UIH + 'px';
    }
    if (isInput(el) && el.type === 'range') {
      el.style.flex = '2 1 0';
    }
    if (isLabel(el) || (isInput(el) && (el.type === 'checkbox' || el.type === 'color'))) {
      el.style.flex = '0 0 auto';
    }
    if (isInput(el) && el.type === 'color') styleColor(el);
  }

  function enforceRow(row){
    if (!row) return;
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'flex-start';
    row.style.gap = GAP + 'px';
    row.style.flexWrap = 'nowrap';
    row.style.width = '100%';
    // reset child margins that create ghost gaps
    for (const el of row.children) {
      el.style.margin = '0';
      styleStretchChild(el);
    }
  }

  function fixSectionPanels(){
    const right = document.getElementById('right');
    if (!right) return;
    const rows = right.querySelectorAll('.panel .pb > .row, .panel .pb > div.row, #textStyleRow, #textRowLineBIU, #strokeAlignRow');
    rows.forEach(enforceRow);
  }

  function fixCanvasGap(){
    const applyRow = document.querySelector('#canvasPanel #canvasApplyRow');
    if (applyRow){
      applyRow.style.margin:0 !important;
      applyRow.style.marginBottom = '2px';
      applyRow.style.padding = '0';
      const btn = applyRow.querySelector('#applyCanvas, button');
      if (btn){
        btn.style.width = '100%';
        btn.style.flex = '1 1 100%';
        btn.style.minWidth = '0';
        btn.style.height = UIH + 'px';
        btn.style.lineHeight = UIH + 'px';
      }
    }
    const showSnap = document.querySelector('#canvasPanel #rowShowSnap') 
                  || document.querySelector('#canvasPanel #canvasRow4');
    if (showSnap){
      showSnap.style.marginTop = '2px';
      showSnap.style.paddingTop = '0';
    }
  }

  function lockColors(){
    const right = document.getElementById('right');
    if (!right) return;
    right.querySelectorAll('input[type="color"]').forEach(styleColor);
  }

  // Run once on DOM ready
  function run(){
    fixSectionPanels();
    fixCanvasGap();
    lockColors();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }

  // Observe mutations to catch dynamic rows inserted later
  const obs = new MutationObserver(muts => {
    for (const m of muts){
      m.addedNodes && m.addedNodes.forEach(node => {
        if (!(node instanceof HTMLElement)) return;
        if (node.matches && (node.matches('.row') || node.id === 'textStyleRow' || node.id === 'textRowLineBIU' || node.id === 'strokeAlignRow')) {
          enforceRow(node);
        }
        // Also catch nested rows inside a fragment
        node.querySelectorAll && node.querySelectorAll('.row, #textStyleRow, #textRowLineBIU, #strokeAlignRow').forEach(enforceRow);
        // Fix any newly added color pickers
        node.querySelectorAll && node.querySelectorAll('input[type="color"]').forEach(styleColor);
      });
    }
  });
  try {
    obs.observe(document.documentElement, { childList: true, subtree: true });
  } catch(e){ /* no-op */ }
})();
</script>

<script id="js-biu-icons-apply-theme">
(function(){
  function once(fn){ try{ fn(); }catch(e){} }
  once(function(){
    // Apply class to Apply button
    var apply = document.getElementById('applyCanvas');
    if (apply) apply.classList.add('btn','apply');

    // Alignment buttons (inside/center/outside) – add class 'align' if not present
    var alignBtns = document.querySelectorAll('#textRowLineBIU .btn.align, #textRowLineBIU .align, .btn[data-align]');
    if (!alignBtns.length) {
      // Fallback: look for likely labels in Text panel
      var candidates = Array.from(document.querySelectorAll('#right .panel[data-sec="Text"] .pb .btn')).filter(b=>/inside|center|outside/i.test(b.textContent||''));
      candidates.forEach(function(b){ b.classList.add('align'); });
    }

    // BIU buttons
    var row = document.getElementById('textStyleRow') || document.querySelector('#right .panel[data-sec="Text"] #textStyleRow');
    if (row){
      var btns = Array.from(row.querySelectorAll('button, .btn'));
      // Heuristics: pick 3 first small buttons or those near "Bold/Italic/Underline" inputs
      if (btns.length >= 3){
        // Normalize to exactly three controls
        var biu = btns.slice(0,3);
        var labels = ['B','I','U'];
        var styles = ['bold','italic','underline'];
        biu.forEach(function(b, i){
          b.classList.add('btn','text-style');
          b.setAttribute('data-style', styles[i]);
          b.setAttribute('aria-label', styles[i].charAt(0).toUpperCase()+styles[i].slice(1));
          b.textContent = labels[i];
        });
      }
    }
  });
})();
</script>

<!-- Re-injected: panel collapse behavior only -->
<script>
window.addEventListener('DOMContentLoaded', () => {

  

  
  
  
  
  /* === SAFETY: Ensure right panel headers toggle open/close === */
  (function () {
    const headers = document.querySelectorAll('#right .panel .ph');
    headers.forEach(ph => {
      // Avoid double-binding
      if (ph.__boundToggle) return;
      ph.__boundToggle = true;
      ph.style.cursor = 'pointer';
      ph.addEventListener('click', (e) => {
        const panel = ph.closest('.panel');
        if (!panel) return;
        // Don't toggle if click was on a control inside a header (none expected)
        if (e.target && e.target.closest('button, select, input')) return;
        panel.classList.toggle('collapsed');
      });
    });
  })();
/* === Custom Export Dropdown (portal-based popup) === */
  (function () {
    const sel = document.getElementById('fmt');
    const wrap = document.getElementById('fmtCustom');
    if (!sel || !wrap) return;
    const selected = wrap.querySelector('.selected');

    // Build portal list from native select options
    const portal = document.createElement('ul');
    portal.className = 'custom-select-portal';
    document.body.appendChild(portal);

    function buildOptions() {
      portal.innerHTML = '';
      Array.from(sel.options).forEach(opt => {
        const li = document.createElement('li');
        li.textContent = opt.textContent || opt.value;
        li.dataset.value = opt.value;
        li.addEventListener('click', () => {
          sel.value = li.dataset.value;
          selected.textContent = li.textContent;
          try { sel.dispatchEvent(new Event('change', { bubbles:true })); } catch(e) {}
          closeMenu();
        });
        portal.appendChild(li);
      });
    }
    buildOptions();

    function openMenu() {
      const r = selected.getBoundingClientRect();
      portal.style.width = Math.max(r.width, 120) + 'px';
      portal.style.left = Math.round(r.left) + 'px';
      portal.style.top = Math.round(r.bottom + 6) + 'px';
      portal.classList.add('open');
      window.addEventListener('scroll', onScrollClose, { passive: true, once: true });
      window.addEventListener('resize', onResizeClose, { passive: true, once: true });
      document.addEventListener('click', onDocClick, { once: true });
      document.addEventListener('keydown', onKey, { once: true });
    }
    function closeMenu() {
      portal.classList.remove('open');
    }
    function onDocClick(e){ if (!portal.contains(e.target) && !wrap.contains(e.target)) closeMenu(); }
    function onKey(e){ if (e.key === 'Escape') closeMenu(); }
    function onScrollClose(){ closeMenu(); }
    function onResizeClose(){ closeMenu(); }

    // Initial selected label
    const cur = sel.options[sel.selectedIndex] || sel.options[0];
    if (cur) selected.textContent = cur.textContent || cur.value;

    // Toggle on click
    selected.addEventListener('click', (e) => {
      e.stopPropagation();
      if (portal.classList.contains('open')) closeMenu();
      else openMenu();
    });

    // Sync if native select changes programmatically
    sel.addEventListener('change', () => {
      const opt = sel.options[sel.selectedIndex];
      if (opt) selected.textContent = opt.textContent || opt.value;
    });
  })();
/* === TEXT STYLE BUTTONS: Bold / Italic / Underline as toggles === */
  (function () {
    const btnBold = document.getElementById('boldBtn');
    const btnItalic = document.getElementById('italicBtn');
    const btnUnderline = document.getElementById('underlineBtn');
    const chkBold = document.getElementById('bold');
    const chkItalic = document.getElementById('italic');
    const chkUnderline = document.getElementById('underline');

    function syncButtonsFromChecks() {
      if (btnBold && chkBold) btnBold.classList.toggle('active', !!chkBold.checked);
      if (btnItalic && chkItalic) btnItalic.classList.toggle('active', !!chkItalic.checked);
      if (btnUnderline && chkUnderline) btnUnderline.classList.toggle('active', !!chkUnderline.checked);
    }

    // Expose to global scope so other modules (e.g. syncTextPanel) canvas invoke
    window.syncButtonsFromChecks = syncButtonsFromChecks;

    function applyStylesToSelection() {
      try {
        const sel = Array.isArray(state.selection) ? state.selection : [];
        if (!sel.length) return;
        let changed = false;
        state.layers.forEach(L => {
          if (!sel.includes(L.id) || L.type !== 'text' || L.locked) return;
          // Apply boolean style flags used by renderer
          const b = !!(chkBold && chkBold.checked);
          const i = !!(chkItalic && chkItalic.checked);
          const u = !!(chkUnderline && chkUnderline.checked);
          if (L.bold !== b) { L.bold = b; changed = true; }
          if (L.italic !== i) { L.italic = i; changed = true; }
          if (L.underline !== u) { L.underline = u; changed = true; }
          // Mirror booleans into CSS properties for backward compatibility
          L.fontWeight = b ? '700' : '400';
          L.fontStyle  = i ? 'italic' : 'normal';
          L.textDecoration = u ? 'underline' : 'none';
        });
        if (changed) {
          if (typeof pushHist === 'function') pushHist();
          if (typeof drawAll === 'function') drawAll();
        }
      } catch (e) {}
    }

    function bind(btn, chk) {
      if (!btn || !chk) return;
      // Initial sync
      btn.classList.toggle('active', !!chk.checked);
      // Button click toggles checkbox and applies styles
      btn.addEventListener('click', () => {
        chk.checked = !chk.checked;
        try { chk.dispatchEvent(new Event('input', { bubbles: true })); } catch(e) {}
        try { chk.dispatchEvent(new Event('change', { bubbles: true })); } catch(e) {}
        btn.classList.toggle('active', !!chk.checked);
        applyStylesToSelection();
      });
      // If something else flips the checkbox, keep button in sync
      ['change','input'].forEach(ev => chk.addEventListener(ev, () => {
        btn.classList.toggle('active', !!chk.checked);
      }));
    }

    bind(btnBold, chkBold);
    bind(btnItalic, chkItalic);
    bind(btnUnderline, chkUnderline);

    // Also try to sync from current selected text layer when selection changes (if app code emits events)
    // Fallback: run once on load
    syncButtonsFromChecks();
  })();
/* === CLEAN WIRING: Existing Show/Snap buttons toggle hidden checkboxes === */
  (function () {
    const chkShow = document.getElementById('gridShow');
    const chkSnap = document.getElementById('gridSnap');
    const btnShow = document.getElementById('gridShowBtn');
    const btnSnap = document.getElementById('gridSnapBtn');
    function syncLabel() {
      if (btnShow && chkShow) btnShow.textContent = chkShow.checked ? "Show: On" : "Show: Off";
      if (btnSnap && chkSnap) btnSnap.textContent = chkSnap.checked ? "Snap: On" : "Snap: Off";
    }
    // Initial label + state sync (in case state/grid was set elsewhere)
    try {
      if (typeof state !== 'undefined' && state.grid) {
        if (typeof chkShow !== 'undefined' && chkShow) chkShow.checked = !!state.grid.show;
        if (typeof chkSnap !== 'undefined' && chkSnap) chkSnap.checked = !!state.grid.snap;
      }
    } catch (e) {}
    syncLabel();

    if (btnShow && chkShow) {
      btnShow.addEventListener('click', () => {
        chkShow.checked = !chkShow.checked;
        try { chkShow.dispatchEvent(new Event('input', { bubbles: true })); } catch(e) {}
        try { chkShow.dispatchEvent(new Event('change', { bubbles: true })); } catch(e) {}
        try { state.grid.show = !!chkShow.checked; if (typeof drawAll === 'function') drawAll(); } catch(e) {}
        syncLabel();
      });
      ['change','input'].forEach(ev => chkShow.addEventListener(ev, syncLabel));
    }
    if (btnSnap && chkSnap) {
      btnSnap.addEventListener('click', () => {
        chkSnap.checked = !chkSnap.checked;
        try { chkSnap.dispatchEvent(new Event('input', { bubbles: true })); } catch(e) {}
        try { chkSnap.dispatchEvent(new Event('change', { bubbles: true })); } catch(e) {}
        try { state.grid.snap = !!chkSnap.checked; } catch(e) {}
        syncLabel();
      });
      ['change','input'].forEach(ev => chkSnap.addEventListener(ev, syncLabel));
    }
  })();
/* ==== utils ==== */
const d=id=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rad=a=>a*Math.PI/180;
const rgbaCss=c=>`rgba(${c.r|0},${c.g|0},${c.b|0},${'a' in c?Math.max(0,Math.min(1,c.a)):1})`;
const hex2rgb=h=>{h=h.replace('#','');return{r:parseInt(h.slice(0,2),16)||0,g:parseInt(h.slice(2,4),16)||0,b:parseInt(h.slice(4,6),16)||0}};
const deep=o=>JSON.parse(JSON.stringify(o));
const uid=()=>Math.random().toString(36).slice(2);

/* ==== state ==== */
const state={
  canvasW:800, canvasH:600, zoom:1, panX:0, panY:0,
  tool:'select',
  layers:[],
  selection:[],
  imgCache:new Map(),
  grid:{size:20, show:false, snap:false},
  canvasBG:{mode:'solid', color:{r:255,g:255,b:255,a:1}, gradient:{angle:0,stops:[{pos:0,c:{r:255,g:255,b:255,a:1}},{pos:1,c:{r:255,g:255,b:255,a:1}}]}},
  uiFill:{solid:{r:30,g:144,b:255,a:1}, grad:{angle:0,stops:[
    {pos:0.00,c:{r:30,g:144,b:255,a:1}},
    {pos:0.33,c:{r:122,g:167,b:255,a:1}},
    {pos:0.66,c:{r:163,g:191,b:250,a:1}},
    {pos:1.00,c:{r:255,g:255,b:255,a:1}}
  ]}},
  hist:[], histI:-1,
  snapFlash: { t: 0, x: 0, y: 0 },
  snapColor: '#34d399',
  showCenterGuides: false,
  guideColor: '#60a5fa'
};
const HANDLE_R=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--handleR'))||10;
const snapState={x:false,y:false};

/* ==== canvas setup ==== */
const stage=d('stage');
const canvas=d('canvas'), ctx=canvas.getContext('2d');
const overlay=d('overlay'), octx=overlay.getContext('2d');

function toScreen(x,y){return {x:(x+state.panX)*state.zoom, y:(y+state.panY)*state.zoom};}
function toCanvas(x,y){return {x:x/state.zoom - state.panX, y:y/state.zoom - state.panY};}
const stageRect = () => stage.getBoundingClientRect();
const toCanvasFromClient = (clientX, clientY) => {
  const r = stageRect();
  return toCanvas(clientX - r.left, clientY - r.top);
};

function centerView(){
  const r=stage.getBoundingClientRect();
  state.panX=(r.width-state.canvasW*state.zoom)/2/state.zoom;
  state.panY=(r.height-state.canvasH*state.zoom)/2/state.zoom;
  syncZoom();
}
function resizeStage(){
  const r=stage.getBoundingClientRect();
  canvas.width=r.width; canvas.height=r.height;
  overlay.width=r.width; overlay.height=r.height;
  drawAll();
}
if ('ResizeObserver' in window) new ResizeObserver(resizeStage).observe(stage);
window.addEventListener('resize', resizeStage);

  /*__CENTER_ON_LOAD__*/
  // Ensure canvas is centered on initial load
  try { centerView(); } catch(e) {}

/* ==== tools ==== */
document.querySelectorAll('.tool').forEach(b=>b.addEventListener('click',()=>{
  document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active'));
  b.classList.add('active'); state.tool=b.dataset.tool;
}));

/* ==== base layer helpers ==== */
function baseLayer(over={}){
  return Object.assign({
    id:uid(), type:'rect', name:'Layer', x:100,y:80,w:300,h:180, rot:0, visible:true, locked:false,
    fillMode:'solid', solidFill:deep(state.uiFill.solid), gradientFill:deep(state.uiFill.grad),
    strokeEnable:true, strokeType:'solid', strokeSolid:{r:0,g:0,b:0,a:1}, strokeW:2, strokeDash:0,
    blend:'source-over',
    sh:{x:0,y:0,blur:12,color:{r:0,g:0,b:0,a:0}},
    filters:'none',
    parent:null
  }, over);
}
function addLayer(L){state.layers.push(L); state.selection=[L.id]; pushHist(); refreshLayers(); drawAll();}

/* ==== image upload/drop ==== */
d('upload').onclick=()=>d('imgInput').click();
d('imgInput').addEventListener('change',ev=>{
  const f=ev.target.files?.[0]; if(!f) return;
  const r=new FileReader(); r.onload=()=>createImg(r.result,f.name); r.readAsDataURL(f); ev.target.value='';
});
stage.addEventListener('dragover',e=>e.preventDefault());
stage.addEventListener('drop',e=>{
  e.preventDefault();
  const f=e.dataTransfer.files?.[0];
  if(f&&f.type.startsWith('image/')){
    const r=new FileReader(); r.onload=()=>createImg(r.result,f.name); r.readAsDataURL(f);
  }
});
function createImg(url,name='Image'){
  const im=new Image();
  im.onload=()=>{
    state.imgCache.set(url,im);
    const w=Math.min(im.width,state.canvasW*.6);
    const h=im.height/im.width*w;
    addLayer(baseLayer({type:'image',name,w,h,x:(state.canvasW-w)/2,y:(state.canvasH-h)/2,src:url,fillMode:'none'}));
  };
  im.src=url;
}

/* ==== history ==== */
function pushHist(){
  state.hist = state.hist.slice(0, state.histI+1);
  state.hist.push(JSON.stringify({canvasW:state.canvasW,canvasH:state.canvasH,canvasBG:state.canvasBG,layers:state.layers}));
  if(state.hist.length>60) state.hist.shift(); else state.histI++;
}
function undo(){ if(state.histI<=0) return; state.histI--; Object.assign(state, JSON.parse(state.hist[state.histI])); refreshLayers(); drawAll(); }
function redo(){ if(state.histI>=state.hist.length-1) return; state.histI++; Object.assign(state, JSON.parse(state.hist[state.histI])); refreshLayers(); drawAll(); }

/* ==== grid & snapping ==== */
// zoom-aware snap tolerance (fix for not hitting vertical/horizontal guides at various zooms)
function snapTolCanvasUnits(){
  const SCREEN_TOL_PX = 14;           // friendlier snapping (was 10)
  return SCREEN_TOL_PX / state.zoom;  // convert to canvas units
}

function setSnapFlashFor(L){
  state.snapFlash = {
    t: performance.now(),
    x: L.x + L.w/2,
    y: L.y + L.h/2
  };
}
function snapGrid(L){
  if(!state.grid.snap) return;
  const s=state.grid.size||20;

  const bx=L.x, by=L.y, bw=L.w, bh=L.h;
  L.x=Math.round(L.x/s)*s;
  L.y=Math.round(L.y/s)*s;
  L.w=Math.max(1,Math.round(L.w/s)*s);
  L.h=Math.max(1,Math.round(L.h/s)*s);

  if(L.x!==bx || L.y!==by || L.w!==bw || L.h!==bh) setSnapFlashFor(L);
}
function snapCenter(L){
  const cx=state.canvasW/2, cy=state.canvasH/2;
  const lx=L.x+L.w/2, ly=L.y+L.h/2;
  const T = snapTolCanvasUnits(); // zoom-aware tolerance

  const nearX = Math.abs(lx - cx) < T;
  const nearY = Math.abs(ly - cy) < T;
  // accumulate for guide rendering this frame (works for all shapes)
  snapState.x = snapState.x || nearX;
  snapState.y = snapState.y || nearY;

  let did=false;
  if(nearX){ L.x=Math.round(cx-L.w/2); did=true; }
  if(nearY){ L.y=Math.round(cy-L.h/2); did=true; }
  if(did) setSnapFlashFor(L);
}

/* ==== hit test ==== */
function hit(p){
  for (let i = state.layers.length - 1; i >= 0; i--) {
    const L = state.layers[i];
    if (!L || L.visible === false || L.locked) continue;

    if (L.type === 'line') {
      const x1 = L.x, y1 = L.y;
      const x2 = L.x + (L.w || 0), y2 = L.y + (L.h || 0);
      const distance = pointToLineDistance(p.x, p.y, x1, y1, x2, y2);
      const sw = (typeof L.strokeWidth === 'number' ? L.strokeWidth : (typeof L.strokeW === 'number' ? L.strokeW : 2));
      // min 5px, scale by zoom so feel is consistent
      const tolerance = Math.max(5, sw * 2, 12 / (state.zoom || 1));
      if (distance <= tolerance) return L;
    } else {
      if (p.x >= L.x && p.x <= L.x + L.w && p.y >= L.y && p.y <= L.y + L.h) return L;
    }
  }
  return null;
}

/* ==== drawing helpers ==== */
function gradientLocal(ctx, ang, w, h){const a=rad(ang),dx=Math.cos(a)*w/2,dy=Math.sin(a)*h/2;return ctx.createLinearGradient(-dx,-dy,dx,dy);}
function fillFor(ctx,L){
  if(L.fillMode==='none'){ctx.fillStyle='rgba(0,0,0,0)';return;}
  if(L.fillMode==='solid'){ctx.fillStyle=rgbaCss(L.solidFill);return;}
  const g=gradientLocal(ctx,L.gradientFill.angle||0,L.w,L.h);
  L.gradientFill.stops.forEach(s=>g.addColorStop(s.pos, rgbaCss(s.c)));
  ctx.fillStyle=g;
}
function strokeFor(ctx,L){
  if(!L.strokeEnable||L.strokeW<=0||L.strokeType==='none'){ctx.strokeStyle='rgba(0,0,0,0)';return;}
  if(L.strokeType==='gradient'){const g=gradientLocal(ctx,L.gradientFill.angle||0,L.w,L.h); L.gradientFill.stops.forEach(s=>g.addColorStop(s.pos, rgbaCss(s.c))); ctx.strokeStyle=g;}
  else ctx.strokeStyle=rgbaCss(L.strokeSolid);
  ctx.lineWidth=L.strokeW||1; ctx.setLineDash(L.strokeDash>0?[L.strokeDash,L.strokeDash]:[]);
}

/* ==== text drawing ==== */
function drawWrappedTextWithUnderline(ctx,t){
  ctx.textAlign='left';
  const text=(t.text||'').replace(/\r\n?/g,'\n');
  const chunks=text.split(/(\n)/);
  const measure=s=>ctx.measureText(s).width;
  const lines=[];
  for(let i=0;i<chunks.length;i++){
    const part=chunks[i];
    if(part==='\n'){ lines.push({text:'', hard:true}); continue; }
    const words=part.split(/(\s+)/);
    let cur="";
    for(const w of words){
      const candidate=cur+w;
      if(candidate.trim()!=='' && measure(candidate)>t.w && cur!==''){
        lines.push({text:cur.trimEnd(), hard:false});
        cur=w.trimStart();
      }else{
        cur=candidate;
      }
    }
    if(cur!==""||part==="") lines.push({text:cur.trimEnd(), hard:true});
  }
  const lh=(t.lineHeight||1.3)*(t.fontSize||28);
  let y=-t.h/2;
  lines.forEach((L,i)=>{
    const txt=L.text;
    const w = measure(txt);
    let x=-t.w/2;
    if(t.textAlign==='center') x=-t.w/2+(t.w-w)/2;
    else if(t.textAlign==='right') x=-t.w/2+(t.w-w);
    else if(t.textAlign==='justify' && i !== lines.length-1 && txt.includes(' ')){
      const parts=txt.split(/\s+/).filter(Boolean), gaps=Math.max(1,parts.length-1);
      const normal=measure(parts.join(' ')), extra=Math.max(0,t.w-normal), add=extra/gaps;
      let cx=-t.w/2;
      for(let j=0;j<parts.length;j++){ ctx.fillText(parts[j],cx,y); cx+=measure(parts[j])+measure(' ')+add; }
      if(t.underline){
        const underlineY = y + (t.fontSize||28) + Math.max(1,Math.floor((t.fontSize||28)*0.1));
        ctx.beginPath(); ctx.moveTo(-t.w/2, underlineY); ctx.lineTo(-t.w/2 + t.w, underlineY);
        ctx.lineWidth=Math.max(1,Math.floor((t.fontSize||28)*0.06)); ctx.strokeStyle=ctx.fillStyle; ctx.stroke();
      }
      y+=lh; return;
    }else{
      ctx.fillText(txt,x,y);
      if(t.underline && txt){
        const underlineY = y + (t.fontSize||28) + Math.max(1,Math.floor((t.fontSize||28)*0.1));
        ctx.beginPath(); ctx.moveTo(x, underlineY); ctx.lineTo(x + w, underlineY);
        ctx.lineWidth=Math.max(1,Math.floor((t.fontSize||28)*0.06)); ctx.strokeStyle=ctx.fillStyle; ctx.stroke();
      }
      y+=lh; return;
    }
  });
}
function roundRectPath(ctx, w, h, r) {
  // Support both uniform radius (number) and per-corner radii (object with tl,tr,bl,br)
  let tl, tr, br, bl;
  if (r && typeof r === 'object') {
    tl = r.tl || 0;
    tr = r.tr || 0;
    br = r.br || 0;
    bl = r.bl || 0;
  } else {
    tl = tr = br = bl = r || 0;
  }
  const maxR = Math.min(Math.abs(w), Math.abs(h)) / 2;
  tl = Math.max(0, Math.min(tl, maxR));
  tr = Math.max(0, Math.min(tr, maxR));
  br = Math.max(0, Math.min(br, maxR));
  bl = Math.max(0, Math.min(bl, maxR));
  ctx.beginPath();
  // top edge
  ctx.moveTo(-w / 2 + tl, -h / 2);
  ctx.lineTo(w / 2 - tr, -h / 2);
  ctx.quadraticCurveTo(w / 2, -h / 2, w / 2, -h / 2 + tr);
  // right edge
  ctx.lineTo(w / 2, h / 2 - br);
  ctx.quadraticCurveTo(w / 2, h / 2, w / 2 - br, h / 2);
  // bottom edge
  ctx.lineTo(-w / 2 + bl, h / 2);
  ctx.quadraticCurveTo(-w / 2, h / 2, -w / 2, h / 2 - bl);
  // left edge
  ctx.lineTo(-w / 2, -h / 2 + tl);
  ctx.quadraticCurveTo(-w / 2, -h / 2, -w / 2 + tl, -h / 2);
  ctx.closePath();
}

/* ==== main draw ==== */
function drawGrid(){
  if(!state.grid.show) return;
  const s=state.grid.size; if(s<=0) return;
  const tl=toScreen(0,0);
  const startX=tl.x%(s*state.zoom), startY=tl.y%(s*state.zoom);
  octx.save(); octx.strokeStyle='rgba(148,163,184,.22)'; octx.lineWidth=1;
  for(let x=startX;x<overlay.width;x+=s*state.zoom){octx.beginPath();octx.moveTo(x,0);octx.lineTo(x,overlay.height);octx.stroke();}
  for(let y=startY;y<overlay.height;y+=s*state.zoom){octx.beginPath();octx.moveTo(0,y);octx.lineTo(overlay.width,y);octx.stroke();}
  octx.restore();
}

function drawCenterGuides(){
  if (!state.showCenterGuides) return;
  const tl=toScreen(0,0), sw=state.canvasW*state.zoom, sh=state.canvasH*state.zoom;
  const cx=tl.x+sw/2, cy=tl.y+sh/2;

  const g = hex2rgb(state.guideColor || '#60a5fa');
  const base = (a)=>`rgba(${g.r},${g.g},${g.b},${a})`;
  const colX = snapState.x ? (state.snapColor || '#34d399') : base(0.55);
  const colY = snapState.y ? (state.snapColor || '#34d399') : base(0.55);
  const dot  = (snapState.x||snapState.y) ? (state.snapColor || '#34d399') : base(0.9);

  octx.save(); octx.setLineDash([8,6]); octx.lineWidth=1.5;
  octx.strokeStyle=colX; octx.beginPath(); octx.moveTo(cx, tl.y); octx.lineTo(cx, tl.y+sh); octx.stroke();
  octx.strokeStyle=colY; octx.beginPath(); octx.moveTo(tl.x, cy); octx.lineTo(tl.x+sw, cy); octx.stroke();
  octx.setLineDash([]); octx.beginPath(); octx.arc(cx,cy,4,0,Math.PI*2); octx.fillStyle=dot; octx.fill();
  octx.restore();
}

// fading crosshair when snap occurs
function drawSnapFlash(){
  const sf = state.snapFlash;
  if (!sf || !sf.t) return;

  const age = performance.now() - sf.t;
  const LIFE = 250; // ms
  if (age > LIFE) return;

  const alpha = 1 - age / LIFE;
  const p = toScreen(sf.x, sf.y);

  octx.save();
  octx.globalAlpha = alpha;
  octx.lineWidth = 2;
  const col = state.snapColor || '#34d399';
  octx.strokeStyle = col;

  const arm = 12;
  octx.beginPath();
  octx.moveTo(p.x - arm, p.y); octx.lineTo(p.x + arm, p.y);
  octx.moveTo(p.x, p.y - arm); octx.lineTo(p.x, p.y + arm);
  octx.stroke();
  octx.restore();

  requestAnimationFrame(drawAll);
}

function drawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  octx.clearRect(0,0,overlay.width,overlay.height);

  // backdrop + canvas bg
  ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const tl=toScreen(0,0), sw=state.canvasW*state.zoom, sh=state.canvasH*state.zoom;
  if(state.canvasBG.mode==='none'){
    const size=Math.max(8,16*state.zoom);
    for(let y=0;y<sh;y+=size){for(let x=0;x<sw;x+=size){ctx.fillStyle=((x+y)/size)%2===0?'#f3f4f6':'#e5e7eb'; ctx.fillRect(tl.x+x,tl.y+y,size,size);}}
  } else if(state.canvasBG.mode==='solid'){
    ctx.fillStyle=rgbaCss(state.canvasBG.color); ctx.fillRect(tl.x,tl.y,sw,sh);
  } else {
    const a=rad(state.canvasBG.gradient.angle||0),dx=Math.cos(a)*sw/2,dy=Math.sin(a)*sh/2;
    const g=ctx.createLinearGradient(tl.x+sw/2-dx,tl.y+sh/2-dy,tl.x+sw/2+dx,tl.y+sh/2+dy);
    state.canvasBG.gradient.stops.forEach(s=>g.addColorStop(s.pos,rgbaCss(s.c)));
    ctx.fillStyle=g; ctx.fillRect(tl.x,tl.y,sw,sh);
  }

  // layers
  state.layers.forEach(L=>{
    if(!L.visible) return;
    const s=toScreen(L.x,L.y);
    ctx.save();
    ctx.translate(s.x+L.w*state.zoom/2, s.y+L.h*state.zoom/2);
    ctx.rotate(rad(L.rot||0));
    ctx.scale(state.zoom,state.zoom);
    ctx.globalCompositeOperation=L.blend||'source-over';
    const sh=L.sh||{x:0,y:0,blur:12,color:{r:0,g:0,b:0,a:0}};
    ctx.shadowOffsetX=sh.x||0; ctx.shadowOffsetY=sh.y||0; ctx.shadowBlur=sh.blur||0; ctx.shadowColor=rgbaCss(sh.color||{r:0,g:0,b:0,a:0});
    ctx.filter=L.filters||'none';

    if(L.type==='image'){
      const im=state.imgCache.get(L.src); if(im) ctx.drawImage(im,-L.w/2,-L.h/2,L.w,L.h);
    } else if(L.type==='line'){
      strokeFor(ctx,L); ctx.beginPath(); ctx.moveTo(-L.w/2,-L.h/2); ctx.lineTo(L.w/2,L.h/2); ctx.stroke();
    } else if(L.type==='ellipse'){
      fillFor(ctx,L); if(L.fillMode!=='none'){ ctx.beginPath(); ctx.ellipse(0,0,Math.abs(L.w/2),Math.abs(L.h/2),0,0,Math.PI*2); ctx.fill(); }
      strokeFor(ctx,L); ctx.beginPath(); ctx.ellipse(0,0,Math.abs(L.w/2),Math.abs(L.h/2),0,0,Math.PI*2); ctx.stroke();
    } else if(L.type==='roundrect'){
      // When drawing a round rectangle, use per-corner radii if defined on the layer.
      const radius = L.corners || L.cornerRadius || 12;
      fillFor(ctx,L);
      if(L.fillMode!=='none'){
        roundRectPath(ctx,L.w,L.h,radius);
        ctx.fill();
      }
      strokeFor(ctx,L);
      roundRectPath(ctx,L.w,L.h,radius);
      ctx.stroke();
    } else if(L.type==='rect'){
      fillFor(ctx,L); if(L.fillMode!=='none') ctx.fillRect(-L.w/2,-L.h/2,L.w,L.h);
      strokeFor(ctx,L); ctx.strokeRect(-L.w/2,-L.h/2,L.w,L.h);
    } else if(L.type==='text'){
      const t=L;
      if(t.fillMode==='gradient'){const g=gradientLocal(ctx,t.gradientFill.angle||0,t.w,t.h); t.gradientFill.stops.forEach(s=>g.addColorStop(s.pos,rgbaCss(s.c))); ctx.fillStyle=g;}
      else if(t.fillMode==='solid'){ctx.fillStyle=rgbaCss(t.solidFill||{r:0,g:0,b:0,a:1});}
      else ctx.fillStyle='rgba(0,0,0,0)';
      ctx.textBaseline='top';
      ctx.font=`${t.italic?'italic':''} ${t.bold?700:400} ${t.fontSize||28}px ${t.fontFamily||'system-ui, Arial'}`;
      drawWrappedTextWithUnderline(ctx,t);
    }
    ctx.restore();
  });

  // selection handles
  state.selection.forEach(id=>{
    const L=layerById(id); if(!L) return;
    const s=toScreen(L.x,L.y);
    ctx.save(); ctx.translate(s.x,s.y); ctx.scale(state.zoom,state.zoom);
    ctx.strokeStyle='#60a5fa'; ctx.setLineDash([4,2]); ctx.strokeRect(0,0,L.w,L.h); ctx.setLineDash([]);
    ctx.fillStyle='#3b82f6'; [[0,0],[L.w,0],[L.w,L.h],[0,L.h]].forEach(pt=>{ctx.beginPath(); ctx.arc(pt[0],pt[1],HANDLE_R,0,Math.PI*2); ctx.fill();});
    ctx.restore();
  });

  drawGrid();
  drawCenterGuides();
  drawSnapFlash();
}

/* ==== interactions ==== */
let drag=null;
function handleAt(L,p){
  const pad=(HANDLE_R+4)/state.zoom;
  const corners=[{k:'tl',x:L.x,y:L.y},{k:'tr',x:L.x+L.w,y:L.y},{k:'br',x:L.x+L.w,y:L.y+L.h},{k:'bl',x:L.x,y:L.y+L.h}];
  for(const c of corners){ if(Math.abs(p.x-c.x)<=pad && Math.abs(p.y-c.y)<=pad) return c.k; }
  if(p.x>=L.x&&p.x<=L.x+L.w&&p.y>=L.y&&p.y<=L.y+L.h) return 'body';
  return null;
}

stage.addEventListener('mousedown',e=>{
  const r=stage.getBoundingClientRect(); const p=toCanvas(e.clientX-r.left,e.clientY-r.top);
  if(e.button===1||state.tool==='pan'){drag={mode:'pan',start:p,orig:{x:state.panX,y:state.panY}}; return;}
  if(state.tool==='select'){
    const h=hit(p);
    if(h){
      if(e.shiftKey||e.ctrlKey){ const i=state.selection.indexOf(h.id); if(i>=0) state.selection.splice(i,1); else state.selection.push(h.id); }
      else { state.selection=[h.id]; }
      const hd=handleAt(h,p);
      if(h.type==='text' && hd==='body' && e.detail===2) openTextEditor(h);
      if(hd && hd!=='body'){
        drag={mode:'resize',ids:[...state.selection],handle:hd,start:p,orig:state.selection.map(id=>{const L=layerById(id); return {id,x:L.x,y:L.y,w:L.w,h:L.h}})};
      }else{
        drag={mode:'move',ids:[...state.selection],start:p,orig:state.selection.map(id=>{const L=layerById(id); return {id,x:L.x,y:L.y}})};
      }
    }else{
      state.selection=[];
    }
    refreshLayers(); syncTextPanel(); drawAll(); return;
  }
  if(state.tool==='text'){
    const h=hit(p);
    if(h && h.type==='text'){ state.selection=[h.id]; refreshLayers(); syncTextPanel(); drawAll(); openTextEditor(h); return; }
    if(e.detail===1){
      addLayer(baseLayer({type:'text',name:'Text',text:'Edit me',fontSize:28,lineHeight:1.3,fontFamily:'system-ui, Arial',textAlign:'left',underline:false}));
      openTextEditor(layerById(state.selection[0]));
      return;
    }
  }
  if(['rect','roundrect','ellipse','line'].includes(state.tool)){
    const map={rect:'Rectangle',roundrect:'Round',ellipse:'Ellipse',line:'Line'};
    addLayer(baseLayer({type:state.tool,name:map[state.tool],w:240,h:140,fillMode:'solid'}));
    if(state.tool==='line'){const L=layerById(state.selection[0]); L.h=0; L.fillMode='none';}
  }
});

stage.addEventListener('dblclick',e=>{
  const r=stage.getBoundingClientRect(); const p=toCanvas(e.clientX-r.left,e.clientY-r.top);
  const h=hit(p);
  if(h && h.type==='text'){ state.selection=[h.id]; refreshLayers(); drawAll(); openTextEditor(h); }
});

stage.addEventListener('mousemove',e=>{
  if(!drag) return;
  const p=toCanvasFromClient(e.clientX,e.clientY);

  // reset guide flags for this frame (so any selected layer canvas light the guides)
  snapState.x = false;
  snapState.y = false;

  if(drag.mode==='pan'){
    state.panX=drag.orig.x+(p.x-drag.start.x); state.panY=drag.orig.y+(p.y-drag.start.y);
    drawAll(); return;
  }
  if(drag.mode==='move'){
    drag.ids.forEach(id=>{
      const L=layerById(id);
      const o=drag.orig.find(o=>o.id===id);
      L.x=o.x+(p.x-drag.start.x); L.y=o.y+(p.y-drag.start.y);
      if(state.grid.snap) snapGrid(L);
      snapCenter(L);
    });
    syncTransform(); drawAll(); return;
  }
  if(drag.mode==='resize'){
    drag.ids.forEach(id=>{
      const L=layerById(id);
      const o=drag.orig.find(o=>o.id===id);
      let {x,y,w,h}=o; const dx=p.x-drag.start.x, dy=p.y-drag.start.y;
      if(drag.handle==='tl'){x+=dx; y+=dy; w-=dx; h-=dy;}
      if(drag.handle==='tr'){y+=dy; w+=dx; h-=dy;}
      if(drag.handle==='br'){w+=dx; h+=dy;}
      if(drag.handle==='bl'){x+=dx; w-=dx; h+=dy;}
      L.x=Math.min(x,x+w); L.y=Math.min(y,y+h);
      L.w=Math.max(5,Math.abs(w)); L.h=Math.max(5,Math.abs(h));
      if(L.type==='line'){L.w=w; L.h=h;}
      if(state.grid.snap) snapGrid(L);
      snapCenter(L);
    });
    syncTransform(); drawAll(); return;
  }
});

stage.addEventListener('mouseup',()=>{ if(drag){ pushHist(); } drag=null; });

/* ==== text editor ==== */
function openTextEditor(L){
  const te = d('textEdit');
  te.value = L.text || '';
  te.style.display = 'block';
  te.focus();
  te.oninput = () => {
    L.text = te.value;          // update canvas object
    d('textValue').value = L.text;  // sync to panel textarea
    drawAll();
  };
}

/* ==== Text panel sync ==== */
  function syncTextPanel(){
  const ta = d('textValue');    // textarea in Text panel
  const ff = d('fontFamily');   // font select
  const fs = d('fontSize');     // size input
  const al = d('textAlign');    // alignment dropdown
  const lh = d('lineHeight');   // line height
  const L = getPrimary();       // currently selected layer

  if (L && L.type === 'text') {
    // unlock + populate panel fields from active text layer
    ta.removeAttribute('readonly');
    ta.value = L.text || '';
    ff.value = L.fontFamily || ff.value;
    fs.value = parseInt(L.fontSize || '28', 10);
    al.value = L.textAlign || 'left';
    lh.value = parseFloat(L.lineHeight || '1.3');

    // Update BIU checkboxes from layer boolean flags if present
    try {
      const boldChk = document.getElementById('bold');
      const italicChk = document.getElementById('italic');
      const underlineChk = document.getElementById('underline');
      if (boldChk) boldChk.checked = !!L.bold;
      if (italicChk) italicChk.checked = !!L.italic;
      if (underlineChk) underlineChk.checked = !!L.underline;
      // Trigger UI button sync if available
      if (typeof syncButtonsFromChecks === 'function') {
        syncButtonsFromChecks();
      }
    } catch(e){}
  } else {
    // no text selected → lock + clear
    ta.value = '';
    ta.placeholder = 'Select a text layer to edit';
    ta.setAttribute('readonly','readonly');

    // Ensure BIU toggles reflect no selection
    try {
      const boldChk = document.getElementById('bold');
      const italicChk = document.getElementById('italic');
      const underlineChk = document.getElementById('underline');
      if (boldChk) boldChk.checked = false;
      if (italicChk) italicChk.checked = false;
      if (underlineChk) underlineChk.checked = false;
      if (typeof syncButtonsFromChecks === 'function') {
        syncButtonsFromChecks();
      }
    } catch(e){}
  }
}


/* ==== UI wiring ==== */
function syncZoom(){ d('zLabel').textContent=Math.round(state.zoom*100)+'%'; d('zRange').value=state.zoom; drawAll(); }
d('zIn').onclick=()=>{state.zoom=clamp(state.zoom+0.1,0.1,4); syncZoom();};
d('zOut').onclick=()=>{state.zoom=clamp(state.zoom-0.1,0.1,4); syncZoom();};
d('zRange').oninput=e=>{state.zoom=parseFloat(e.target.value); syncZoom();};
d('centerView').onclick=()=>{centerView(); drawAll();};
d('centerX').onclick=()=>{
  if(!state.selection.length) return;
  const cx=state.canvasW/2;
  state.selection.forEach(id=>{const L=layerById(id); if(!L) return; L.x=Math.round(cx - L.w/2);});
  syncTransform(); drawAll(); pushHist();
};

// canvas size/units
const unitSel=d('unit'), dpiInp=d('dpi');
function pxToUnit(px){const u=unitSel.value,dpi=parseFloat(dpiInp.value)||96; if(u==='px')return +px.toFixed(0); if(u==='cm')return +(px*2.54/dpi).toFixed(2); if(u==='in')return +(px/dpi).toFixed(2);}
function unitToPx(v){const u=unitSel.value,dpi=parseFloat(dpiInp.value)||96; if(u==='px')return v; if(u==='cm')return v*dpi/2.54; if(u==='in')return v*dpi;}
d('applyCanvas').onclick=()=>{ const w=unitToPx(parseFloat(d('cw').value||0)); const h=unitToPx(parseFloat(d('ch').value||0)); if(w>0&&h>0){ state.canvasW=Math.round(w); state.canvasH=Math.round(h); centerView(); pushHist(); drawAll(); } };
unitSel.onchange=()=>{ d('cw').value=pxToUnit(state.canvasW); d('ch').value=pxToUnit(state.canvasH); };
dpiInp.onchange=unitSel.onchange;
// grid
d('gridShow').onchange=e=>{state.grid.show=e.target.checked; drawAll();};
d('gridSize').oninput=e=>{state.grid.size=parseInt(e.target.value||20,10); drawAll();};
d('gridSnap').onchange=e=>{state.grid.snap=e.target.checked;};

// Snap Color picker
const snapColorInput = d('snapColor');
if (snapColorInput) {
  snapColorInput.value = state.snapColor || '#34d399';
  snapColorInput.addEventListener('input', () => {
    state.snapColor = snapColorInput.value || '#34d399';
    drawAll();
  });
}

// Guides toggle + Guide color
d('toggleGuides').onclick = () => {
  state.showCenterGuides = !state.showCenterGuides;
  d('toggleGuides').textContent = state.showCenterGuides ? 'Guides: On' : 'Guides: Off';
  drawAll();
};
const guideColorInput = d('guideColor');
guideColorInput.addEventListener('input', (e) => {
  state.guideColor = e.target.value || '#60a5fa';
  drawAll();
});

// transform
function getPrimary(){return layerById(state.selection[state.selection.length-1]);}
function layerById(id){return state.layers.find(l=>l.id===id);} 
function syncTransform(){
  const L=getPrimary(); if(!L){['tx','ty','tw','th','trot'].forEach(id=>d(id).value=''); return;}
  d('tx').value=Math.round(L.x); d('ty').value=Math.round(L.y);
  d('tw').value=Math.round(Math.abs(L.w)); d('th').value=Math.round(Math.abs(L.h));
  d('trot').value=Math.round(L.rot||0);
}
['tx','ty','tw','th','trot'].forEach(id=>{
  d(id).addEventListener('input',()=>{
    const L=getPrimary(); if(!L) return;
    const x=parseFloat(d('tx').value)||L.x, y=parseFloat(d('ty').value)||L.y;
    let w=parseFloat(d('tw').value)||L.w, h=parseFloat(d('th').value)||L.h;
    const rot=parseFloat(d('trot').value)||0;
    if(d('tLock').checked){ const aspect=L.w/(L.h||1); if(document.activeElement===d('tw')) h=Math.round(w/(aspect||1)); else if(document.activeElement===d('th')) w=Math.round(h*(aspect||1)); }
    L.x=x; L.y=y; L.w=Math.max(1,w); L.h=Math.max(1,h); L.rot=rot;
    if(state.grid.snap) snapGrid(L);
    snapCenter(L);
    drawAll();
  });
});

// fill
function toggleFillUI(){
  const m = d('fillMode').value;
  // Display solid and gradient rows based on mode; use !important to override other CSS
  var solidRow = d('fillSolid');
  var gradRow = d('fillGrad');
  if (solidRow) solidRow.style.setProperty('display', (m === 'solid') ? 'flex' : 'none', 'important');
  if (gradRow) gradRow.style.setProperty('display', (m === 'gradient') ? 'block' : 'none', 'important');
  // Show the angle controls (label + slider) only for gradient fills
  var wrap = d('gAngleWrap');
  if (wrap) wrap.style.setProperty('display', (m === 'gradient') ? 'flex' : 'none', 'important');
}

// Synchronize the Round corners row with the current selection.
// Only enable inputs when the selected primary layer is a round rectangle (type 'roundrect').
// When enabled, populate the inputs with existing corner values if present.
function syncRoundRow(){
  const tl = d('cornerTL');
  const tr = d('cornerTR');
  const bl = d('cornerBL');
  const br = d('cornerBR');
  if(!tl || !tr || !bl || !br) return;
  // Always enable the corner inputs; show current values if present on the primary layer
  const L = getPrimary();
  const isRound = (L && L.type === 'roundrect');
  const corners = (isRound && L.corners) ? L.corners : {tl:0,tr:0,bl:0,br:0};
  // Show or hide the entire corner radius row based on shape type. Because the
  // CSS for #strokeRoundRow uses `display: flex !important`, simply assigning
  // `style.display = 'none'` does not override it. Instead we use
  // `setProperty` with the third parameter 'important' to ensure our
  // preference takes precedence. When the selected layer is not a round
  // rectangle, hide the row; otherwise show it.
  const rowEl = d('strokeRoundRow');
  if (rowEl) {
    const displayValue = isRound ? 'flex' : 'none';
    rowEl.style.setProperty('display', displayValue, 'important');
  }
  // Enable inputs only for roundrect shapes
  tl.disabled = !isRound;
  tr.disabled = !isRound;
  bl.disabled = !isRound;
  br.disabled = !isRound;
  // Update input values
  tl.value = corners.tl || 0;
  tr.value = corners.tr || 0;
  bl.value = corners.bl || 0;
  br.value = corners.br || 0;
}
d('fillMode').onchange=()=>{const L=getPrimary(); toggleFillUI(); if(L){ L.fillMode=d('fillMode').value; if(L.fillMode==='solid') L.solidFill=deep(state.uiFill.solid); if(L.fillMode==='gradient') L.gradientFill=deep(state.uiFill.grad); drawAll();}};
d('fillColor').oninput=e=>{state.uiFill.solid={...hex2rgb(e.target.value),a:state.uiFill.solid.a}; const L=getPrimary(); if(L&&d('fillMode').value==='solid'){L.solidFill=deep(state.uiFill.solid); drawAll();}};
d('fillAlpha').oninput=e=>{state.uiFill.solid.a=parseFloat(e.target.value); d('fillAlphaL').textContent=state.uiFill.solid.a.toFixed(2); const L=getPrimary(); if(L&&d('fillMode').value==='solid'){L.solidFill.a=state.uiFill.solid.a; drawAll();}};
['g1','g2','g3','g4'].forEach((id,i)=>d(id)?.addEventListener('input',e=>{state.uiFill.grad.stops[i].c={...hex2rgb(e.target.value),a:state.uiFill.grad.stops[i].c?.a??1}; const L=getPrimary(); if(L&&d('fillMode').value==='gradient'){L.gradientFill=deep(state.uiFill.grad); drawAll();}}));
['g1a','g2a','g3a','g4a'].forEach((id,i)=>d(id)?.addEventListener('input',e=>{state.uiFill.grad.stops[i].c.a=parseFloat(e.target.value); const L=getPrimary(); if(L&&d('fillMode').value==='gradient'){L.gradientFill=deep(state.uiFill.grad); drawAll();}}));
d('gAngle').oninput=e=>{state.uiFill.grad.angle=parseInt(e.target.value,10); d('gAngleL').textContent=state.uiFill.grad.angle+'°'; const L=getPrimary(); if(L&&d('fillMode').value==='gradient'){L.gradientFill.angle=state.uiFill.grad.angle; drawAll();}};

// stop positions equalizer (kept)
function applyEqualStopPositions(){
  const S = state.uiFill.grad.stops;
  const colors = [S[0].c, S[1].c, S[2].c, S[3].c];
  const positions = [0, 1/3, 2/3, 1];
  state.uiFill.grad.stops = positions.map((p,i)=>({ pos: Math.max(0, Math.min(1, p)), c: colors[i] }));
  const eps = 1e-6;
  for (let i = 1; i < state.uiFill.grad.stops.length; i++) {
    if (state.uiFill.grad.stops[i].pos <= state.uiFill.grad.stops[i-1].pos) {
      state.uiFill.grad.stops[i].pos = Math.min(1, state.uiFill.grad.stops[i-1].pos + eps);
    }
  }
  const L = getPrimary();
  if (L && d('fillMode').value === 'gradient') {
    L.gradientFill = deep(state.uiFill.grad);
  }
  drawAll();
}
['g1pBtn','g2pBtn','g3pBtn','g4pBtn'].forEach((id)=>{
  const btn = d(id); if(!btn) return;
  btn.addEventListener('click', applyEqualStopPositions);
});

d('toCanvas').onclick=()=>{const m=d('fillMode').value; if(m==='none') state.canvasBG.mode='none'; else if(m==='solid'){state.canvasBG.mode='solid'; state.canvasBG.color=deep(state.uiFill.solid);} else {state.canvasBG.mode='gradient'; state.canvasBG.gradient=deep(state.uiFill.grad);} drawAll();};
d('toShape').onclick=()=>{const L=getPrimary(); if(!L) return; const m=d('fillMode').value; if(m==='none') L.fillMode='none'; else if(m==='solid'){L.fillMode='solid'; L.solidFill=deep(state.uiFill.solid);} else {L.fillMode='gradient'; L.gradientFill=deep(state.uiFill.grad);} drawAll();};
d('toText').onclick=()=>{const L=getPrimary(); if(!L||L.type!=='text') return; const m=d('fillMode').value; if(m==='none') L.fillMode='none'; else if(m==='solid'){L.fillMode='solid'; L.solidFill=deep(state.uiFill.solid);} else {L.fillMode='gradient'; L.gradientFill=deep(state.uiFill.grad);} drawAll();};

// stroke
d('strokeType').onchange=()=>{const L=getPrimary(); if(!L) return; L.strokeType=d('strokeType').value; drawAll();};
d('strokeW').oninput=e=>{d('strokeWL').textContent=e.target.value; const L=getPrimary(); if(!L) return; L.strokeW=parseInt(e.target.value,10)||0; drawAll();};
d('strokeDash').oninput=e=>{const L=getPrimary(); if(!L) return; L.strokeDash=parseInt(e.target.value,10)||0; drawAll();};
d('strokeColor').oninput=e=>{const L=getPrimary(); if(!L) return; L.strokeSolid={...hex2rgb(e.target.value),a:(L.strokeSolid?.a??1)}; drawAll();};

// Round corner inputs: update individual corner radii on the primary layer
['cornerTL','cornerTR','cornerBL','cornerBR'].forEach(id=>{
  const input = d(id);
  if(input){
    input.addEventListener('input', e => {
      const L = getPrimary();
      if(!L) return;
      // Initialize corner object if missing
      L.corners = L.corners || {tl:0,tr:0,bl:0,br:0};
      const val = parseFloat(e.target.value) || 0;
      if(id === 'cornerTL') L.corners.tl = val;
      else if(id === 'cornerTR') L.corners.tr = val;
      else if(id === 'cornerBL') L.corners.bl = val;
      else if(id === 'cornerBR') L.corners.br = val;
      drawAll();
      pushHist();
    });
  }
});
d('strokeAlpha').oninput=e=>{d('strokeAlphaL').textContent=parseFloat(e.target.value).toFixed(2); const L=getPrimary(); if(!L) return; L.strokeSolid={...(L.strokeSolid||{r:0,g:0,b:0,a:1}), a:parseFloat(e.target.value)}; drawAll();};
d('transparentShapeBtn').onclick=()=>{const L=getPrimary(); if(!L) return; L.fillMode='none'; drawAll();};

// effects
d('effectsNone').onclick=()=>{const L=getPrimary(); if(!L) return; L.blend='source-over'; L.sh={x:0,y:0,blur:12,color:{r:0,g:0,b:0,a:0}}; L.filters='none'; d('blendMode').value='source-over'; d('shAlpha').value=0; d('shAlphaL').textContent='0.00'; d('filterSel').value='none'; drawAll();};
d('blendMode').onchange=e=>{const L=getPrimary(); if(!L) return; L.blend=e.target.value; drawAll();};
['shX','shY','shBlur'].forEach(id=>d(id).oninput=e=>{const L=getPrimary(); if(!L) return; L.sh=L.sh||{x:0,y:0,blur:0,color:{r:0,g:0,b:0,a:0}}; L.sh[id==='shX'?'x':id==='shY'?'y':'blur']=parseFloat(e.target.value)||0; drawAll();});
d('shColor').oninput=e=>{const L=getPrimary(); if(!L) return; L.sh=L.sh||{}; L.sh.color={...hex2rgb(e.target.value), a:(L.sh.color?.a??0)}; drawAll();};
d('shAlpha').oninput=e=>{d('shAlphaL').textContent=parseFloat(e.target.value).toFixed(2); const L=getPrimary(); if(!L) return; L.sh=L.sh||{color:{r:0,g:0,b:0,a:0}}; L.sh.color={...(L.sh.color||{r:0,g:0,b:0,a:0}), a:parseFloat(e.target.value)}; drawAll();};

/* ==== text panel (mirror) ==== */
function applyText(fn){const L=getPrimary(); if(L&&L.type==='text'){fn(L); drawAll();}}
d('textValue').addEventListener('input',e=>applyText(L=>L.text=e.target.value));
d('fontFamily').addEventListener('change',e=>applyText(L=>L.fontFamily=e.target.value));
d('fontSize').addEventListener('input',e=>applyText(L=>L.fontSize=parseInt(e.target.value||'28',10)));
d('textAlign').addEventListener('change',e=>applyText(L=>L.textAlign=e.target.value));
d('lineHeight').addEventListener('input',e=>applyText(L=>L.lineHeight=parseFloat(e.target.value||'1.3')));
['bold','italic','underline'].forEach(id=>d(id).addEventListener('change',e=>applyText(L=>L[id]=e.target.checked)));

/* ==== layers UI ==== */
function refreshLayers(){
  const box=d('layers'); box.innerHTML='';
  state.layers.forEach(l=>{
    const row=document.createElement('div'); row.className='layer'+(state.selection.includes(l.id)?' sel':'');
    const eye=document.createElement('button'); eye.className='btn'; eye.textContent=l.visible?'\ud83d\udc41\ufe0f':'\ud83d\ude48'; eye.title='Show/Hide';
    eye.onclick=(ev)=>{ev.stopPropagation(); l.visible=!l.visible; refreshLayers(); drawAll();};
    const lock=document.createElement('button'); lock.className='btn'; lock.textContent=l.locked?'\ud83d\udd12':'\ud83d\udd13'; lock.title='Lock/Unlock';
    lock.onclick=(ev)=>{ev.stopPropagation(); l.locked=!l.locked; refreshLayers();};
    const name=document.createElement('span'); name.style.flex='1'; name.textContent=(l.name||l.type); name.title='Double-click to rename';
    name.ondblclick=()=>{const inp=document.createElement('input'); inp.type='text'; inp.value=(l.name||l.type); const commit=()=>{l.name=inp.value.trim()||l.name||l.type; name.textContent=l.name; inp.replaceWith(name);}; inp.addEventListener('keydown',ev=>{if(ev.key==='Enter') commit(); if(ev.key==='Escape') inp.replaceWith(name);}); inp.addEventListener('blur',commit); name.replaceWith(inp); inp.focus(); inp.select();};
    row.append(eye,lock,name);
    row.onclick=(ev)=>{ if(ev.detail===2) return; if(ev.shiftKey||ev.ctrlKey){ const ix=state.selection.indexOf(l.id); if(ix>=0) state.selection.splice(ix,1); else state.selection.push(l.id);} else state.selection=[l.id]; refreshLayers(); syncTransform(); drawAll(); };
    box.append(row);
  });
  syncTransform();
  syncTextPanel();
  if(typeof syncRoundRow === 'function') syncRoundRow();
 }
d('bringF').onclick=()=>reorder(1);
d('sendB').onclick=()=>reorder(-1);
function reorder(delta){
  if(!state.selection.length) return; const id=state.selection[0];
  const i=state.layers.findIndex(l=>l.id===id); const j=i+delta; if(j<0||j>=state.layers.length) return;
  [state.layers[i],state.layers[j]]=[state.layers[j],state.layers[i]]; pushHist(); refreshLayers(); drawAll();
}

/* ==== context menu ==== */
const menu=d('contextMenu');
stage.addEventListener('contextmenu',e=>{
  e.preventDefault(); menu.innerHTML='';
  const items=[["Duplicate",dupSel],["Delete",delSel],["Lock/Unlock",toggleLock],["Hide/Show",toggleVisible],["Bring Forward",()=>reorder(1)],["Send Back",()=>reorder(-1)]];
  items.forEach(([label,fn])=>{const b=document.createElement('button'); b.textContent=label; b.onclick=()=>{fn(); menu.style.display='none';}; menu.append(b);});
  menu.style.left=e.clientX+'px'; menu.style.top=e.clientY+'px'; menu.style.display='block';
});
document.addEventListener('click',()=>menu.style.display='none');
function dupSel(){
  const clones=[];
  state.selection.forEach(id=>{
    const L=layerById(id);
    const C=deep(L); C.id=uid(); C.x+=24; C.y+=24; clones.push(C);
  });
  state.layers.push(...clones);
  state.selection=clones.map(c=>c.id);
  pushHist(); refreshLayers(); drawAll();
}
function delSel(){
  const ids=new Set(state.selection);
  state.layers = state.layers.filter(l=>!ids.has(l.id));
  state.selection=[]; pushHist(); refreshLayers(); drawAll();
}
function toggleLock(){state.selection.forEach(id=>{const L=layerById(id); L.locked=!L.locked;}); refreshLayers();}
function toggleVisible(){state.selection.forEach(id=>{const L=layerById(id); L.visible=!L.visible;}); refreshLayers(); drawAll();}

/* ==== export / print ==== */
d('fmt').onchange=()=>{d('quality').style.display=(d('fmt').value==='image/png')?'none':'block';};


/* Make range+color inputs visually match height without breaking their native UI */
[data-sec="Stroke"] input[type="range"],
[data-sec="Stroke"] input[type="color"] {
  height: 28px !important;
  min-height: 28px !important;
  box-sizing: border-box !important;
}

/* 2) Stretch rows to full width and space items neatly */
[data-sec="Stroke"] .row {
  display: flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  gap: 8px !important;
  width: 100% !important;
}

/* 3) Let key sliders grow to consume remaining width */
[data-sec="Stroke"] #strokeW,
[data-sec="Stroke"] #strokeAlpha {
  flex: 1 1 auto !important;
  max-width: none !important;
}

/* 4) Keep numeric readouts compact */
[data-sec="Stroke"] #strokeWL,
[data-sec="Stroke"] #strokeAlphaL {
  flex: 0 0 auto !important;
  min-width: 36px !important;
  text-align: center !important;
}

/* 5) Dash and Color group sizing: inputs stay compact */
[data-sec="Stroke"] #strokeDash {
  width: 70px !important;
  max-width: 90px !important;
  text-align: center !important;
  flex: 0 0 auto !important;
}
[data-sec="Stroke"] #strokeColor {
  inline-size: 28px !important;
  block-size: 24px !important;
  flex: 0 0 auto !important;
}

/* 6) Type + Transparent row: let selector & button share width */
[data-sec="Stroke"] #strokeType,
[data-sec="Stroke"] #transparentShapeBtn {
  flex: 1 1 0 !important;
  max-width: none !important;
}

/* 7) Labels: remove forced min-widths inside Stroke so they don't create extra gaps */
[data-sec="Stroke"] label.small {
  min-width: auto !important;
  margin: 0 !important;
  white-space: nowrap !important;
}
</style>

<!-- Uniform height augmentation v4 (high-specificity overrides) -->
<style id="css-uniform-height-dup2">
/* === Global 35px baseline for target panels === */
[data-sec="Canvas"] label.small,
[data-sec="Transform"] label.small,
[data-sec="Fill"] label.small,
[data-sec="Stroke"] label.small,
[data-sec="Effects"] label.small,
[data-sec="Canvas"] input,
[data-sec="Transform"] input,
[data-sec="Fill"] input,
[data-sec="Stroke"] input,
[data-sec="Effects"] input,
[data-sec="Canvas"] select,
[data-sec="Transform"] select,
[data-sec="Fill"] select,
[data-sec="Stroke"] select,
[data-sec="Effects"] select,
[data-sec="Canvas"] .btn,
[data-sec="Transform"] .btn,
[data-sec="Fill"] .btn,
[data-sec="Stroke"] .btn,
[data-sec="Effects"] .btn {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  white-space: nowrap !important;
  padding: 0 10px !important;
}

/* === Stroke: per-ID overrides to defeat more specific rules === */
[data-sec="Stroke"] #strokeW,
[data-sec="Stroke"] #strokeAlpha,
[data-sec="Stroke"] #strokeDash,
[data-sec="Stroke"] #strokeColor,
[data-sec="Stroke"] #strokeType,
[data-sec="Stroke"] #transparentShapeBtn,
[data-sec="Stroke"] #strokeWL,
[data-sec="Stroke"] #strokeAlphaL {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 10px !important;
}

/* Fix color input intrinsic box */
[data-sec="Stroke"] #strokeColor {
  inline-size: 35px !important;
  block-size: 35px !important;
  padding: 0 !important;
}

/* === Transform: explicit targeting === */
#transformRowXY input[type="number"],
#transformRowWH input[type="number"],
#transformRowRotLock input[type="number"],
#transformRowRotLock input[type="checkbox"],
#transformRowXY label.small,
#transformRowWH label.small,
#transformRowRotLock label.small {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 10px !important;
}

/* Checkbox visual centering */
#transformRowRotLock input[type="checkbox"] {
  width: 18px !important;
  height: 18px !important; /* intrinsic box */
  padding: 0 !important;
  margin: 0 4px 0 0 !important;
  align-self: center !important;
}

/* Range inputs in Stroke should also visually match */
[data-sec="Stroke"] input[type="range"] {
  height: 35px !important;
  min-height: 35px !important;
  align-self: center !important;
}
</style>

<!-- Canvas tighten + Color width augmentation -->
<!-- Canvas Apply row tighten v2 + round color inputs + gradient compact -->
<style id="css-effects-tidy-dup2">
#effectsTopRow, #effectsAlphaOnly {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;
}
#effectsTopRow select#blendMode {
  width: 140px !important;
}
</style>

<style id="css-fill-tighter-dup2">
/* Tighter vertical height for linear gradient controls */
#fillGrad { margin-top: 2px !important; }
#fillGrad .grid-2 { gap: 4px 10px !important; }
#fillGrad .grid-2 > .row { gap: 2px !important; margin: 0 !important; }
#fillGrad .grid-2 > .row label.small { height: auto !important; line-height: 1 !important; }
#fillGrad input[type="range"] { width: 140px !important; }
#gAngle { width: 160px !important; }
</style>

<style id="css-canvas-apply-tight-dup2">
#canvasPanel #canvasApplyRow {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 100% !important;
  padding: 0 6px 4px 6px !important;
  margin:0 !important;
  box-sizing: border-box !important;
}
#canvasPanel #applyCanvas {
  max-width: 100% !important;
  margin: 0 !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
</style>

<style id="css-effects-one-row-dup2">
#effectsTopRow {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;
}
#effectsTopRow #blendNormalLabel {
  text-transform: none !important;
  font-weight: 500 !important;
}
</style>

<style id="css-color-25px-round-dup2">
/* === Force all color pickers to be perfectly round 25×25 === */
input[type="color"],
[data-sec] input[type="color"],
header input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  border-radius: 9999px !important;
  padding: 0 !important;
  border: none !important;
  background: none !important;
  overflow: hidden !important;
  box-sizing: border-box !important;
}

/* WebKit */
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 9999px !important; }
input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 9999px !important; }

/* Firefox */
input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 9999px !important; }
</style>

<style id="css-color-25px-final-dup2">
/* Highest-priority rule for all color pickers */
#right input[type="color"],
header input[type="color"],
[data-sec] input[type="color"],
input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
}

/* WebKit fix */
input[type="color"]::-webkit-color-swatch-wrapper {
  padding: 0 !important;
  border-radius: 50% !important;
}
input[type="color"]::-webkit-color-swatch {
  border: none !important;
  border-radius: 50% !important;
}

/* Firefox fix */
input[type="color"]::-moz-focus-inner {
  border: 0 !important;
  padding: 0 !important;
}
input[type="color"]::-moz-color-swatch {
  border: none !important;
  border-radius: 50% !important;
}
</style>

<style id="css-color-25px-force-dup2">
/* Final override: ensure true 25x25 circle, prevent flex stretching and logical-size overrides */
#right input[type="color"],
header input[type="color"],
[data-sec] input[type="color"],
input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;   /* override earlier inline-size:35px */
  block-size: 25px !important;    /* override earlier block-size:35px */
  aspect-ratio: 1 / 1 !important; /* enforce square box */
  display: inline-block !important; /* defeat inline-flex from uniform-height */
  line-height: normal !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
  vertical-align: middle !important;
}

/* WebKit */
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }

/* Firefox */
input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }
</style>

<style id="css-fillgrad-chip-fix-dup2">
/* Fix Fill -> Gradient stop rows after color-chip wrapping */
#fillGrad .grid-2 > .row {
  display: flex !important;
  flex-direction: row !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 6px !important;
  margin: 0 !important;
}

#fillGrad .grid-2 > .row label.small {
  min-width: 20px !important;
  margin-right: 4px !important;
}

#fillGrad .color-chip-25 {
  flex: 0 0 auto !important;
}

#fillGrad input[type="range"] {
  flex: 1 1 auto !important;
  max-width: 160px !important;
}
</style>

<style id="css-color-25px-authority-dup2">
header input[type="color"],
#right input[type="color"],
[data-sec] input[type="color"],
input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  display: inline-block !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
  vertical-align: middle !important;
}
header input[type="color"], #right input[type="color"] { align-self: center !important; }
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }
input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }
</style>

<style id="css-fillgrad-native-25-dup2">
/* Keep gradient stop color inputs native, but force perfect 25px circles */
#right .panel[data-sec="Fill"] #fillGrad input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  display: inline-block !important; /* Fixed: Ensure color inputs are visible */
  box-sizing: border-box !important;
  overflow: hidden !important;
}
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }
</style>

<style id="css-colorpicker-uniformheight-fix-and-slider-tighten-dup2">
/* 1) Remove global uniform-height effect ONLY for color pickers */
header input[type="color"],
#right input[type="color"],
[data-sec] input[type="color"],
input[type="color"] {
  height: 25px !important;
  min-height: 25px !important;
  line-height: 25px !important;
  padding: 0 !important;
  margin: 0 !important;
  display: inline-block !important;
  border: none !important;
  background: none !important;
  width: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
}

/* Keep internal swatch perfectly round */
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 50% !important; }
input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 50% !important; }
input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 50% !important; }

/* 2) Reduce slider widths to prevent overlapping boundaries */

/* Fill panel sliders */
#right .panel[data-sec="Fill"] #fillAlpha { width: 140px !important; max-width: 140px !important; }
#right .panel[data-sec="Fill"] #fillGrad input[type="range"] { width: 130px !important; max-width: 130px !important; }
#right .panel[data-sec="Fill"] #gAngle { width: 160px !important; max-width: 160px !important; }

/* Stroke panel sliders */
#right .panel[data-sec="Stroke"] #strokeW { width: 140px !important; max-width: 140px !important; }
#right .panel[data-sec="Stroke"] #strokeAlpha { width: 140px !important; max-width: 140px !important; }

/* Effects panel sliders */
#right .panel[data-sec="Effects"] #shAlpha { width: 140px !important; max-width: 140px !important; }
</style>

<style id="css-fillgrad-2x2-pure-dup2">
/* Make the gradient stops appear as two columns: (S1 S2) on first row, (S3 S4) on second */
#fillGrad .grid-2 {
  display: grid !important;
  grid-template-columns: repeat(2, minmax(160px, 1fr)) !important;
  gap: 10px 22px !important; /* row gap, column gap */
  justify-items: stretch !important;
  align-items: start !important;
}

/* Each stop row becomes a mini grid: 
   label on top across both columns, then color + slider below */
#fillGrad .grid-2 > .row {
  display: grid !important;
  grid-template-columns: auto 1fr !important;
  grid-template-areas:
    "lab lab"
    "col rng" !important;
  column-gap: 10px !important;
  row-gap: 6px !important;
  margin: 0 !important;
}

/* Place elements into areas */
#fillGrad .grid-2 > .row label.small { 
  grid-area: lab; 
  justify-self: start;
  opacity: 0.95 !important;
  margin: 0 !important;
}
#fillGrad .grid-2 > .row input[type="color"] { 
  grid-area: col; 
  width: 25px !important; height: 25px !important;
  inline-size: 25px !important; block-size: 25px !important;
  border-radius: 50% !important;
}
#fillGrad .grid-2 > .row input[type="range"] { 
  grid-area: rng; 
  width: 120px !important; max-width: 120px !important;
}

/* Hide any trailing span right after a range (end-of-slider text) inside Fill panel */
.panel[data-sec="Fill"] input[type="range"] + span { display: none !important; }
</style>

<style id="css-canvas-unit-custom-select">
/* Canvas Unit: custom responsive dropdown mirroring header .custom-select */
#canvasPanel .custom-select-unit {
  position: relative;
  display: inline-block;
  min-width: 90px;
  user-select: none;
  vertical-align: middle;
}

/* Visible selected area */
#canvasPanel .custom-select-unit .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  min-width: 90px;
  width: auto;
  max-width: 28vw;              /* clamp like the top bar */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Chevron */
#canvasPanel .custom-select-unit .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#canvasPanel .custom-select-unit .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;           /* grow to the longest item */
  max-width: 50vw;              /* clamp */
  max-height: 240px;
  overflow: auto;
}

#canvasPanel .custom-select-unit.open .options { display: block; }

#canvasPanel .custom-select-unit .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
}
#canvasPanel .custom-select-unit .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native select but keep behavior via JS sync */
#canvasPanel select#unit {
  display: none !important;
}
</style>

<style id="css-fill-mode-custom-select">
/* Fill -> Mode: custom responsive dropdown */
#right .panel[data-sec="Fill"] .custom-select-fill {
  position: relative;
  display: inline-block;
  min-width: 120px;
  user-select: none;
  vertical-align: middle;
}

#right .panel[data-sec="Fill"] .custom-select-fill .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  min-width: 120px;
  width: auto;
  max-width: 28vw;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#right .panel[data-sec="Fill"] .custom-select-fill .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

#right .panel[data-sec="Fill"] .custom-select-fill .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;
  max-width: 50vw;
  max-height: 240px;
  overflow: auto;
}

#right .panel[data-sec="Fill"] .custom-select-fill.open .options { display: block; }

#right .panel[data-sec="Fill"] .custom-select-fill .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
}
#right .panel[data-sec="Fill"] .custom-select-fill .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

#right .panel[data-sec="Fill"] select#fillMode {
  display: none !important;
}
</style>

<style id="css-canvas-unit-leftalign">
/* Force left alignment for Canvas -> Unit custom select */
#canvasPanel .custom-select-unit .selected {
  justify-content: flex-start !important;
  text-align: left !important;
  padding-left: 12px !important;
}
</style>

<style id="css-canvas-unit-leftalign-strong">
/* Reset inherited centering from #canvasPanel for the Unit custom select */
#canvasPanel .custom-select-unit,
#canvasPanel .custom-select-unit .selected,
#canvasPanel .custom-select-unit .options,
#canvasPanel .custom-select-unit .options li {
  text-align: left !important;
}

/* Keep content pinned to the left inside the selected chip */
#canvasPanel .custom-select-unit .selected {
  justify-content: flex-start !important;
  align-items: center !important;
}

/* Ensure list items occupy full row so text aligns left edge cleanly */
#canvasPanel .custom-select-unit .options li {
  display: block !important;
}
</style>

<style id="css-stroke-type-custom-select">
/* Stroke -> Type: custom responsive dropdown */
#right .panel[data-sec="Stroke"] .custom-select-stroke {
  position: relative;
  display: inline-block;
  min-width: 120px;
  user-select: none;
  vertical-align: middle;
  text-align: left; /* ensure left alignment in stroke panel */
}

/* Visible selected area */
#right .panel[data-sec="Stroke"] .custom-select-stroke .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start; /* left align content */
  min-width: 120px;
  width: auto;
  max-width: 28vw;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
}

/* Chevron */
#right .panel[data-sec="Stroke"] .custom-select-stroke .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#right .panel[data-sec="Stroke"] .custom-select-stroke .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;
  max-width: 50vw;
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Stroke"] .custom-select-stroke.open .options { display: block; }

#right .panel[data-sec="Stroke"] .custom-select-stroke .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Stroke"] .custom-select-stroke .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native strokeType select (mirrored via JS) */
#right .panel[data-sec="Stroke"] select#strokeType {
  display: none !important;
}
</style>

<style id="css-effects-blend-custom-select">
/* Effects -> Blend: custom responsive dropdown */
#right .panel[data-sec="Effects"] .custom-select-effects {
  position: relative;
  display: inline-block;
  min-width: 140px;
  user-select: none;
  vertical-align: middle;
  text-align: left; /* ensure left alignment */
}

/* Visible selected area */
#right .panel[data-sec="Effects"] .custom-select-effects .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start;    /* left align content */
  min-width: 140px;
  width: auto;
  max-width: 30vw;               /* clamp */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
}

/* Chevron */
#right .panel[data-sec="Effects"] .custom-select-effects .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#right .panel[data-sec="Effects"] .custom-select-effects .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;            /* grow to longest label */
  max-width: 50vw;               /* clamp */
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Effects"] .custom-select-effects.open .options { display: block; }

#right .panel[data-sec="Effects"] .custom-select-effects .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Effects"] .custom-select-effects .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native blend select (mirrored via JS) */
#right .panel[data-sec="Effects"] select#blendMode {
  display: none !important;
}
</style>

<style id="css-effects-filter-custom-select">
/* Effects -> Filter: custom responsive dropdown */
#right .panel[data-sec="Effects"] .custom-select-filter {
  position: relative;
  display: inline-block;
  min-width: 140px;
  user-select: none;
  vertical-align: middle;
  text-align: left;
}

/* Visible selected area */
#right .panel[data-sec="Effects"] .custom-select-filter .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start;   /* left align content */
  min-width: 140px;
  width: auto;
  max-width: 30vw;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
}

/* Chevron */
#right .panel[data-sec="Effects"] .custom-select-filter .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup list */
#right .panel[data-sec="Effects"] .custom-select-filter .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;
  max-width: 50vw;
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Effects"] .custom-select-filter.open .options { display: block; }

#right .panel[data-sec="Effects"] .custom-select-filter .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Effects"] .custom-select-filter .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native filter select (mirrored via JS) */
#right .panel[data-sec="Effects"] select#filterSel {
  display: none !important;
}
</style>

<style id="css-text-font-align-custom-selects">
/* Text panel: Font family custom dropdown */
#right .panel[data-sec="Text"] .custom-select-font,
#right .panel[data-sec="Text"] .custom-select-align {
  position: relative;
  display: inline-block;
  user-select: none;
  vertical-align: middle;
  text-align: left;
}

#right .panel[data-sec="Text"] .custom-select-font { min-width: 160px; }
#right .panel[data-sec="Text"] .custom-select-align { min-width: 100px; }

#right .panel[data-sec="Text"] .custom-select-font .selected,
#right .panel[data-sec="Text"] .custom-select-align .selected {
  background: #1f2937;
  border: 1px solid var(--muted);
  color: var(--text);
  border-radius: 10px;
  height: 35px;
  line-height: 35px;
  padding: 0 34px 0 12px;
  cursor: pointer;
  box-shadow: 0 1px 2px rgba(0,0,0,0.25);
  transition: border-color .2s ease, box-shadow .2s ease, background .2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: flex-start;  /* left align text */
  width: auto;
  max-width: 30vw;             /* responsive clamp */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#right .panel[data-sec="Text"] .custom-select-font .selected::after,
#right .panel[data-sec="Text"] .custom-select-align .selected::after {
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px; height: 16px;
  mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a3b3d1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>") no-repeat center / contain;
  background: #a3b3d1;
  opacity: .9;
  pointer-events: none;
}

/* Popup lists */
#right .panel[data-sec="Text"] .custom-select-font .options,
#right .panel[data-sec="Text"] .custom-select-align .options {
  position: absolute;
  left: 0; right: auto;
  top: calc(100% + 6px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  padding: 6px;
  list-style: none;
  margin: 0;
  display: none;
  z-index: 50;
  min-width: 100%;
  width: max-content;          /* expand to longest item */
  max-width: 50vw;             /* clamp */
  max-height: 240px;
  overflow: auto;
  text-align: left;
}

#right .panel[data-sec="Text"] .custom-select-font.open .options,
#right .panel[data-sec="Text"] .custom-select-align.open .options { display: block; }

#right .panel[data-sec="Text"] .custom-select-font .options li,
#right .panel[data-sec="Text"] .custom-select-align .options li {
  padding: 8px 10px;
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: background .15s ease, color .15s ease;
  white-space: nowrap;
  display: block;
  text-align: left;
}
#right .panel[data-sec="Text"] .custom-select-font .options li:hover,
#right .panel[data-sec="Text"] .custom-select-align .options li:hover {
  background: rgba(59,130,246,0.18);
  color: #e5f0ff;
}

/* Hide native selects (mirrored via JS) */
#right .panel[data-sec="Text"] select#fontFamily,
#right .panel[data-sec="Text"] select#textAlign {
  display: none !important;
}
</style>

/* Robust active class (non-destructive) for Show/Snap buttons */
#canvasPanel #gridShowBtn.active,
#canvasPanel #gridSnapBtn.active {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
}

<style id="css-uniform-height-system">
/* =========================================================
   UNIFORM CONTROL HEIGHT SYSTEM (global + per-section opts)
   ========================================================= */
:root{
  /* Global defaults (tweak anytime) */
  --ui-h: 34px;        /* default control height for all panels */
  --ui-gap: 8px;       /* default gap inside rows */
  --ui-chip: 25px;     /* circular color chip */
}

/* Base: apply only to right-side panels with a data-sec */
#right .panel[data-sec]{
  --panel-h: var(--ui-h);
  --panel-gap: var(--ui-gap);
}

/* Row layout is consistent, no wrap by default */
#right .panel[data-sec] .row{
  display:flex;
  align-items:center;
  gap:var(--panel-gap);
  flex-wrap:nowrap;
}

/* Uniform height for common controls */
#right .panel[data-sec] .row > label.small,
#right .panel[data-sec] .row > input:not([type="range"]):not([type="color"]):not([type="checkbox"]),
#right .panel[data-sec] .row > select,
#right .panel[data-sec] .row > button,
#right .panel[data-sec] .btn{
  height:var(--panel-h);
  min-height:var(--panel-h);
  line-height:var(--panel-h);
  box-sizing:border-box;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
}

/* Ranges: visually match row height (native UI kept) */
#right .panel[data-sec] input[type="range"]{
  height:var(--panel-h);
  min-height:var(--panel-h);
  box-sizing:border-box;
}

/* Checkboxes: compact and centered */
#right .panel[data-sec] input[type="checkbox"]{
  width:16px; height:16px;
  flex:0 0 auto;
}

/* Color pickers: always perfect circular chips (no stretching) */
#right .panel[data-sec] input[type="color"]{
  appearance:none; -webkit-appearance:none;
  width:var(--ui-chip); height:var(--ui-chip);
  inline-size:var(--ui-chip); block-size:var(--ui-chip);
  border-radius:50%;
  padding:0; margin:0; border:none;
  background:none;
  display:inline-block;
  box-sizing:border-box; overflow:hidden;
  vertical-align:middle;
}
#right .panel[data-sec] input[type="color"]::-webkit-color-swatch-wrapper{ padding:0; border-radius:50%; }
#right .panel[data-sec] input[type="color"]::-webkit-color-swatch{ border:none; border-radius:50%; }
#right .panel[data-sec] input[type="color"]::-moz-focus-inner{ border:0; padding:0; }
#right .panel[data-sec] input[type="color"]::-moz-color-swatch{ border:none; border-radius:50%; }

/* Textareas stay free-sized */
#right .panel[data-sec] textarea{
  min-height:100px; height:auto;
}

/* -----------------------------------------
   PER-SECTION OVERRIDES (just set --panel-h)
   ----------------------------------------- */
/* Example defaults (tweak/remove as you like) */
#right .panel[data-sec="Text"]      { --panel-h: 35px; }
#right .panel[data-sec="Stroke"]    { --panel-h: 32px; }
#right .panel[data-sec="Transform"] { --panel-h: 32px; }
#right .panel[data-sec="Canvas"]    { --panel-h: 34px; }
#right .panel[data-sec="Fill"]      { --panel-h: 34px; }
#right .panel[data-sec="Effects"]   { --panel-h: 32px; }
#right .panel[data-sec="Layers"]    { --panel-h: 32px; }

/* -----------------------------------------
   PER-ROW / PER-CONTROL UTILITIES
   ----------------------------------------- */
/* Apply to a panel, a row, or any wrapper to locally change height */
.h-28 { --panel-h:28px; }
.h-30 { --panel-h:30px; }
.h-32 { --panel-h:32px; }
.h-34 { --panel-h:34px; }
.h-35 { --panel-h:35px; }
.h-40 { --panel-h:40px; }

/* Opt-out on a specific row if needed */
.row.skip-uniform > *{
  height:auto !important;
  min-height:0 !important;
  line-height:normal !important;
}

/* Optional: tighter/looser gaps per row */
.gap-4 { --panel-gap:4px; }
.gap-6 { --panel-gap:6px; }
.gap-10{ --panel-gap:10px; }
</style>

<style id="css-uniform-height-tune">
/* --- Uniform Height Tune: keep button height & add identical row gaps --- */

/* 1) Restore global uniform control height to 35px */
:root { --ui-h: 35px !important; }

/* 2) Identical vertical spacing between rows in all right-panel sections */
:root { --row-gap: 8px; } /* tweak if you want tighter/looser */
#right .panel[data-sec] .pb > .row { margin-bottom: var(--row-gap) !important; }
#right .panel[data-sec] .pb > .row:last-child { margin-bottom: 0 !important; }

/* 3) Ensure ALL buttons inside panels (even outside .row) keep the uniform height */
#right .panel[data-sec] .btn,
#right .panel[data-sec] button {
  height: var(--ui-h) !important;
  min-height: var(--ui-h) !important;
  line-height: var(--ui-h) !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  white-space: nowrap !important;
}

/* 4) Optional per-section row-gap overrides (example) */
/* #right .panel[data-sec="Stroke"] { --row-gap: 10px; } */
</style>

<style id="css-uniform-height-fix-final">
/* === FINAL UNIFORM FIX: buttons 35px everywhere, no rogue margins/paddings === */

/* Global control height */
:root { --ui-h: 35px !important; --row-gap: 8px !important; }

/* Apply to ALL right-side panel controls */
#right .panel[data-sec] .row > *,
#right .panel[data-sec] .btn,
#right .panel[data-sec] button,
#right .panel[data-sec] select,
#right .panel[data-sec] input:not([type="color"]):not([type="checkbox"]):not([type="range"]),
#right .panel[data-sec] label.small {
  height: var(--ui-h) !important;
  min-height: var(--ui-h) !important;
  line-height: var(--ui-h) !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  margin: 0 !important;
  padding: 0 10px !important;
}

/* Range inputs align visually but keep native slider look */
#right .panel[data-sec] input[type="range"] {
  height: var(--ui-h) !important;
  min-height: var(--ui-h) !important;
  margin: 0 !important;
}

/* Checkboxes compact */
#right .panel[data-sec] input[type="checkbox"] {
  width: 16px !important;
  height: 16px !important;
  margin: 0 !important;
  padding: 0 !important;
}

/* Color inputs: fixed 25px circular */
#right .panel[data-sec] input[type="color"] {
  width: 25px !important;
  height: 25px !important;
  border-radius: 50% !important;
  margin: 0 !important;
  padding: 0 !important;
}

/* Canvas row order: removed custom ordering so DOM order prevails */
/* (Custom ordering removed to let the Apply row appear before the Size/Show/Snap row) */
/* #canvasApplyRow { order: 3 !important; } */
/* #canvasRow4     { order: 4 !important; } */

/* Stroke alignment row: space out Inside/Center/Outside buttons evenly */
#strokeAlignRow {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
}
#strokeAlignRow label.small {
  margin-right: 8px !important;
}
#strokeAlignGroup {
  display: flex !important;
  gap: 6px !important;
  flex: 1 1 auto !important;
}
#strokeAlignGroup .btn {
  flex: 1 1 auto !important;
}

/* Prevent borders on rows inside panel headers (to avoid blank boundaries) */
#right .panel .ph .row {
  border: none !important;
  padding: 0 !important;
  margin-bottom: 0 !important;
}

/* Fill gradient color stop rows: evenly distributed slider and color chip */
#fillGrad .grid-2 .row {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  border: 1px solid var(--muted) !important;
  border-radius: 6px !important;
  padding-left: 8px !important;
  padding-right: 8px !important;
  margin-bottom: var(--row-gap) !important;
}
#fillGrad .grid-2 .row:last-child {
  margin-bottom: 0 !important;
}
#fillGrad .grid-2 label.small {
  width: 24px !important;
  justify-content: flex-start !important;
}
#fillGrad .grid-2 input[type="range"] {
  flex: 1 1 auto !important;
}
#fillGrad .grid-2 input[type="color"] {
  margin-right: 8px !important;
}

/* Canvas panel rows should not display the decorative row border */
#right .panel[data-sec="Canvas"] .row,
/* Remove borders from Canvas action rows */
#canvasRow4,
#canvasApplyRow {
  border: none !important;
  box-shadow: none !important;
  padding-left: 0 !important;
  padding-right: 0 !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
}

/* Override original inline layout for Canvas control rows: stack vertically */
#canvasPanel .pb {
  text-align: left !important;
}
#canvasPanel .pb > #canvasApplyRow,
#canvasPanel .pb > #canvasRow4 {
  display: flex !important;
  justify-content: flex-start !important;
  width: 100% !important;
  margin: var(--row-gap) 0 !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
}

/* Row spacing: identical across all panels */
#right .panel[data-sec] .row {
  margin: 0 0 var(--row-gap) 0 !important;
  padding: 0 !important;
}
#right .panel[data-sec] .row:last-child {
  margin-bottom: 0 !important;
}

/* Remove any per-section padding overrides in .pb */
#right .panel[data-sec] .pb {
  padding: 6px 8px !important;
  margin: 0 !important;
}

/* Ensure Apply rows, BIU rows, etc. follow same spacing */
#right .panel[data-sec] [id*="Row"] {
  margin: 0 0 var(--row-gap) 0 !important;
  padding: 0 !important;
}
</style>

<style id="css-uniform-stretch-100">
/* ======================
   FINAL STRETCH + COLOR
   ====================== */

/* A) 35px uniform rule: explicitly exclude color inputs (keeps them round 25px) */
#right .panel[data-sec] .row > input:not([type="range"]):not([type="color"]):not([type="checkbox"]),
#right .panel[data-sec] .row > select,
#right .panel[data-sec] .row > button,
#right .panel[data-sec] .btn,
#right .panel[data-sec] button {
  height: var(--ui-h) !important;
  min-height: var(--ui-h) !important;
  line-height: var(--ui-h) !important;
}

/* B) Color inputs: fixed 25px round chips */
#right .panel[data-sec] input[type="color"] {
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  display: inline-block !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
}

/* C) 100% stretch system for all right-panel sections
   - Rows are flex and fill the panel width
   - Inputs/Selects/Buttons stretch; labels/checkboxes/color chips don't
   - If a row has only buttons, they auto share the width equally
*/
#right .panel[data-sec] .pb > .row {
  display: flex !important;
  align-items: center !important;
  gap: var(--row-gap, 8px) !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
}

/* Stretchable controls */
#right .panel[data-sec] .row > input:not([type="color"]):not([type="checkbox"]),
#right .panel[data-sec] .row > select,
#right .panel[data-sec] .row > button,
#right .panel[data-sec] .row > .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important; /* allow shrinking in tight space */
}

/* Ranges canvas get a bit more room */
#right .panel[data-sec] .row > input[type="range"] {
  flex: 2 1 0 !important;
}

/* Non-stretch items */
#right .panel[data-sec] .row > label.small,
#right .panel[data-sec] .row > input[type="checkbox"],
#right .panel[data-sec] .row > input[type="color"] {
  flex: 0 0 auto !important;
}

/* Rows that are button groups: split width evenly */
#right .panel[data-sec] .row:has(> .btn):not(.no-stretch) > .btn,
#right .panel[data-sec] .row:has(> button):not(.no-stretch) > button {
  flex: 1 1 0 !important;
}

/* Ensure Apply button rows and similar single-button rows expand full width */
#right .panel[data-sec] .row .btn.full,
#right .panel[data-sec] .row button.full {
  width: 100% !important;
  flex: 1 1 100% !important;
}

/* Canvas: enforce Apply button full-width in its container just in case */
#canvasPanel #applyCanvas {
  width: 100% !important;
  flex: 1 1 100% !important;
}

/* Safety: kill stray margins/paddings inside rows to keep clean spacing */
#right .panel[data-sec] .row > * {
  margin: 0 !important;
  /* keep existing paddings on inputs/selects/buttons;
     if any panel set extra padding, it will be visible, so we only normalize margins */
}
</style>

<style id="css-stretch-v2-and-color-fix">
/* =============================
   COLOR CHIP ABSOLUTE AUTHORITY
   ============================= */
/* Highest-specificity, panel-scoped color input fix */
#right .panel[data-sec] .row > input[type="color"],
#right .panel[data-sec] input[type="color"],
#right .panel[data-sec] .pb input[type="color"] {
  appearance: none !important;
  -webkit-appearance: none !important;
  width: 25px !important;
  height: 25px !important;
  inline-size: 25px !important;
  block-size: 25px !important;
  aspect-ratio: 1 / 1 !important;
  border-radius: 9999px !important;
  padding: 0 !important;
  margin: 0 !important;
  border: none !important;
  background: none !important;
  display: inline-block !important;
  box-sizing: border-box !important;
  overflow: hidden !important;
  vertical-align: middle !important;
}
#right .panel[data-sec] input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 9999px !important; }
#right .panel[data-sec] input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 9999px !important; }
#right .panel[data-sec] input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
#right .panel[data-sec] input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 9999px !important; }

/* ===================================
   FULL-WIDTH ROWS + BUTTON DISTRIBUTION
   =================================== */
/* Every row fills panel width */
#right .panel[data-sec] .pb > .row {
  display: flex !important;
  align-items: center !important;
  gap: var(--row-gap, 8px) !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
}

/* Stretchable: inputs, selects, and buttons.
   Opt-out: add .no-stretch to row OR to individual control. */
#right .panel[data-sec] .row > input:not([type="checkbox"]):not([type="color"]):not(.no-stretch),
#right .panel[data-sec] .row > select:not(.no-stretch),
#right .panel[data-sec] .row > button:not(.no-stretch),
#right .panel[data-sec] .row > .btn:not(.no-stretch) {
  flex: 1 1 0 !important;
  min-width: 0 !important;        /* allow to shrink */
  max-width: 100% !important;
  /* Neutralize legacy width constraints */
  width: auto !important;
  min-height: var(--ui-h) !important;
  line-height: var(--ui-h) !important;
}

/* Ranges get extra give */
#right .panel[data-sec] .row > input[type="range"] {
  flex: 2 1 0 !important;
}

/* Non-stretch items remain intrinsic */
#right .panel[data-sec] .row > label.small,
#right .panel[data-sec] .row > input[type="checkbox"],
#right .panel[data-sec] .row > input[type="color"] {
  flex: 0 0 auto !important;
}

/* Even distribution for 1–5 buttons in a row (any mixture of .btn/button) */
#right .panel[data-sec] .row:has(> button):not(.no-stretch) > button,
#right .panel[data-sec] .row:has(> .btn):not(.no-stretch) > .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important;
}

/* Kill legacy min-widths that break distribution */
#right .panel[data-sec] .row > button,
#right .panel[data-sec] .row > .btn {
  min-width: 0 !important;    /* overrides earlier min-width:72px, etc. */
  box-sizing: border-box !important;
  /* keep padding; width is controlled by flex */
}

/* Single full-width action helpers */
#right .panel[data-sec] .row .btn.full,
#right .panel[data-sec] .row button.full,
#canvasPanel #applyCanvas {
  width: 100% !important;
  flex: 1 1 100% !important;
}

/* Safety: remove stray margins from children so row gap controls spacing */
#right .panel[data-sec] .row > * {
  margin: 0 !important;
}
</style>

<style id="css-unblock-overrides">
/* ===============================
   UNBLOCK LEGACY WIDTH CONSTRAINTS
   =============================== */

/* Rows fill panel width uniformly */
#right .panel[data-sec] .pb > .row {
  display: flex !important;
  align-items: center !important;
  gap: var(--row-gap, 8px) !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
  margin: 0 0 var(--row-gap, 8px) 0 !important;
  padding: 0 !important;
}
#right .panel[data-sec] .pb > .row:last-child { margin-bottom: 0 !important; }

/* Color inputs: hard lock 25x25 round */
#right .panel[data-sec] input[type="color"] {
  appearance: none !important; -webkit-appearance: none !important;
  width: 25px !important; height: 25px !important;
  inline-size: 25px !important; block-size: 25px !important;
  aspect-ratio: 1 / 1 !important; border-radius: 9999px !important;
  padding: 0 !important; margin: 0 !important; border: none !important; background: none !important;
  display: inline-block !important; box-sizing: border-box !important; overflow: hidden !important;
}
#right .panel[data-sec] input[type="color"]::-webkit-color-swatch-wrapper { padding: 0 !important; border-radius: 9999px !important; }
#right .panel[data-sec] input[type="color"]::-webkit-color-swatch { border: none !important; border-radius: 9999px !important; }
#right .panel[data-sec] input[type="color"]::-moz-focus-inner { border: 0 !important; padding: 0 !important; }
#right .panel[data-sec] input[type="color"]::-moz-color-swatch { border: none !important; border-radius: 9999px !important; }

/* Stretch buttons evenly (1–5 per row) */
#right .panel[data-sec] .row > button,
#right .panel[data-sec] .row > .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  max-width: 100% !important;
  width: auto !important;
  height: var(--ui-h, 35px) !important;
  line-height: var(--ui-h, 35px) !important;
  box-sizing: border-box !important;
  margin: 0 !important;
}

/* Explicitly neutralize common legacy widths on special IDs */
#right .panel[data-sec] #transparentShapeBtn,
#right .panel[data-sec] [id^="apply"],
#right .panel[data-sec] [id*="Apply"],
#right .panel[data-sec] [id$="Btn"] {
  width: auto !important;
  min-width: 0 !important;
  max-width: 100% !important;
  flex: 1 1 0 !important;
}

/* Inputs/selects may stretch; labels/checkboxes/color stay intrinsic */
#right .panel[data-sec] .row > input:not([type="checkbox"]):not([type="color"]),
#right .panel[data-sec] .row > select {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  max-width: 100% !important;
  width: auto !important;
}
#right .panel[data-sec] .row > label.small,
#right .panel[data-sec] .row > input[type="checkbox"],
#right .panel[data-sec] .row > input[type="color"] {
  flex: 0 0 auto !important;
}

/* Ranges get a little extra room */
#right .panel[data-sec] .row > input[type="range"] {
  flex: 2 1 0 !important;
}

/* Opt-out flags */
#right .panel[data-sec] .row.no-stretch > *,
#right .panel[data-sec] .row > .no-stretch {
  flex: 0 0 auto !important;
  width: auto !important;
}

/* Full-width action helpers */
#right .panel[data-sec] .row .btn.full,
#right .panel[data-sec] .row button.full {
  flex: 1 1 100% !important;
  width: 100% !important;
}

/* Safety: remove stray margins from children so only row gap applies */
#right .panel[data-sec] .row > * { margin: 0 !important; }
</style>

<style id="css-stretch-v4-fixes">
/* ======================
   GLOBAL FIXES V4
   ====================== */

/* Stroke + Text: force row justify to normal (not centered), allow full stretch */
#right .panel[data-sec="Stroke"] .row,
#right .panel[data-sec="Text"] .row {
  justify-content: flex-start !important;
}

/* Buttons in Stroke + Text stretch across row */
#right .panel[data-sec="Stroke"] .row > button,
#right .panel[data-sec="Stroke"] .row > .btn,
#right .panel[data-sec="Text"] .row > button,
#right .panel[data-sec="Text"] .row > .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  max-width: 100% !important;
  width: auto !important;
}

/* Canvas: collapse vertical gap between Apply and Show/Snap rows */
#canvasPanel #canvasApplyRow {
  margin:0 !important;  /* tighten spacing */
}
#canvasPanel #rowShowSnap,
#canvasPanel #canvasRow4 {
  margin-top: 4px !important;     /* reduce top spacing */
}

/* Global label-to-button gap: 3px */
#right .panel[data-sec] .row {
  gap: 3px !important;
}
</style>

<style id="css-fixes-v5">
/* ============ GLOBAL GAP: label ↔ button = 3px ============ */
#right .panel[data-sec] .row { gap: 3px !important; }

/* ============ STROKE + TEXT: stop centering, stretch buttons ============ */
#right .panel[data-sec="Stroke"] .row,
#right .panel[data-sec="Text"] .row {
  justify-content: flex-start !important;
  width: 100% !important;
}

/* Stretch ANY button groups inside Stroke/Text (1–5 buttons) */
#right .panel[data-sec="Stroke"] .row > .btn,
#right .panel[data-sec="Stroke"] .row > button,
#right .panel[data-sec="Text"] .row > .btn,
#right .panel[data-sec="Text"] .row > button {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  width: auto !important;
}

/* Also target legacy wrappers used in Text panel */
#right .panel[data-sec="Text"] #textStyleRow,
#right .panel[data-sec="Text"] #textRowLineBIU {
  display: flex !important;
  align-items: center !important;
  justify-content: flex-start !important;
  width: 100% !important;
  gap: 3px !important;
}
#right .panel[data-sec="Text"] #textStyleRow > .btn,
#right .panel[data-sec="Text"] #textRowLineBIU > .btn,
#right .panel[data-sec="Text"] #textRowLineBIU > button {
  flex: 1 1 0 !important;
  min-width: 0 !important;
}

/* Kill historical min-widths that block flex growth */
#right .panel[data-sec="Stroke"] .row > .btn,
#right .panel[data-sec="Text"] .row > .btn {
  min-width: 0 !important;
}

/* ============ CANVAS: collapse vertical gap between Apply and Show/Snap ============ */
#canvasPanel #canvasApplyRow { margin:0 !important; padding: 0 !important; }
#canvasPanel #rowShowSnap, 
#canvasPanel #canvasRow4,
#canvasPanel .pb > div:has(#gridShow),
#canvasPanel .pb > div:has(#gridSnap) {
  margin: 2px 0 !important; padding: 0 !important;
}

/* If any rule forces larger spacing on first/last rows, neutralize */
#canvasPanel .pb > *:first-child { margin-top: 0 !important; }
#canvasPanel .pb > *:last-child { margin-bottom: 0 !important; }

/* Ensure Apply button is truly full width */
#canvasPanel #applyCanvas { flex: 1 1 100% !important; width: 100% !important; min-width: 0 !important; }

/* ============ FILL: color pickers must be 25x25 round, no extra spacing ============ */
#right .panel[data-sec="Fill"] input[type="color"] {
  appearance: none !important; -webkit-appearance: none !important;
  width: 25px !important; height: 25px !important;
  inline-size: 25px !important; block-size: 25px !important;
  border-radius: 50% !important; aspect-ratio: 1 / 1 !important;
  padding: 0 !important; margin: 0 !important; border: none !important; background: none !important;
  display: inline-block !important; box-sizing: border-box !important; overflow: hidden !important;
  vertical-align: middle !important;
}
#right .panel[data-sec="Fill"] input[type="color"]::-webkit-color-swatch-wrapper{ padding:0 !important; border-radius:50% !important; }
#right .panel[data-sec="Fill"] input[type="color"]::-webkit-color-swatch{ border:none !important; border-radius:50% !important; }
#right .panel[data-sec="Fill"] input[type="color"]::-moz-focus-inner{ border:0 !important; padding:0 !important; }
#right .panel[data-sec="Fill"] input[type="color"]::-moz-color-swatch{ border:none !important; border-radius:50% !important; }

/* ============ COLLAPSE HEADER SEAM (remove tiny gaps) ============ */
/* Tighten the seam under headers globally */
#right .panel .ph { margin: 0 !important; padding-bottom: 6px !important; }
#right .panel .pb { padding-top: 6px !important; }
/* Layers-specific polish (if it looked gappy) */
#right .panel[data-sec="Layers"] .ph { padding-bottom: 4px !important; }
#right .panel[data-sec="Layers"] .pb { padding-top: 4px !important; }
</style>

<style id="css-v6-ultimate">
/* ===== ULTIMATE OVERRIDES (last in cascade) ===== */

/* 0) Global tiny tune */
:root { --ui-h: 35px !important; --row-gap: 8px !important; }

/* 1) Row model across all right-panel sections */
#right .panel .pb > .row,
#right .panel .pb > div.row,
#right .panel .pb > #textStyleRow,
#right .panel .pb > #textRowLineBIU,
#right .panel .pb > #strokeAlignRow {
  display: flex !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 3px !important; /* label-button gap */
  flex-wrap: nowrap !important;
  width: 100% !important;
  margin: 0 0 var(--row-gap) 0 !important;
  padding: 0 !important;
}
#right .panel .pb > .row:last-child,
#right .panel .pb > div.row:last-child { margin-bottom: 0 !important; }

/* 2) Stretch behavior */
#right .panel .row > button,
#right .panel .row > .btn,
#right .panel .row > select,
#right .panel .row > input:not([type="checkbox"]):not([type="color"]) {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  width: auto !important;
  max-width: 100% !important;
  height: var(--ui-h) !important;
  line-height: var(--ui-h) !important;
}
#right .panel .row > input[type="range"] { flex: 2 1 0 !important; }

/* 3) Non-stretch items */
#right .panel .row > label.small,
#right .panel .row > input[type="checkbox"],
#right .panel .row > input[type="color"] {
  flex: 0 0 auto !important;
}

/* 4) Kill legacy min/max widths that stop stretching */
#right .panel .row > .btn,
#right .panel .row > button {
  min-width: 0 !important;
  max-width: 100% !important;
  width: auto !important;
}

/* 5) Specific panels that were centered: Stroke & Text */
#right .panel[data-sec="Stroke"] .row,
#right .panel[data-sec="Text"] .row,
#right .panel[data-sec="Text"] #textStyleRow,
#right .panel[data-sec="Text"] #textRowLineBIU {
  justify-content: flex-start !important;
}

/* 6) Canvas seam (Apply vs Show/Snap) */
#canvasPanel #canvasApplyRow { margin:0 !important; padding: 0 !important; }
#canvasPanel #rowShowSnap, 
#canvasPanel #canvasRow4,
#canvasPanel .pb > div:has(#gridShow),
#canvasPanel .pb > div:has(#gridSnap) {
  margin: 2px 0 !important; padding: 0 !important;
}

/* 7) Color inputs: absolute round 25x25 */
#right .panel input[type="color"] {
  appearance: none !important; -webkit-appearance: none !important;
  width: 25px !important; height: 25px !important;
  inline-size: 25px !important; block-size: 25px !important;
  border-radius: 9999px !important; aspect-ratio: 1 / 1 !important;
  padding: 0 !important; margin: 0 !important; border: none !important;
  background: none !important; display: inline-block !important;
  box-sizing: border-box !important; overflow: hidden !important;
  vertical-align: middle !important;
}
#right .panel input[type="color"]::-webkit-color-swatch-wrapper{ padding:0 !important; border-radius:9999px !important; }
#right .panel input[type="color"]::-webkit-color-swatch{ border:none !important; border-radius:9999px !important; }
#right .panel input[type="color"]::-moz-focus-inner{ border:0 !important; padding:0 !important; }
#right .panel input[type="color"]::-moz-color-swatch{ border:none !important; border-radius:9999px !important; }

/* 8) Collapse header seam fix */
#right .panel .ph { margin: 0 !important; padding-bottom: 6px !important; }
#right .panel .pb { padding-top: 6px !important; }

/* 9) Safety: zero margins on children inside rows */
#right .panel .row > * { margin: 0 !important; }
</style>

<style id="css-collapse-gap-fix-global">
/* === CLEAN COLLAPSE MENU HEADERS (GLOBAL) === */

/* remove outside spacing so panels touch */
#right .panel {
  margin: 0 !important;
  border: 0 !important;
}

/* fix 1px gap between stacked panels */
#right .panel + .panel {
  margin-top: -1px !important;
}

/* clean header look */
#right .panel .ph {
  margin: 0 !important;
  padding: 10px 12px;
  border-radius: 8px;                  
  border-bottom: 1px solid #2c325d;    
  background-clip: padding-box;
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease;
}

/* hover effect */
#right .panel .ph:hover {
  background: #2e335f;                 
  color: #ffffff;
}

/* active/open section header */
#right .panel.active .ph {
  background: #3a417a;                 
  font-weight: 600;
  color: #fff;
  border-bottom: none !important;      
  border-radius: 8px 8px 0 0;          
}

/* active/open section body */
#right .panel.active .pb {
  border-radius: 0 0 8px 8px;          
  overflow: hidden;                    
  background: #1e223d;                 /* subtle dark background */
  padding: 10px;                       
  box-shadow: 0 4px 12px rgba(0,0,0,0.35); /* soft shadow lift */
}

/* remove bottom line on last panel if closed */
#right .panel:last-of-type .ph {
  border-bottom: 0 !important;
}
</style>

<style id="css-collapse-gap-fix-global-v2">
/* === FINAL: GAPLESS HEADERS (conflict-proof) === */

/* 0) Base: ensure right column doesn't introduce column gaps */
#right { row-gap: 0 !important; column-gap: 0 !important; }

/* 1) Remove any spacing/borders that canvas create seams */
#right > .panel {
  margin: 0 !important;
  padding: 0 !important;
  border: 0 !important;
  box-shadow: none !important;
}

/* 2) Collapse the vertical seam completely */
#right > .panel + .panel { margin-top: -1px !important; }

/* 3) Normalize header visuals and kill stray outlines */
#right > .panel > .ph {
  margin: 0 !important;
  padding: 10px 12px !important;
  background: transparent !important;
  border-radius: 8px !important;
  border-bottom: 1px solid #2c325d !important;
  outline: none !important;
  box-shadow: none !important;
  -webkit-tap-highlight-color: transparent;
  background-clip: padding-box !important;
}

/* Remove any focus rings that look like blue pills */
#right > .panel > .ph:focus,
#right > .panel > .ph:focus-visible,
#right > .panel > .ph:active {
  outline: none !important;
  box-shadow: none !important;
}

/* 4) Hover and active states (consistent) */
#right > .panel > .ph:hover {
  background: #2e335f !important;
  color: #fff !important;
}

#right > .panel.active > .ph {
  background: #3a417a !important;
  color: #fff !important;
  font-weight: 600;
  border-bottom: none !important;
  border-radius: 8px 8px 0 0 !important;
}

/* 5) Active body forms a single card with soft shadow */
#right > .panel.active > .pb {
  padding: 10px !important;
  background: #1e223d !important;
  border-radius: 0 0 8px 8px !important;
  overflow: hidden !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.35) !important;
}

/* 6) Last header’s divider hidden when closed */
#right > .panel:last-of-type > .ph { border-bottom: 0 !important; }
</style>

<style id="css-collapse-gap-fix-global-v3">
/* === FINAL ROUND EDGE + GAPLESS HEADERS === */

/* Reset any unwanted spacing */
#right { row-gap: 0 !important; column-gap: 0 !important; }
#right > .panel { margin: 0 !important; padding: 0 !important; border: 0 !important; }

/* Remove seam but keep headers independent */
#right > .panel + .panel { margin-top: 0 !important; }

/* All headers styled cleanly */
#right > .panel > .ph {
  margin: 0 !important;
  padding: 10px 12px !important;
  border-radius: 8px !important;           /* always round */
  border: 1px solid #2c325d !important;    /* subtle frame */
  background: #1d223c !important;
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease;
  position: relative;
  z-index: 1;                              /* layer on top so overlap hides seams */
}

/* kill double-borders between stacked panels */
#right > .panel + .panel > .ph { margin-top: -1px !important; }

/* hover state */
#right > .panel > .ph:hover {
  background: #2e335f !important;
  color: #fff !important;
}

/* active header */
#right > .panel.active > .ph {
  background: #3a417a !important;
  color: #fff !important;
  font-weight: 600;
  border-radius: 8px 8px 0 0 !important;
}

/* active body as card */
#right > .panel.active > .pb {
  background: #1e223d !important;
  padding: 10px !important;
  border-radius: 0 0 8px 8px !important;
  overflow: hidden !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.35) !important;
  border: 1px solid #2c325d !important;
  border-top: none !important;
}

/* First panel keeps top rounding */
#right > .panel:first-of-type > .ph { border-radius: 8px 8px 0 0 !important; }

/* Last panel keeps bottom rounding */
#right > .panel:last-of-type > .ph { border-radius: 0 0 8px 8px !important; }
</style>

<style id="unbind-effects-text-override">
/* Neutralize earlier surgical rules so Effects/Text behave like others */
#right .panel[data-sec="Effects"] .ph { 
  border-bottom: 1px solid #2c325d !important; 
}
#right .panel[data-sec="Text"] { 
  margin-top: 0 !important; 
}
</style>

<style id="css-collapse-gap-fix-global-v5">
/* === OUTER-HEADER BIND + BODY FALLBACK (handles panels without .pb) === */

/* Remove container gaps */
#right { row-gap: 0 !important; column-gap: 0 !important; }
#right > .panel { margin: 0 !important; padding: 0 !important; border: 0 !important; }

/* Each panel header (only the outer one) */
#right > .panel > .ph {
  margin: 0 !important;
  padding: 10px 12px !important;
  border-radius: 8px !important;
  border: 1px solid #2c325d !important;
  background: #1d223c !important;
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease;
  position: relative;
  z-index: 1;
}

/* Kill double seam between panels */
#right > .panel + .panel > .ph { margin-top: -1px !important; }

/* Hover and active */
#right > .panel > .ph:hover { background: #2e335f !important; color: #fff !important; }
#right > .panel.active > .ph {
  background: #3a417a !important; color: #fff !important; font-weight: 600;
  border-radius: 8px 8px 0 0 !important; border-bottom: none !important;
}

/* BODY: use .pb if present, otherwise the first element after .ph */
#right > .panel.active > .pb,
#right > .panel.active > .ph + * {
  background: #1e223d !important;
  padding: 10px !important;
  border: 1px solid #2c325d !important;
  border-top: none !important;
  border-radius: 0 0 8px 8px !important;
  overflow: hidden !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.35) !important;
}

/* Ensure nested .ph inside the body don't adopt outer header rounding */
#right > .panel > :not(.ph) .ph {
  border-radius: 6px !important;
  border: 1px solid transparent !important;
  background: transparent !important;
  color: inherit !important;
  box-shadow: none !important;
}

/* First/Last panel corner hints */
#right > .panel:first-of-type > .ph { border-radius: 8px 8px 0 0 !important; }
#right > .panel:last-of-type > .ph { border-radius: 0 0 8px 8px !important; }
</style>

<style id="css-canvas-apply-match-layers">
/* Make Apply button look identical to Bring/Send */
#canvasPanel #applyCanvas {
  height: 35px !important;
  min-height: 35px !important;
  line-height: 35px !important;
  padding: 0 12px !important;
  box-sizing: border-box !important;
  background: #1f2937 !important;
  border: 1px solid var(--muted) !important;
  border-radius: 6px !important;
  color: var(--text) !important;
  transition: background .2s ease, border-color .2s ease, color .2s ease;
}
#canvasPanel #applyCanvas:hover {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
  color: #fff !important;
}
</style>
<style id="css-ui-polish-aug2025">
/* === Consolidated polish: accessibility, motion, hover === */

/* Accessible focus for all interactive controls */
button.btn:focus-visible,
header button:focus-visible,
input:focus-visible,
select:focus-visible,
textarea:focus-visible,
#left .tool:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25);
}

/* Left tool tiles: clearer hover/active states */
#left .tool {
  transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
}
#left .tool:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(0,0,0,.35);
}
#left .tool.active {
  box-shadow: 0 0 0 1px rgba(59,130,246,0.45) inset, 0 8px 22px rgba(59,130,246,.25);
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  * {
    animation: none !important;
    transition: none !important;
    scroll-behavior: auto !important;
  }
}

/* Improve clickable area for tiny controls in headers/panels */
header .row > *,
#right .panel .ph > * {
  min-height: 35px;
}
</style>

<style id="css-topbar-label-align">
/* Surgical patch — align top bar labels vertically center at 35px */
header .row label.small,
header .row span.muted,
header .row strong,
header .row button,
header .row input:not([type="color"]),
header .row select {
  display: inline-flex !important;
  align-items: center !important;
  height: 35px !important;
  line-height: 35px !important;
}

/* Keep label text snug without extra offsets */
header .row label.small,
header .row span.muted {
  padding: 0 4px;
  margin: 0;
}
</style>
</head><body><img id="p" src="${url}">

`);
  doc.close();
  const img=doc.getElementById('p');
  img.onload=()=>{ iframe.contentWindow.focus(); iframe.contentWindow.print(); setTimeout(()=>document.body.removeChild(iframe), 2000); };
}

function renderCanvasToDataURL(fmt,q){
  const c=document.createElement('canvas'); c.width=state.canvasW; c.height=state.canvasH; const x=c.getContext('2d');
  if(state.canvasBG.mode==='solid'){x.fillStyle=rgbaCss(state.canvasBG.color); x.fillRect(0,0,c.width,c.height);} 
  else if(state.canvasBG.mode==='gradient'){const a=rad(state.canvasBG.gradient.angle||0),dx=Math.cos(a)*c.width/2,dy=Math.sin(a)*c.height/2; const g=x.createLinearGradient(c.width/2-dx,c.height/2-dy,c.width/2+dx,c.height/2+dy); state.canvasBG.gradient.stops.forEach(s=>g.addColorStop(s.pos,rgbaCss(s.c))); x.fillStyle=g; x.fillRect(0,0,c.width,c.height);} 
  state.layers.forEach(L=>{
    if(!L.visible) return;
    x.save(); x.translate(L.x+L.w/2,L.y+L.h/2); x.rotate(rad(L.rot||0));
    x.globalCompositeOperation=L.blend||'source-over';
    const sh=L.sh||{x:0,y:0,blur:0,color:{r:0,g:0,b:0,a:0}}; x.shadowOffsetX=sh.x||0; x.shadowOffsetY=sh.y||0; x.shadowBlur=sh.blur||0; x.shadowColor=rgbaCss(sh.color||{r:0,g:0,b:0,a:0}); x.filter=L.filters||'none';
    const setFill=()=>{ if(L.fillMode==='none'){x.fillStyle='rgba(0,0,0,0)'; return;} if(L.fillMode==='solid'){x.fillStyle=rgbaCss(L.solidFill); return;} const a=rad(L.gradientFill.angle||0),dx=Math.cos(a)*L.w/2,dy=Math.sin(a)*L.h/2; const g=x.createLinearGradient(-dx,-dy,dx,dy); L.gradientFill.stops.forEach(s=>g.addColorStop(s.pos,rgbaCss(s.c))); x.fillStyle=g; };
    const setStroke=()=>{ if(!L.strokeEnable||L.strokeW<=0||L.strokeType==='none'){x.strokeStyle='rgba(0,0,0,0)'; return;} if(L.strokeType==='gradient'){const a=rad(L.gradientFill.angle||0),dx=Math.cos(a)*L.w/2,dy=Math.sin(a)*L.h/2; const g=x.createLinearGradient(-dx,-dy,dx,dy); L.gradientFill.stops.forEach(s=>g.addColorStop(s.pos,rgbaCss(s.c))); x.strokeStyle=g;} else x.strokeStyle=rgbaCss(L.strokeSolid); x.lineWidth=L.strokeW; x.setLineDash(L.strokeDash>0?[L.strokeDash,L.strokeDash]:[]); };
    if(L.type==='image'){const im=document.createElement('img'); im.src=L.src; x.drawImage(im,-L.w/2,-L.h/2,L.w,L.h);} 
    else if(L.type==='line'){ setStroke(); x.beginPath(); x.moveTo(-L.w/2,-L.h/2); x.lineTo(L.w/2,L.h/2); x.stroke(); } 
    else if(L.type==='ellipse'){ setFill(); if(L.fillMode!=='none'){ x.beginPath(); x.ellipse(0,0,Math.abs(L.w/2),Math.abs(L.h/2),0,0,Math.PI*2); x.fill(); } setStroke(); x.beginPath(); x.ellipse(0,0,Math.abs(L.w/2),Math.abs(L.h/2),0,0,Math.PI*2); x.stroke(); } 
    else if(L.type==='roundrect'){ 
      // Use the layer's per-corner radii when rendering to an off-screen canvas.
      const radius = L.corners || L.cornerRadius || 12;
      setFill();
      if(L.fillMode!=='none'){
        roundRectPath(x,L.w,L.h,radius);
        x.fill();
      }
      setStroke();
      roundRectPath(x,L.w,L.h,radius);
      x.stroke(); 
    } 
    else if(L.type==='rect'){ setFill(); if(L.fillMode!=='none') x.fillRect(-L.w/2,-L.h/2,L.w,L.h); setStroke(); x.strokeRect(-L.w/2,-L.h/2,L.w,L.h); } 
    else if(L.type==='text'){ const t=L; if(t.fillMode==='gradient'){const a=rad(t.gradientFill.angle||0),dx=Math.cos(a)*t.w/2,dy=Math.sin(a)*t.h/2; const g=x.createLinearGradient(-dx,-dy,dx,dy); t.gradientFill.stops.forEach(s=>g.addColorStop(s.pos,rgbaCss(s.c))); x.fillStyle=g;} else if(t.fillMode==='solid'){x.fillStyle=rgbaCss(t.solidFill||{r:0,g:0,b:0,a:1});} else x.fillStyle='rgba(0,0,0,0)'; x.textBaseline='top'; x.font=`${t.italic?'italic':''} ${t.bold?700:400} ${t.fontSize||28}px ${t.fontFamily||'system-ui, Arial'}`; drawWrappedTextWithUnderline(x,t);} 
    x.restore();
  });
  return c.toDataURL(fmt, fmt==='image/png'?undefined:q);
}

/* ==== save/load/clear/autosave ==== */
function snapshot(){return {canvasW:state.canvasW,canvasH:state.canvasH,canvasBG:state.canvasBG,layers:state.layers};}

d('openProj').onclick=()=>d('projInput').click();
d('projInput').addEventListener('change',e=>{
  const f=e.target.files?.[0]; if(!f) return; const r=new FileReader();
  r.onload=()=>{try{const obj=JSON.parse(r.result); Object.assign(state,obj);
    state.imgCache.clear(); state.layers.forEach(L=>{ if(L.type==='image'&&L.src){ const im=new Image(); im.onload=()=>{state.imgCache.set(L.src,im); drawAll();}; im.src=L.src; }});
    pushHist(); refreshLayers(); centerView(); drawAll();
  }catch(err){ alert('Invalid project file'); }};
  r.readAsText(f); e.target.value='';
});


setInterval(()=>{try{localStorage.setItem('cdp_autosave',JSON.stringify(snapshot()));}catch{}},2000);
(function loadAutosave(){try{const s=localStorage.getItem('cdp_autosave'); if(s){const obj=JSON.parse(s); Object.assign(state,obj); state.imgCache.clear(); state.layers.forEach(L=>{ if(L.type==='image'&&L.src){ const im=new Image(); im.onload=()=>{state.imgCache.set(L.src,im); drawAll();}; im.src=L.src; }}); }}catch{} })();

/* ==== boot ==== */
function boot(){ resizeStage(); centerView(); toggleFillUI(); refreshLayers(); pushHist(); drawAll(); }
function toggleFillUI(){
  const m = d('fillMode').value;
  // Display solid and gradient rows based on mode; use !important to override other CSS
  var solidRow = d('fillSolid');
  var gradRow = d('fillGrad');
  if (solidRow) solidRow.style.setProperty('display', (m === 'solid') ? 'flex' : 'none', 'important');
  if (gradRow) gradRow.style.setProperty('display', (m === 'gradient') ? 'block' : 'none', 'important');
  // Show the angle controls (label + slider) only for gradient fills
  var wrap = d('gAngleWrap');
  if (wrap) wrap.style.setProperty('display', (m === 'gradient') ? 'flex' : 'none', 'important');
}
boot();
});
</script>

<script>
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll("#right .panel .ph").forEach(function(header) {
    header.addEventListener("click", function() {
      const panel = header.closest(".panel");
      panel.classList.toggle("collapsed");
    });
  });
});
</script>

<script id="js-toggle-wire-20250829">
(function(){
  // Generic helper: bind a button to a checkbox or boolean state input
  function bindToggle(btnSel, inputSel, {activeClass='active', pressedAttr=true, click=true}={}){
    var btn = typeof btnSel === 'string' ? document.querySelector(btnSel) : btnSel;
    var input = typeof inputSel === 'string' ? document.querySelector(inputSel) : inputSel;
    if(!btn || !input) return;
    // initial sync
    var setUI = function(checked){
      if(activeClass){ btn.classList.toggle(activeClass, !!checked); }
      if(pressedAttr){ btn.setAttribute('aria-pressed', !!checked); }
    };
    setUI(input.checked !== undefined ? input.checked : !!input.value);
    // click wiring
    if(click){
      btn.addEventListener('click', function(e){
        e.preventDefault();
        if('checked' in input){
          input.checked = !input.checked;
        } else {
          input.value = !input.value ? 1 : 0;
        }
        setUI('checked' in input ? input.checked : !!input.value);
        input.dispatchEvent(new Event('change', {bubbles:true}));
        input.dispatchEvent(new Event('input', {bubbles:true}));
      });
      // keyboard a11y
      btn.setAttribute('role','button');
      btn.tabIndex = btn.tabIndex || 0;
      btn.addEventListener('keydown', function(e){
        if(e.key === ' ' || e.key === 'Enter'){ e.preventDefault(); btn.click(); }
      });
    }
    // reflect external changes
    ['change','input'].forEach(ev => input.addEventListener(ev, function(){
      setUI('checked' in input ? input.checked : !!input.value);
    }));
  }

  // Canvas Grid: show/snap
  bindToggle('#gridShowBtn', '#gridShow', {activeClass:'active'});
  bindToggle('#gridSnapBtn', '#gridSnap', {activeClass:'active'});

  // Text panel: Bold / Italic / Underline
  // Support both #boldBtn style (button) and [data-style] buttons
  function findAndBind(style){
    var input = document.querySelector('#right .panel[data-sec="Text"] input#'+style);
    // Prefer explicit button id, else data-style attr
    var btn = document.querySelector('#right .panel[data-sec="Text"] button#'+style+'Btn') ||
              document.querySelector('#right .panel[data-sec="Text"] .btn[data-style="'+style+'"]') ||
              document.querySelector('#right .panel[data-sec="Text"] .'+style);
    if(btn && input){
      bindToggle(btn, input, {activeClass:'active'});
      // Also toggle selection styles if app maintains current object
      btn.addEventListener('click', function(){
        document.dispatchEvent(new CustomEvent('textStyleToggle', {detail:{style}}));
      });
    }
  }
  ['bold','italic','underline'].forEach(findAndBind);

  // Defensive: if checkboxes are hidden via CSS, that's fine; we only sync state.
  // No-op if elements aren't present.
})();
</script>

<!-- Re-added: font custom-select builder from reference -->
<script id="js-text-font-align-custom-selects">
(function(){
  function ready(fn){ if(document.readyState!=='loading'){ fn(); } else { document.addEventListener('DOMContentLoaded', fn); }}

  function enhanceSelect(nativeId, customId, className){
    var sel = document.getElementById(nativeId);
    if(!sel || sel.dataset.enhanced === "1") return;

    var wrap = document.createElement('div');
    wrap.className = 'custom-select ' + className;
    wrap.id = customId;
    var selected = document.createElement('div');
    selected.className = 'selected';
    selected.textContent = '—';
    var list = document.createElement('ul');
    list.className = 'options';
    wrap.appendChild(selected);
    wrap.appendChild(list);
    sel.insertAdjacentElement('afterend', wrap);

    Array.from(sel.options).forEach(function(opt){
      var li = document.createElement('li');
      li.textContent = opt.textContent || opt.value;
      li.dataset.value = opt.value;
      li.style.fontFamily = (nativeId === 'fontFamily' ? opt.value + ', system-ui, sans-serif' : '');
      li.addEventListener('click', function(){
        sel.value = li.dataset.value;
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        selected.textContent = li.textContent;
        wrap.classList.remove('open');
      });
      list.appendChild(li);
    });

    function syncFromNative(){
      var opt = sel.options[sel.selectedIndex];
      if(opt){
        selected.textContent = opt.textContent || opt.value;
        if(nativeId === 'fontFamily'){
          selected.style.fontFamily = opt.value + ', system-ui, sans-serif';
        }
      }
    }

    selected.addEventListener('click', function(e){
      wrap.classList.toggle('open');
    });
    document.addEventListener('click', function(e){
      if(!wrap.contains(e.target)) wrap.classList.remove('open');
    });

    sel.addEventListener('change', syncFromNative);
    syncFromNative();
    sel.dataset.enhanced = "1";
  }

  ready(function(){
    enhanceSelect('fontFamily', 'fontFamilyCustom', 'custom-select-font');
    enhanceSelect('textAlign',  'textAlignCustom',  'custom-select-align');
  });
})();
</script>

<script id="js-text-align-custom-select-init">
(function () {
  const scope = document.querySelector('#right .panel[data-sec="Text"]');
  if (!scope) return;

  const native = scope.querySelector('select#textAlign');
  if (!native) return;

  // Avoid double init
  if (scope.querySelector('.custom-select-align')) {
    // If it exists but not wired, ensure click wiring
    const wrap = scope.querySelector('.custom-select-align');
    const selected = wrap.querySelector('.selected');
    const list = wrap.querySelector('.options');
    if (!selected || !list || list.childElementCount === 0) {
      wrap.innerHTML = '';
      build();
    } else {
      wire(wrap, selected, list, native);
    }
    return;
  }

  build();

  function build(){
    const wrap = document.createElement('div');
    wrap.className = 'custom-select-align';

    const selected = document.createElement('div');
    selected.className = 'selected';
    selected.textContent = native.options[native.selectedIndex]?.text || '';

    const list = document.createElement('ul');
    list.className = 'options';

    Array.from(native.options).forEach(opt => {
      const li = document.createElement('li');
      li.textContent = opt.text;
      li.dataset.value = opt.value;
      if (opt.selected) li.setAttribute('aria-selected', 'true');
      li.addEventListener('click', () => {
        native.value = opt.value;
        native.dispatchEvent(new Event('change', { bubbles: true }));
        selected.textContent = opt.text;
        wrap.classList.remove('open');
        Array.from(list.children).forEach(x => x.removeAttribute('aria-selected'));
        li.setAttribute('aria-selected', 'true');
      });
      list.appendChild(li);
    });

    wrap.appendChild(selected);
    wrap.appendChild(list);

    // Insert right after native select
    native.parentNode.insertBefore(wrap, native.nextSibling);

    wire(wrap, selected, list, native);
  }

  function wire(wrap, selected, list, native){
    // Ensure native hidden
    native.style.display = 'none';

    selected.addEventListener('click', function(e){
      e.stopPropagation();
      wrap.classList.toggle('open');
    });

    // Close on outside click
    document.addEventListener('click', function(){
      wrap.classList.remove('open');
    });

    // Close on ESC
    document.addEventListener('keydown', function(e){
      if (e.key === 'Escape') wrap.classList.remove('open');
    });
  }
})();
</script>

<script id="js-text-align-dedupe">
(function(){
  const scope = document.querySelector('#right .panel[data-sec="Text"]');
  if (!scope) return;
  const native = scope.querySelector('#textRowSizeAlign select#textAlign');
  if (!native) return;

  // Remove all existing custom selects except one fresh instance
  const customs = scope.querySelectorAll('.custom-select-align');
  customs.forEach(el => el.remove());

  // Build a single instance
  const wrap = document.createElement('div');
  wrap.className = 'custom-select-align';

  const selected = document.createElement('div');
  selected.className = 'selected';
  selected.textContent = native.options[native.selectedIndex]?.text || '';

  const list = document.createElement('ul');
  list.className = 'options';

  Array.from(native.options).forEach(opt => {
    const li = document.createElement('li');
    li.textContent = opt.text;
    li.dataset.value = opt.value;
    if (opt.selected) li.setAttribute('aria-selected', 'true');
    li.addEventListener('click', () => {
      native.value = opt.value;
      native.dispatchEvent(new Event('change', { bubbles: true }));
      selected.textContent = opt.text;
      wrap.classList.remove('open');
      Array.from(list.children).forEach(x => x.removeAttribute('aria-selected'));
      li.setAttribute('aria-selected', 'true');
    });
    list.appendChild(li);
  });

  wrap.appendChild(selected);
  wrap.appendChild(list);
  native.parentNode.insertBefore(wrap, native.nextSibling);

  // Hide native hard
  native.style.display = 'none';
  native.style.visibility = 'hidden';
  native.style.width = '0';
  native.style.height = '0';
  native.style.position = 'absolute';
  native.style.left = '-99999px';

  // wiring
  selected.addEventListener('click', function(e){
    e.stopPropagation();
    wrap.classList.toggle('open');
  });
  document.addEventListener('click', function(){ wrap.classList.remove('open'); });
  document.addEventListener('keydown', function(e){ if (e.key === 'Escape') wrap.classList.remove('open'); });
})();
</script>

<script id="js-text-align-remove-native">
(function(){
  const scope = document.querySelector('#right .panel[data-sec="Text"]');
  if (!scope) return;
  const native = scope.querySelector('#textRowSizeAlign select#textAlign');
  if (!native) return;

  // Remove any pre-existing custom selects
  scope.querySelectorAll('.custom-select-align').forEach(el => el.remove());

  // Build a single custom select
  const wrap = document.createElement('div');
  wrap.className = 'custom-select-align';

  const selected = document.createElement('div');
  selected.className = 'selected';
  selected.textContent = native.options[native.selectedIndex]?.text || '';

  const list = document.createElement('ul');
  list.className = 'options';

  Array.from(native.options).forEach(opt => {
    const li = document.createElement('li');
    li.textContent = opt.text;
    li.dataset.value = opt.value;
    if (opt.selected) li.setAttribute('aria-selected', 'true');
    li.addEventListener('click', () => {
      selected.textContent = opt.text;
      wrap.classList.remove('open');
      Array.from(list.children).forEach(x => x.removeAttribute('aria-selected'));
      li.setAttribute('aria-selected', 'true');
    });
    list.appendChild(li);
  });

  wrap.appendChild(selected);
  wrap.appendChild(list);
  native.parentNode.insertBefore(wrap, native.nextSibling);

  // Remove the native select entirely from DOM
  native.remove();

  // wiring
  selected.addEventListener('click', function(e){
    e.stopPropagation();
    wrap.classList.toggle('open');
  });
  document.addEventListener('click', function(){ wrap.classList.remove('open'); });
  document.addEventListener('keydown', function(e){ if (e.key === 'Escape') wrap.classList.remove('open'); });
})();
</script>



<script id="patch-text-sync">
(function(){
  // Prevent duplicate installation
  if (window.__TEXT_PANEL_PATCH_APPLIED_V2__) return;
  window.__TEXT_PANEL_PATCH_APPLIED_V2__ = true;

  function getCanvas(){
    try{
      if (window.fabric) {
        if (window.__canvas) return window.__canvas;
        if (window.canvas) return window.canvas;
      }
      // try helpers if app exposes them
      if (typeof window.getCanvas === 'function') return window.getCanvas();
      var el = document.getElementById('canvas');
      if (el && el.fabricCanvas) return el.fabricCanvas;
    }catch(e){}
    return null;
  }

  function getActiveTextObject(c){
    try{
      var obj = c && c.getActiveObject && c.getActiveObject();
      if (!obj) return null;
      var t = (obj.type||'').toLowerCase();
      if (t === 'textbox' || t === 'i-text' || t === 'text') return obj;
    }catch(e){}
    return null;
  }

  function $(id){ return document.getElementById(id); }

  var ta = $('textValue');
  if (!ta) return;

  // State
  var state = {
    isTyping: false,
    commitTimer: null,
    lastMirroredFromSelection: null,
    lastCommittedToObject: null
  };

  // Helper: write textarea from selection if safe
  function ensureTextareaShowsCurrent(){
    var c = getCanvas();
    var obj = getActiveTextObject(c);
    if (!obj) return;

    var current = (obj.text != null ? String(obj.text) : '');
    // If user is typing, don't overwrite mid-typing
    if (state.isTyping) return;

    if (ta.value !== current) {
      ta.value = current;
      state.lastMirroredFromSelection = current;
    }
  }

  function commitToObject(){
    clearTimeout(state.commitTimer);
    state.commitTimer = null;
    var c = getCanvas();
    var obj = getActiveTextObject(c);
    if (!obj) return;

    var val = ta.value;
    if (val === state.lastCommittedToObject && val === (obj.text||'')) return;

    try{
      obj.text = val;
      state.lastCommittedToObject = val;
      if (typeof obj.set === 'function') obj.set('dirty', true);
      if (c && typeof c.requestRenderAll === 'function') c.requestRenderAll();
      else if (c && typeof c.renderAll === 'function') c.renderAll();
    }catch(e){}
  }

  // Input handling with debounce
  ta.addEventListener('input', function(){
    state.isTyping = true;
    ta.dataset.userDirty = "1";
    clearTimeout(state.commitTimer);
    state.commitTimer = setTimeout(commitToObject, 150);
  }, { passive: true });

  ta.addEventListener('focus', function(){
    // When the user clicks into the text panel, immediately mirror current selection
    state.isTyping = false; // allow mirror to populate if empty/wrong
    ensureTextareaShowsCurrent();
    // Place caret at end for convenience
    try{
      var len = ta.value.length;
      ta.setSelectionRange(len, len);
    }catch(e){}
  });

  ta.addEventListener('mousedown', function(){
    // Make sure a click that focuses also mirrors latest selection
    setTimeout(ensureTextareaShowsCurrent, 0);
  });

  ta.addEventListener('blur', function(){
    if (ta.dataset.userDirty === "1") commitToObject();
    state.isTyping = false;
    ta.dataset.userDirty = "";
  });

  // Mirror on selection/scene changes
  function mirrorFromSelection(){
    if (state.isTyping) return;
    ensureTextareaShowsCurrent();
  }

  function bindCanvasEvents(){
    var c = getCanvas();
    if (!c || !c.on || c.__textPanelPatchedV2) return;
    c.__textPanelPatchedV2 = true;

    var refresh = mirrorFromSelection;
    c.on('selection:created', refresh);
    c.on('selection:updated', refresh);
    c.on('selection:cleared', function(){
      // Don't blank user's textarea; just stop syncing until another text selected
      // (optional) could set a placeholder here
    });
    c.on('object:added', refresh);
    c.on('object:modified', refresh);
    c.on('mouse:up', function(){ setTimeout(refresh, 0); });
  }

  // Also listen for panel header clicks (if collapsing/expanding)
  document.addEventListener('click', function(e){
    var ph = e.target.closest && e.target.closest('#right .panel[data-sec="Text"] .ph');
    if (ph) setTimeout(mirrorFromSelection, 0);
  }, true);

  // Initialize / retry binding until canvas ready
  var attempts = 80;
  (function wait(){
    bindCanvasEvents();
    // Also attempt an initial sync in case a text object is already selected
    mirrorFromSelection();
    if (--attempts > 0) setTimeout(wait, 120);
  })();

  // Debug
  window.__textPanelPatchV2 = {
    ensureTextareaShowsCurrent: ensureTextareaShowsCurrent,
    commit: commitToObject,
    state: state
  };
})();
</script>



<script id="patch-text-sync-v3">
(function(){
  if (window.__TEXT_PANEL_PATCH_APPLIED_V3__) return;
  window.__TEXT_PANEL_PATCH_APPLIED_V3__ = true;

  function $id(id){ return document.getElementById(id); }
  var ta = $id('textValue');
  if (!ta) return;

  function getFabricCanvas(){
    // 1) Known globals
    if (window.canvas && typeof window.canvas.getActiveObject === 'function') return window.canvas;
    if (window.fabricCanvas && typeof window.fabricCanvas.getActiveObject === 'function') return window.fabricCanvas;
    if (window.editor && window.editor.canvas && typeof window.editor.canvas.getActiveObject === 'function') return window.editor.canvas;
    // 2) Query all upper-canvas elements and return the first with __canvas
    var ups = document.querySelectorAll('.upper-canvas, canvas.upper-canvas, #c, #canvas');
    for (var i=0;i<ups.length;i++){
      var el = ups[i];
      if (el && el.__canvas && typeof el.__canvas.getActiveObject === 'function') return el.__canvas;
      if (el && el.fabricCanvas && typeof el.fabricCanvas.getActiveObject === 'function') return el.fabricCanvas;
    }
    return null;
  }

  function getActiveText(c){
    try {
      var o = c && c.getActiveObject && c.getActiveObject();
      if (!o) return null;
      var t = (o.type||'').toLowerCase();
      if (t === 'textbox' || t === 'i-text' || t === 'text') return o;
    } catch(e){}
    return null;
  }

  var state = { isTyping:false, lastText:null, commitTimer:null };

  function mirror(){
    if (state.isTyping) return;
    var c = getFabricCanvas();
    var o = getActiveText(c);
    if (!o) return;
    var cur = (o.text!=null? String(o.text):"");
    if (ta.value !== cur){
      ta.value = cur;
      state.lastText = cur;
    }
  }

  function commit(){
    clearTimeout(state.commitTimer);
    state.commitTimer = null;
    var c = getFabricCanvas();
    var o = getActiveText(c);
    if (!o) return;
    var v = ta.value;
    if (v === o.text) return;
    try {
      o.text = v;
      if (typeof o.set === 'function') o.set('dirty', true);
      if (c && typeof c.requestRenderAll === 'function') c.requestRenderAll();
      else if (c && typeof c.renderAll === 'function') c.renderAll();
    } catch(e){}
  }

  // Events
  ta.addEventListener('focus', function(){ state.isTyping = false; mirror(); });
  ta.addEventListener('mousedown', function(){ setTimeout(mirror, 0); });
  ta.addEventListener('input', function(){ state.isTyping = true; clearTimeout(state.commitTimer); state.commitTimer=setTimeout(commit, 120); });
  ta.addEventListener('blur', function(){ commit(); state.isTyping=false; });

  // Fallback polling to catch any missed selection changes
  var poll = setInterval(function(){
    if (!document.body.contains(ta)) { clearInterval(poll); return; }
    if (document.activeElement === ta) return; // don't stomp while focused
    mirror();
  }, 200);

  // One immediate sync if a text is already selected
  setTimeout(mirror, 0);
})();
</script>


<!-- Surgical patch 2025-08-29 15:02:05 IST: Restore text editing + BIU checkbox wiring -->
<script>
(function() {
  const $ = (id) => document.getElementById(id);

  // Ensure we have a textarea for editing text
  function ensureTextArea() {
    let ta = $('textValue');
    if (!ta) {
      // Try to insert into Text panel body
      const panel = document.querySelector('#right .panel[data-sec="Text"] .pb') || document.body;
      const wrap = document.createElement('div');
      wrap.className = 'row';
      ta = document.createElement('textarea');
      ta.id = 'textValue';
      ta.placeholder = 'Type text…';
      ta.style.width = '100%';
      ta.style.minHeight = '100px';
      wrap.appendChild(ta);
      panel.prepend(wrap);
    }
    ta.removeAttribute('readonly');
    ta.disabled = false;
    return ta;
  }

  const ta = ensureTextArea();
  const bold = $('bold');
  const italic = $('italic');
  const underline = $('underline');

  // Target the currently selected text layer (DOM element) or model.
  let currentTarget = null;
  let rerender = null;

  function isHTMLElement(obj) { return obj && obj.nodeType === 1; }

  function readTextFromTarget() {
    if (!currentTarget) return '';
    if (isHTMLElement(currentTarget)) return currentTarget.textContent || currentTarget.innerText || '';
    if (currentTarget && typeof currentTarget.text === 'string') return currentTarget.text;
    return '';
  }

  function writeTextToTarget(text) {
    if (!currentTarget) return;
    if (isHTMLElement(currentTarget)) currentTarget.textContent = text;
    else currentTarget.text = text;
    if (typeof rerender === 'function') try { rerender(); } catch(_){}
  }

  function applyStylesToTarget() {
    if (!currentTarget) return;
    const b = !!(bold && bold.checked);
    const i = !!(italic && italic.checked);
    const u = !!(underline && underline.checked);
    if (isHTMLElement(currentTarget)) {
      currentTarget.style.fontWeight = b ? '700' : '400';
      currentTarget.style.fontStyle = i ? 'italic' : 'normal';
      currentTarget.style.textDecoration = u ? 'underline' : 'none';
    } else {
      currentTarget.bold = b; currentTarget.italic = i; currentTarget.underline = u;
    }
    if (typeof rerender === 'function') try { rerender(); } catch(_){}
  }

  // Keep textarea preview styles in sync with the checkboxes
  function applyStylesToTextarea() {
    if (!ta) return;
    ta.style.fontWeight = bold && bold.checked ? '700' : '400';
    ta.style.fontStyle = italic && italic.checked ? 'italic' : 'normal';
    ta.style.textDecoration = underline && underline.checked ? 'underline' : 'none';
  }

  // Events: typing updates target
  if (ta) {
    ta.addEventListener('input', () => writeTextToTarget(ta.value));
  }
  // Events: BIU checkbox changes update target + textarea preview
  [bold, italic, underline].forEach(el => el && el.addEventListener('change', () => {
    applyStylesToTarget();
    applyStylesToTextarea();
  }));

  // Public API to integrate with your selection logic
  window.TextEdit = {
    attach(target, requestRender) {
      currentTarget = target || null;
      rerender = typeof requestRender === 'function' ? requestRender : null;
      // Load the target's text into textarea
      if (ta) ta.value = readTextFromTarget();
      // Apply checkbox styles to the textarea for preview
      applyStylesToTextarea();
      return currentTarget;
    },
    currentTarget() { return currentTarget; }
  };

  // Initial apply for textarea preview
  applyStylesToTextarea();
})();
</script>


  <!-- Final Canvas layout fix inserted at very end of body to override all previous styles -->
  <style id="css-canvas-final-fix-end-20250830">
    /* Ensure Canvas panel rows appear in this order: width/dpi, height/unit, Apply, size+show/snap */
    #canvasPanel .pb {
      /* Force Canvas panel rows to stack vertically.  Use flex column so each row occupies its own line. */
      display: flex !important;
      flex-direction: column !important;
      align-items: stretch !important;
      text-align: left !important;
      white-space: normal !important;
    }
    /* Display Apply and Size rows as full‑width flex rows */
    #canvasPanel .pb > #canvasApplyRow,
    #canvasPanel .pb > #canvasRow4 {
      display: flex !important;
      align-items: center !important;
      width: 100% !important;
      flex-wrap: nowrap !important;
      gap: 8px !important;
      margin: var(--row-gap) 0 !important;
      padding: 0 !important;
    }
    /* Center the Apply button row horizontally */
    #canvasPanel .pb > #canvasApplyRow {
      justify-content: center !important;
    }

    /* -------------------- Fill panel gradient final override -------------------- */
    /* Constrain the width of gradient stop sliders and ensure the grid layout places
       S1/S2 on the first row and S3/S4 on the second. Also lay out each stop's
       controls horizontally (label, colour picker, slider) to avoid wrapping. */
    #right .panel[data-sec="Fill"] #fillGrad input[type="range"] {
      width: 100% !important;
      max-width: 100px !important;
    }
    #right .panel[data-sec="Fill"] #fillGrad .grid-2 {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 8px 16px !important;
    }
    #right .panel[data-sec="Fill"] #fillGrad .grid-2 > .row {
      display: flex !important;
      flex-direction: row !important;
      align-items: center !important;
      gap: 6px !important;
      margin: 0 !important;
    }

    /* --------------- Color picker global override --------------- */
    /* Ensure every colour input inside the right-hand panels appears as a perfect circle.
       Some earlier styles may set only the height or width; this override makes both
       dimensions equal and applies a full border-radius. */
    #right input[type="color"] {
      appearance: none !important;
      -webkit-appearance: none !important;
      /* Reduce colour picker size to 20px so the buttons remain compact */
      width: 20px !important;
      height: 20px !important;
      inline-size: 20px !important;
      block-size: 20px !important;
      border-radius: 50% !important;
      padding: 0 !important;
      margin: 0 !important;
      border: none !important;
      background: none !important;
      display: inline-block !important;
      box-sizing: border-box !important;
      overflow: hidden !important;
    }
    #right input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0 !important;
      border-radius: 50% !important;
    }
    #right input[type="color"]::-webkit-color-swatch {
      border: none !important;
      border-radius: 50% !important;
    }
    #right input[type="color"]::-moz-focus-inner {
      border: 0 !important;
      padding: 0 !important;
    }
    #right input[type="color"]::-moz-color-swatch {
      border: none !important;
      border-radius: 50% !important;
    }

    /* --------------- Collapsible panel header adjustments --------------- */
    /* Reduce the height of each panel header (ph) by decreasing vertical padding and center the
       header text horizontally. This gives a more compact, polished appearance. */
    #right .panel .ph {
      /* Further reduce vertical padding for an even slimmer header */
      padding: 1px 8px !important;
      min-height: 20px !important;
      /* Left‑align header content and center it vertically */
      justify-content: flex-start !important;
      align-items: center !important;
      text-align: left !important;
      /* Add smooth transition for hover state (matching left toolbar tiles) */
      transition: transform .15s ease, box-shadow .15s ease;
    }
    #right .panel .ph strong {
      flex: 0 0 auto !important;
      margin: 0 !important;
    }
    /* Custom hover effect similar to the left toolbar: lift slightly and cast a shadow */
    #right .panel .ph:hover {
      background: rgba(107, 114, 128, 0.15) !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35) !important;
      color: inherit !important;
    }

    /* Reduce the vertical gap between panels to tighten the collapsed menu list */
    #right .panel {
      margin-bottom: 6px !important;
    }
    /* Left-align the Size/Show/Snap row */
    #canvasPanel .pb > #canvasRow4 {
      justify-content: flex-start !important;
    }

    /* Center the Apply button itself within its row using absolute positioning */
    #canvasPanel #applyCanvas {
      position: relative !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
    }
    /* Make Apply button fill row */
    #canvasPanel #canvasApplyRow > #applyCanvas {
      flex: 1 1 auto !important;
      width: 100% !important;
      justify-content: center !important;
    }
    /* Remove all order overrides so DOM order defines the flow */
    #canvasApplyRow,
    #canvasRow4 {
      order: 0 !important;
    }

    /* Align inputs/labels to the left for tight rows (Width/DPI and Height/Unit) */
    #canvasPanel .row-tight-2 {
      justify-content: flex-start !important;
    }
  </style>

<script>
function $(id){ return document.getElementById(id); }

if(typeof state === "undefined"){
  var state = { layers: [], selection: [], canvasW: 800, canvasH: 600, canvasBG: "#ffffff", imgCache: new Map() };
}

var canvas = document.getElementById('canvas');
var ctx = canvas?.getContext('2d');

// --- CDP OPEN ---
function openCdpFile(file){
  const reader = new FileReader();
  reader.onload = e => {
    try{
      const data = JSON.parse(e.target.result);
      if(data){
        Object.assign(state, data);
        if(typeof refreshLayers === "function") refreshLayers();
        if(typeof drawAll === "function") drawAll();
        alert("File loaded successfully!");
      }else{
        alert("Invalid CDP file format.");
      }
    }catch(err){
      alert("Failed to parse CDP file.");
      console.error(err);
    }
  };
  reader.readAsText(file);
}

// --- CDP SAVE ---
function saveCdpFile(){
  const snapshot = {
    canvasW: state.canvasW,
    canvasH: state.canvasH,
    canvasBG: state.canvasBG,
    layers: state.layers
  };
  const data = JSON.stringify(snapshot, null, 2);
  const blob = new Blob([data],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'design.cdp';
  a.click();
  URL.revokeObjectURL(url);
}

// --- EXPORT ---
function exportCanvas(fmt){
  if(!canvas) return;
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = state.canvasW;
  exportCanvas.height = state.canvasH;
  const ectx = exportCanvas.getContext('2d');
  ectx.drawImage(canvas, 0, 0, state.canvasW, state.canvasH);
  const dataURL = exportCanvas.toDataURL('image/'+fmt);
  const a = document.createElement('a');
  a.href = dataURL;
  a.download = 'design.'+fmt;
  a.click();
}

// --- PRINT ---
function printCanvas(){
  if(!canvas) return;
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = state.canvasW;
  exportCanvas.height = state.canvasH;
  const ectx = exportCanvas.getContext('2d');
  ectx.drawImage(canvas, 0, 0, state.canvasW, state.canvasH);
  const dataURL = exportCanvas.toDataURL('image/png');
  const win = window.open();
  win.document.write('<img src="'+dataURL+'" style="max-width:100%;height:auto;" onload="window.print();window.close()"/>');
}

// --- CLEAR ---
function clearAllLayers(){
  if(!canvas || !ctx) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  state.layers = [];
  state.selection = [];
  if(typeof refreshLayers === "function") refreshLayers();
  if(typeof drawAll === "function") drawAll();
}

// --- EVENT BINDINGS ---
document.addEventListener("DOMContentLoaded", ()=>{
  $("openProj")?.addEventListener("click", ()=> $("projInput")?.click());
  $("projInput")?.addEventListener("change", e=>{
    const f=e.target.files[0];
    if(f) openCdpFile(f);
    e.target.value="";
  });
  $("saveProj")?.addEventListener("click", saveCdpFile);
  $("exportImg")?.addEventListener("click", ()=>{
    const fmt = $("fmt")?.value || "image/png";
    exportCanvas(fmt.includes("jpeg") ? "jpeg" : fmt.includes("webp") ? "webp" : "png");
  });
  $("printBtn")?.addEventListener("click", printCanvas);
  $("clearAll")?.addEventListener("click", clearAllLayers);
});

// --- DELETE KEY ---
document.addEventListener("keydown", e => {
  if (e.key === "Delete" || e.key === "Backspace") {
    if (state.selection && state.selection.length > 0) {
      state.layers = state.layers.filter(l => !state.selection.includes(l));
      state.selection = [];
      if (typeof refreshLayers === "function") refreshLayers();
      if (typeof drawAll === "function") drawAll();
    }
  }
});
</script>

</body>
</html>
<!-- TEXT-EDIT-AUTO-ENABLE -->
<script>
(function(){
  try {
    var contentInput = document.getElementById('textContent');
    if (!contentInput) return;

    function resolveCanvas() {
      return (window.canvas || window.fabricCanvas || (window.editor && window.editor.canvas)) ||
        (function(){ try { return (document.querySelector('.upper-canvas')||{}).__canvas; } catch(e){ return null; } })();
    }

    function syncTextFieldWithSelection() {
      var c = resolveCanvas();
      if (!c || !c.getActiveObject) return;
      var obj = c.getActiveObject && c.getActiveObject();
      var t = obj && String(obj.type||'').toLowerCase();
      var isText = t === 'textbox' || t === 'text' || t === 'itext';

      if (isText) {
        contentInput.readOnly = false;
        var txt = (typeof obj.text === 'string') ? obj.text : '';
        if (contentInput.value !== txt) contentInput.value = txt;
        try { if (typeof obj.__origText === 'undefined') obj.__origText = obj.text; } catch(e){}
      } else {
        contentInput.readOnly = true;
        if (contentInput.value !== '') contentInput.value = '';
      }
    }

    (function waitAndWire(attempts){
      var c = resolveCanvas();
      if (!c || !c.on) {
        if ((attempts||40) > 0) return setTimeout(function(){ waitAndWire((attempts||40)-1); }, 150);
        return;
      }

      var refresh = syncTextFieldWithSelection;
      c.on('selection:created', refresh);
      c.on('selection:updated', refresh);
      c.on('selection:cleared', refresh);
      c.on('object:added', refresh);
      c.on('object:modified', refresh);
      // initial sync
      refresh();
    })();
  } catch (e) {
    // swallow errors to avoid breaking other UI
    console && console.warn && console.warn('TEXT-EDIT-AUTO-ENABLE failed:', e);
  }
})();
</script>
<script>
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll("#right .panel .ph").forEach(function(header) {
    header.addEventListener("click", function() {
      const panel = header.closest(".panel");
      panel.classList.toggle("collapsed");
    });
  });
});
</script>
<script>
(function(){
  function togglePanel(panel){
    if(!panel) return;
    panel.classList.toggle('collapsed');
    var header = panel.querySelector('.ph');
    if(header){
      var expanded = !panel.classList.contains('collapsed');
      header.setAttribute('aria-expanded', String(expanded));
    }
  }

  function setupHeaders(){
    var right = document.getElementById('right');
    if(!right) return;
    var panels = right.querySelectorAll('.panel');

    panels.forEach(function(panel){
      var ph = panel.querySelector('.ph');
      var pb = panel.querySelector('.pb');
      if(!ph) return;
      // Make header focusable & accessible
      ph.setAttribute('role', 'button');
      ph.setAttribute('tabindex', '0');
      ph.setAttribute('aria-expanded', String(!panel.classList.contains('collapsed')));

      // Click to toggle
      ph.addEventListener('click', function(e){
        // Only toggle when clicking within the header area
        togglePanel(panel);
      });

      // Keyboard support
      ph.addEventListener('keydown', function(e){
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          togglePanel(panel);
        }
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupHeaders);
  } else {
    setupHeaders();
  }
})();
</script>
<script>
(function(){
  function togglePanel(panel){
    if(!panel) return;
    var pb = panel.querySelector('.pb');
    var header = panel.querySelector('.ph');
    var nowCollapsed = !panel.classList.toggle('collapsed'); // classList.toggle returns true if class is now present
    // We want collapsed = panel.classList.contains('collapsed')
    var collapsed = panel.classList.contains('collapsed');
    if(pb){
      if(collapsed){
        pb.style.display = 'none';
        pb.style.maxHeight = '0px';
        pb.style.opacity = '0';
      } else {
        pb.style.display = 'block';
        pb.style.maxHeight = '';
        pb.style.opacity = '';
      }
    }
    if(header){
      header.setAttribute('aria-expanded', String(!collapsed));
    }
  }

  function normalizePanel(panel){
    var pb = panel.querySelector('.pb');
    var header = panel.querySelector('.ph');
    if(pb){
      if(panel.classList.contains('collapsed')){
        pb.style.display = 'none';
        pb.style.maxHeight = '0px';
        pb.style.opacity = '0';
      }else{
        pb.style.display = 'block';
        pb.style.maxHeight = '';
        pb.style.opacity = '';
      }
    }
    if(header){
      header.setAttribute('role', 'button');
      header.setAttribute('tabindex', '0');
      header.setAttribute('aria-expanded', String(!panel.classList.contains('collapsed')));
    }
  }

  function setupHeaders(){
    var right = document.getElementById('right');
    if(!right) return;
    var panels = right.querySelectorAll('.panel');
    panels.forEach(function(panel){
      normalizePanel(panel);
      var ph = panel.querySelector('.ph');
      if(!ph) return;
      // Remove existing click handlers attached inline (if any) by cloning
      var newPh = ph.cloneNode(true);
      ph.parentNode.replaceChild(newPh, ph);
      // Attach handlers
      newPh.addEventListener('click', function(e){ togglePanel(panel); });
      newPh.addEventListener('keydown', function(e){
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          togglePanel(panel);
        }
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupHeaders);
  } else {
    setupHeaders();
  }
})();


// ===== Header Button Functions (Clean Fixed) =====

// Save project (.cdp)
function saveProject() {
  const data = JSON.stringify({
    canvasW: state.canvasW,
    canvasH: state.canvasH,
    canvasBG: state.canvasBG,
    layers: state.layers
  }, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'project.cdp';
  a.click();
}

// Open project (.cdp)
d('openProj').onclick = () => d('projInput').click();
d('projInput').addEventListener('change', e => {
  const f = e.target.files && e.target.files[0]; if (!f) return;
  const r = new FileReader();
  r.onload = () => {
    try {
      const obj = JSON.parse(r.result);
      if (obj.canvas && (obj.canvas.width || obj.canvas.height)) {
        state.canvasW = obj.canvas.width || state.canvasW;
        state.canvasH = obj.canvas.height || state.canvasH;
      } else {
        state.canvasW = obj.canvasW || state.canvasW;
        state.canvasH = obj.canvasH || state.canvasH;
      }
      state.canvasBG = obj.canvasBG || state.canvasBG;
      state.layers = Array.isArray(obj.layers) ? obj.layers : [];
      try { state.imgCache.clear(); } catch(e) { state.imgCache = new Map(); }
      state.layers.forEach(L => {
        if (L.type === 'image' && L.src) {
          const im = new Image();
          im.onload = () => { state.imgCache.set(L.src, im); drawAll(); };
          im.src = L.src;
        }
      });
      state.selection = [];
      pushHist && pushHist();
      refreshLayers && refreshLayers();
      centerView && centerView();
      drawAll();
    } catch (err) {
      console.error('Open failed', err);
      alert('Invalid project file');
    }
  };
  r.readAsText(f);
  e.target.value = '';
});

// Export image (exact canvas size)
function exportImage() {
  const fmt = d('fmt').value;
  const q = parseFloat(d('quality').value) || 1;
  const url = renderCanvasToDataURL(fmt, q);
  const a = document.createElement('a');
  const ext = fmt === 'image/png' ? 'png' : (fmt === 'image/jpeg' ? 'jpg' : 'webp');
  a.href = url;
  a.download = 'canvas.' + ext;
  a.click();
}

// Print exact canvas size
d('printBtn').onclick = () => { printCanvasOnly(); };
function printCanvasOnly() {
  const url = renderCanvasToDataURL('image/png', 1);
  const w = window.open('', '_blank');
  const W = state.canvasW, H = state.canvasH;
  const html = `<!DOCTYPE html><html><head><meta charset="utf-8">
  <style>
    @page { size: ${W}px ${H}px; margin: 0; }
    html, body { margin:0; padding:0; }
    img { width:${W}px; height:${H}px; display:block; }
  </style></head><body>
  <img src="${url}" alt="canvas"/>
  <script>window.onload=function(){ setTimeout(function(){ window.print(); }, 50); }<\/script>
  </body></html>`;
  w.document.open(); w.document.write(html); w.document.close();
}

// Clear all layers (keeps canvas visible with background)
d('clearAll').onclick = () => {
  if (!confirm('Clear all layers?')) return;
  state.layers = [];
  state.selection = [];
  pushHist && pushHist();
  refreshLayers && refreshLayers();
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = state.canvasBG || "#fff";
  ctx.fillRect(0, 0, state.canvasW, state.canvasH);
  drawAll && drawAll();
};

// ===== Startup Initializer =====
window.addEventListener("load", () => {
  try {
    // Ensure dimensions
    canvas.width  = state.canvasW || 1200;
    canvas.height = state.canvasH || 800;
    overlay.width   = state.canvasW || 1200;
    overlay.height  = state.canvasH || 800;
// Force visible background (checkerboard pattern)
    const ctx = canvas.getContext("2d");
    const size = 20;
    for (let y = 0; y < canvas.height; y += size) {
      for (let x = 0; x < canvas.width; x += size) {
        ctx.fillStyle = ((x/size + y/size) % 2 === 0) ? "#ddd" : "#fff";
        ctx.fillRect(x, y, size, size);
      }
    }

    // Then let the normal functions run
    refreshLayers && refreshLayers();
    drawAll && drawAll();

    console.log("Canvas initialized:", canvas.width, canvas.height);
  } catch(e) {
    console.error("Init failed:", e);
  }
});
setTimeout(() => {
  console.log("Canvas element:", document.getElementById("canvas"));
  console.log("Overlay element:", document.getElementById("overlay"));
}, 1000);
setTimeout(() => {
  const c = document.getElementById("canvas");
  if (c) {
    const ctx = c.getContext("2d");
    ctx.fillStyle = "red";
    ctx.fillRect(50, 50, 200, 200);
    console.log("Painted red test square on canvas.");
  }
}, 1500);
setTimeout(() => {
  console.log("Canvas check:", canvas, overlay);
  
  if (canvas) {
    const testCtx = canvas.getContext("2d");
    testCtx.fillStyle = "lime";
    testCtx.fillRect(20, 20, 200, 200);
    console.log("Painted lime test square.");
  }
}, 2000);

</script>